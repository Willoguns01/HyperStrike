// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************
































/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_STRUCTS_HPP_
#define OPENXR_STRUCTS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR structure types.
 * @ingroup structs
 */

/*!
 * @defgroup structs Structures
 * @brief C++ projections of OpenXR structure types, with easier init but identical layout.
 * @ingroup wrappers
 *
 * These are all implicitly convertible to a reference-to-const to their corresponding raw C types, so you can treat them as you otherwise might.
 */
/*!
 * @defgroup typedstructs Typed/chainable structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field.
 * @ingroup structs
 */
/*!
 * @defgroup abstracttypedstructs Abstract typed structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field,
 * but no specific type enum value of their own: these are the "base structs" in OpenXR.
 * @ingroup typedstructs
 */

// for strncpy_s
#ifndef __STDC_WANT_LIB_EXT1__
#define __STDC_WANT_LIB_EXT1__ 1
#endif
#include <string.h>

#include "openxr_enums.hpp"
#include "openxr_flags.hpp"
#include "openxr_version.hpp"
#include "openxr_time.hpp"
#include "openxr_atoms.hpp"
#include "openxr_bool.hpp"
#include "openxr_handles.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

namespace OPENXR_HPP_NAMESPACE {

namespace impl {

    class XR_MAY_ALIAS InputStructBase {
    protected:
        InputStructBase(StructureType type_,
                        const void* next_ = nullptr)
            : type(type_), next(next_) {}

    public:
        StructureType type;
        const void* next;
    };
     static_assert(sizeof(::XrBaseInStructure) == sizeof(InputStructBase), "Original type and wrapper have different size!"); 

    class XR_MAY_ALIAS OutputStructBase {
    protected:
        OutputStructBase(StructureType type_, void* next_ = nullptr)
            : type(type_), next(next_) {}

    public:
        StructureType type;
        void* next;
    };
     static_assert(sizeof(::XrBaseOutStructure) == sizeof(OutputStructBase), "Original type and wrapper have different size!"); 
}  // namespace impl

/*!
 * @brief Wrapper for XrEventDataBuffer
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBuffer>
 * 
 * @xrentity{XrEventDataBuffer}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataBuffer : public impl::InputStructBase {
private:
    using Parent = impl::InputStructBase;

protected:
    EventDataBuffer(StructureType type_, const void* next_ = nullptr)
        : Parent(type_, next_), varying{} {}

public:
    //! Default constructor - use this one.
    EventDataBuffer() : Parent(StructureType::EventDataBuffer), varying{} {
        (void)varying;
    }
    //! @brief "Put" function for assigning as null then getting the address of the raw pointer to pass as function output parameter.
    XrEventDataBuffer* put(bool clear = true) noexcept {
        if (clear) {
            auto oldNext = next;
            *this = {};
            next = oldNext;
        }
        return reinterpret_cast<XrEventDataBuffer*>(this);
    }

    //! Gets a pointer to the underlying raw XrEventDataBuffer type.
    XrEventDataBuffer* get() noexcept {
        return reinterpret_cast<XrEventDataBuffer*>(this);
    }

    //! Gets a pointer to the underlying raw XrEventDataBuffer type.
    XrEventDataBuffer const* get() const noexcept {
        return reinterpret_cast<XrEventDataBuffer const*>(this);
    }

private:
    uint8_t varying[4000];
};
 static_assert(sizeof(::XrEventDataBuffer) == sizeof(EventDataBuffer), "Original type and wrapper have different size!"); 

/*!
 * @brief Free "put" function for clearing and getting the address of the raw XrEventDataBuffer in an EventDataBuffer.
 * @relates EventDataBuffer
 * @ingroup utility_accessors
 */
OPENXR_HPP_INLINE XrEventDataBuffer* put(EventDataBuffer& v, bool clear = true) noexcept {
    return v.put(clear);
}
































    
/*!
 * C++ projection of XrApiLayerProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApiLayerProperties>
 * @xrentity{XrApiLayerProperties}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ApiLayerProperties : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ApiLayerProperties (
            void * next_ = nullptr)

: Parent(StructureType::APILayerProperties
             , next_)
            {}

        //! Default copy constructor
        ApiLayerProperties(const ApiLayerProperties& rhs) = default;
        //! Default copy assignment
        ApiLayerProperties& operator=(const ApiLayerProperties& rhs) = default;
        //! Copy construct from raw
        ApiLayerProperties(const XrApiLayerProperties& rhs) : ApiLayerProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ApiLayerProperties& operator=(const XrApiLayerProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrApiLayerProperties &() const { return *reinterpret_cast<const XrApiLayerProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrApiLayerProperties &() {
            return *reinterpret_cast<XrApiLayerProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrApiLayerProperties
        XrApiLayerProperties const* get() const noexcept { return reinterpret_cast<XrApiLayerProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrApiLayerProperties.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrApiLayerProperties * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ApiLayerProperties{};next = oldNext;}
            return reinterpret_cast<XrApiLayerProperties*>(this);
        }
        char layerName[XR_MAX_API_LAYER_NAME_SIZE];
        Version specVersion;
        uint32_t layerVersion;
        char description[XR_MAX_API_LAYER_DESCRIPTION_SIZE];
    };
     static_assert(sizeof(XrApiLayerProperties) == sizeof(ApiLayerProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrApiLayerProperties pointer to const from a ApiLayerProperties reference to const.
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrApiLayerProperties const* get(ApiLayerProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ApiLayerProperties as the address of a raw XrApiLayerProperties
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrApiLayerProperties * put(ApiLayerProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrExtensionProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtensionProperties>
 * @xrentity{XrExtensionProperties}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ExtensionProperties : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ExtensionProperties (
            void * next_ = nullptr)

: Parent(StructureType::ExtensionProperties
             , next_)
            {}

        //! Default copy constructor
        ExtensionProperties(const ExtensionProperties& rhs) = default;
        //! Default copy assignment
        ExtensionProperties& operator=(const ExtensionProperties& rhs) = default;
        //! Copy construct from raw
        ExtensionProperties(const XrExtensionProperties& rhs) : ExtensionProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ExtensionProperties& operator=(const XrExtensionProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExtensionProperties &() const { return *reinterpret_cast<const XrExtensionProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExtensionProperties &() {
            return *reinterpret_cast<XrExtensionProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrExtensionProperties
        XrExtensionProperties const* get() const noexcept { return reinterpret_cast<XrExtensionProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExtensionProperties.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrExtensionProperties * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ExtensionProperties{};next = oldNext;}
            return reinterpret_cast<XrExtensionProperties*>(this);
        }
        char extensionName[XR_MAX_EXTENSION_NAME_SIZE];
        uint32_t extensionVersion;
    };
     static_assert(sizeof(XrExtensionProperties) == sizeof(ExtensionProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExtensionProperties pointer to const from a ExtensionProperties reference to const.
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtensionProperties const* get(ExtensionProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ExtensionProperties as the address of a raw XrExtensionProperties
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtensionProperties * put(ExtensionProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrApplicationInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApplicationInfo>
 * @xrentity{XrApplicationInfo}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ApplicationInfo 
    {
    public:
        //! Constructor initializing all members.
                ApplicationInfo (
 const char* applicationName_,  uint32_t applicationVersion_,  const char* engineName_,  uint32_t engineVersion_,  const Version& apiVersion_                  )
: applicationVersion {applicationVersion_}
, engineVersion {engineVersion_}
, apiVersion {apiVersion_}
        {
            if (nullptr != applicationName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
    strncpy_s(applicationName, XR_MAX_APPLICATION_NAME_SIZE, applicationName_, XR_MAX_APPLICATION_NAME_SIZE );
#else
    strncpy(applicationName, applicationName_, XR_MAX_APPLICATION_NAME_SIZE - 1);
    applicationName[XR_MAX_APPLICATION_NAME_SIZE - 1] = '\0';
#endif
}

            if (nullptr != engineName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
    strncpy_s(engineName, XR_MAX_ENGINE_NAME_SIZE, engineName_, XR_MAX_ENGINE_NAME_SIZE );
#else
    strncpy(engineName, engineName_, XR_MAX_ENGINE_NAME_SIZE - 1);
    engineName[XR_MAX_ENGINE_NAME_SIZE - 1] = '\0';
#endif
}

        }


        //! Default/empty constructor
                 ApplicationInfo (
            )

: applicationVersion{0}
, engineVersion{0}
, apiVersion{}
            {}

        //! Default copy constructor
        ApplicationInfo(const ApplicationInfo& rhs) = default;
        //! Default copy assignment
        ApplicationInfo& operator=(const ApplicationInfo& rhs) = default;
        //! Copy construct from raw
        ApplicationInfo(const XrApplicationInfo& rhs) : ApplicationInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ApplicationInfo& operator=(const XrApplicationInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrApplicationInfo &() const { return *reinterpret_cast<const XrApplicationInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrApplicationInfo &() {
            return *reinterpret_cast<XrApplicationInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrApplicationInfo
        XrApplicationInfo const* get() const noexcept { return reinterpret_cast<XrApplicationInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrApplicationInfo.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrApplicationInfo * put(bool clear = true) noexcept {
            if (clear) {*this = ApplicationInfo{};}
            return reinterpret_cast<XrApplicationInfo*>(this);
        }
        char applicationName[XR_MAX_APPLICATION_NAME_SIZE];
        uint32_t applicationVersion;
        char engineName[XR_MAX_ENGINE_NAME_SIZE];
        uint32_t engineVersion;
        Version apiVersion;
    };
     static_assert(sizeof(XrApplicationInfo) == sizeof(ApplicationInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrApplicationInfo pointer to const from a ApplicationInfo reference to const.
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrApplicationInfo const* get(ApplicationInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ApplicationInfo as the address of a raw XrApplicationInfo
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrApplicationInfo * put(ApplicationInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrInstanceCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfo>
 * @xrentity{XrInstanceCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InstanceCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                InstanceCreateInfo (
 const InstanceCreateFlags& createFlags_,  const ApplicationInfo& applicationInfo_,  uint32_t enabledApiLayerCount_,  const char* const* enabledApiLayerNames_,  uint32_t enabledExtensionCount_,  const char* const* enabledExtensionNames_,  const void * next_ = nullptr                  )
: Parent(StructureType::InstanceCreateInfo
, next_)
, createFlags {createFlags_}
, applicationInfo {applicationInfo_}
, enabledApiLayerCount {enabledApiLayerCount_}
, enabledApiLayerNames {enabledApiLayerNames_}
, enabledExtensionCount {enabledExtensionCount_}
, enabledExtensionNames {enabledExtensionNames_}
        {
        }


        //! Default/empty constructor
                 InstanceCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::InstanceCreateInfo
             , next_)
, createFlags{}
, applicationInfo{}
, enabledApiLayerCount{0}
, enabledApiLayerNames{nullptr}
, enabledExtensionCount{0}
, enabledExtensionNames{nullptr}
            {}

        //! Default copy constructor
        InstanceCreateInfo(const InstanceCreateInfo& rhs) = default;
        //! Default copy assignment
        InstanceCreateInfo& operator=(const InstanceCreateInfo& rhs) = default;
        //! Copy construct from raw
        InstanceCreateInfo(const XrInstanceCreateInfo& rhs) : InstanceCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InstanceCreateInfo& operator=(const XrInstanceCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInstanceCreateInfo &() const { return *reinterpret_cast<const XrInstanceCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInstanceCreateInfo &() {
            return *reinterpret_cast<XrInstanceCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrInstanceCreateInfo
        XrInstanceCreateInfo const* get() const noexcept { return reinterpret_cast<XrInstanceCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInstanceCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInstanceCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InstanceCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrInstanceCreateInfo*>(this);
        }
        InstanceCreateFlags createFlags;
        ApplicationInfo applicationInfo;
        uint32_t enabledApiLayerCount;
        const char* const* enabledApiLayerNames;
        uint32_t enabledExtensionCount;
        const char* const* enabledExtensionNames;
    };
     static_assert(sizeof(XrInstanceCreateInfo) == sizeof(InstanceCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfo pointer to const from a InstanceCreateInfo reference to const.
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInstanceCreateInfo const* get(InstanceCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfo as the address of a raw XrInstanceCreateInfo
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInstanceCreateInfo * put(InstanceCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrInstanceProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceProperties>
 * @xrentity{XrInstanceProperties}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InstanceProperties : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 InstanceProperties (
            void * next_ = nullptr)

: Parent(StructureType::InstanceProperties
             , next_)
            {}

        //! Default copy constructor
        InstanceProperties(const InstanceProperties& rhs) = default;
        //! Default copy assignment
        InstanceProperties& operator=(const InstanceProperties& rhs) = default;
        //! Copy construct from raw
        InstanceProperties(const XrInstanceProperties& rhs) : InstanceProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InstanceProperties& operator=(const XrInstanceProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInstanceProperties &() const { return *reinterpret_cast<const XrInstanceProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInstanceProperties &() {
            return *reinterpret_cast<XrInstanceProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrInstanceProperties
        XrInstanceProperties const* get() const noexcept { return reinterpret_cast<XrInstanceProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInstanceProperties.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInstanceProperties * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InstanceProperties{};next = oldNext;}
            return reinterpret_cast<XrInstanceProperties*>(this);
        }
        Version runtimeVersion;
        char runtimeName[XR_MAX_RUNTIME_NAME_SIZE];
    };
     static_assert(sizeof(XrInstanceProperties) == sizeof(InstanceProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInstanceProperties pointer to const from a InstanceProperties reference to const.
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInstanceProperties const* get(InstanceProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceProperties as the address of a raw XrInstanceProperties
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInstanceProperties * put(InstanceProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSystemGetInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGetInfo>
 * @xrentity{XrSystemGetInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemGetInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SystemGetInfo (
 const FormFactor& formFactor_,  const void * next_ = nullptr                  )
: Parent(StructureType::SystemGetInfo
, next_)
, formFactor {formFactor_}
        {
        }


        //! Default/empty constructor
                 SystemGetInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SystemGetInfo
             , next_)
, formFactor{}
            {}

        //! Default copy constructor
        SystemGetInfo(const SystemGetInfo& rhs) = default;
        //! Default copy assignment
        SystemGetInfo& operator=(const SystemGetInfo& rhs) = default;
        //! Copy construct from raw
        SystemGetInfo(const XrSystemGetInfo& rhs) : SystemGetInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemGetInfo& operator=(const XrSystemGetInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemGetInfo &() const { return *reinterpret_cast<const XrSystemGetInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemGetInfo &() {
            return *reinterpret_cast<XrSystemGetInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemGetInfo
        XrSystemGetInfo const* get() const noexcept { return reinterpret_cast<XrSystemGetInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemGetInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemGetInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemGetInfo{};next = oldNext;}
            return reinterpret_cast<XrSystemGetInfo*>(this);
        }
        FormFactor formFactor;
    };
     static_assert(sizeof(XrSystemGetInfo) == sizeof(SystemGetInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemGetInfo pointer to const from a SystemGetInfo reference to const.
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemGetInfo const* get(SystemGetInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGetInfo as the address of a raw XrSystemGetInfo
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemGetInfo * put(SystemGetInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSystemGraphicsProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGraphicsProperties>
 * @xrentity{XrSystemGraphicsProperties}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS SystemGraphicsProperties 
    {
    public:
        //! Constructor initializing all members.
                SystemGraphicsProperties (
 uint32_t maxSwapchainImageHeight_,  uint32_t maxSwapchainImageWidth_,  uint32_t maxLayerCount_                  )
: maxSwapchainImageHeight {maxSwapchainImageHeight_}
, maxSwapchainImageWidth {maxSwapchainImageWidth_}
, maxLayerCount {maxLayerCount_}
        {
        }


        //! Default/empty constructor
                 SystemGraphicsProperties (
            )

: maxSwapchainImageHeight{0}
, maxSwapchainImageWidth{0}
, maxLayerCount{0}
            {}

        //! Default copy constructor
        SystemGraphicsProperties(const SystemGraphicsProperties& rhs) = default;
        //! Default copy assignment
        SystemGraphicsProperties& operator=(const SystemGraphicsProperties& rhs) = default;
        //! Copy construct from raw
        SystemGraphicsProperties(const XrSystemGraphicsProperties& rhs) : SystemGraphicsProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemGraphicsProperties& operator=(const XrSystemGraphicsProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemGraphicsProperties &() const { return *reinterpret_cast<const XrSystemGraphicsProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemGraphicsProperties &() {
            return *reinterpret_cast<XrSystemGraphicsProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemGraphicsProperties
        XrSystemGraphicsProperties const* get() const noexcept { return reinterpret_cast<XrSystemGraphicsProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemGraphicsProperties.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrSystemGraphicsProperties * put(bool clear = true) noexcept {
            if (clear) {*this = SystemGraphicsProperties{};}
            return reinterpret_cast<XrSystemGraphicsProperties*>(this);
        }
        uint32_t maxSwapchainImageHeight;
        uint32_t maxSwapchainImageWidth;
        uint32_t maxLayerCount;
    };
     static_assert(sizeof(XrSystemGraphicsProperties) == sizeof(SystemGraphicsProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemGraphicsProperties pointer to const from a SystemGraphicsProperties reference to const.
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemGraphicsProperties const* get(SystemGraphicsProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGraphicsProperties as the address of a raw XrSystemGraphicsProperties
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemGraphicsProperties * put(SystemGraphicsProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSystemTrackingProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemTrackingProperties>
 * @xrentity{XrSystemTrackingProperties}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS SystemTrackingProperties 
    {
    public:
        //! Constructor initializing all members.
                SystemTrackingProperties (
 const Bool32& orientationTracking_,  const Bool32& positionTracking_                  )
: orientationTracking {orientationTracking_}
, positionTracking {positionTracking_}
        {
        }


        //! Default/empty constructor
                 SystemTrackingProperties (
            )

: orientationTracking{false}
, positionTracking{false}
            {}

        //! Default copy constructor
        SystemTrackingProperties(const SystemTrackingProperties& rhs) = default;
        //! Default copy assignment
        SystemTrackingProperties& operator=(const SystemTrackingProperties& rhs) = default;
        //! Copy construct from raw
        SystemTrackingProperties(const XrSystemTrackingProperties& rhs) : SystemTrackingProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemTrackingProperties& operator=(const XrSystemTrackingProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemTrackingProperties &() const { return *reinterpret_cast<const XrSystemTrackingProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemTrackingProperties &() {
            return *reinterpret_cast<XrSystemTrackingProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemTrackingProperties
        XrSystemTrackingProperties const* get() const noexcept { return reinterpret_cast<XrSystemTrackingProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemTrackingProperties.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrSystemTrackingProperties * put(bool clear = true) noexcept {
            if (clear) {*this = SystemTrackingProperties{};}
            return reinterpret_cast<XrSystemTrackingProperties*>(this);
        }
        Bool32 orientationTracking;
        Bool32 positionTracking;
    };
     static_assert(sizeof(XrSystemTrackingProperties) == sizeof(SystemTrackingProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemTrackingProperties pointer to const from a SystemTrackingProperties reference to const.
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemTrackingProperties const* get(SystemTrackingProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemTrackingProperties as the address of a raw XrSystemTrackingProperties
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemTrackingProperties * put(SystemTrackingProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSystemProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemProperties>
 * @xrentity{XrSystemProperties}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemProperties : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemProperties (
            void * next_ = nullptr)

: Parent(StructureType::SystemProperties
             , next_)
            {}

        //! Default copy constructor
        SystemProperties(const SystemProperties& rhs) = default;
        //! Default copy assignment
        SystemProperties& operator=(const SystemProperties& rhs) = default;
        //! Copy construct from raw
        SystemProperties(const XrSystemProperties& rhs) : SystemProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemProperties& operator=(const XrSystemProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemProperties &() const { return *reinterpret_cast<const XrSystemProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemProperties &() {
            return *reinterpret_cast<XrSystemProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemProperties
        XrSystemProperties const* get() const noexcept { return reinterpret_cast<XrSystemProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemProperties.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemProperties * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemProperties{};next = oldNext;}
            return reinterpret_cast<XrSystemProperties*>(this);
        }
        SystemId systemId;
        uint32_t vendorId;
        char systemName[XR_MAX_SYSTEM_NAME_SIZE];
        SystemGraphicsProperties graphicsProperties;
        SystemTrackingProperties trackingProperties;
    };
     static_assert(sizeof(XrSystemProperties) == sizeof(SystemProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemProperties pointer to const from a SystemProperties reference to const.
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemProperties const* get(SystemProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemProperties as the address of a raw XrSystemProperties
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemProperties * put(SystemProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSessionCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfo>
 * @xrentity{XrSessionCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SessionCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SessionCreateInfo (
 const SessionCreateFlags& createFlags_,  const SystemId& systemId_,  const void * next_ = nullptr                  )
: Parent(StructureType::SessionCreateInfo
, next_)
, createFlags {createFlags_}
, systemId {systemId_}
        {
        }


        //! Default/empty constructor
                 SessionCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SessionCreateInfo
             , next_)
, createFlags{}
, systemId{}
            {}

        //! Default copy constructor
        SessionCreateInfo(const SessionCreateInfo& rhs) = default;
        //! Default copy assignment
        SessionCreateInfo& operator=(const SessionCreateInfo& rhs) = default;
        //! Copy construct from raw
        SessionCreateInfo(const XrSessionCreateInfo& rhs) : SessionCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SessionCreateInfo& operator=(const XrSessionCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSessionCreateInfo &() const { return *reinterpret_cast<const XrSessionCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSessionCreateInfo &() {
            return *reinterpret_cast<XrSessionCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSessionCreateInfo
        XrSessionCreateInfo const* get() const noexcept { return reinterpret_cast<XrSessionCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSessionCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSessionCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SessionCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrSessionCreateInfo*>(this);
        }
        SessionCreateFlags createFlags;
        SystemId systemId;
    };
     static_assert(sizeof(XrSessionCreateInfo) == sizeof(SessionCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSessionCreateInfo pointer to const from a SessionCreateInfo reference to const.
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionCreateInfo const* get(SessionCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfo as the address of a raw XrSessionCreateInfo
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionCreateInfo * put(SessionCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrVector3f
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector3f>
 * @xrentity{XrVector3f}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Vector3f 
    {
    public:
        //! Constructor initializing all members.
                Vector3f (
 float x_,  float y_,  float z_                  )
: x {x_}
, y {y_}
, z {z_}
        {
        }


        //! Default/empty constructor
                 Vector3f (
            )

: x{0.0f}
, y{0.0f}
, z{0.0f}
            {}

        //! Default copy constructor
        Vector3f(const Vector3f& rhs) = default;
        //! Default copy assignment
        Vector3f& operator=(const Vector3f& rhs) = default;
        //! Copy construct from raw
        Vector3f(const XrVector3f& rhs) : Vector3f() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Vector3f& operator=(const XrVector3f& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVector3f &() const { return *reinterpret_cast<const XrVector3f*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVector3f &() {
            return *reinterpret_cast<XrVector3f*>(this);
        }

        //! Accessor for this as the address of a raw XrVector3f
        XrVector3f const* get() const noexcept { return reinterpret_cast<XrVector3f const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVector3f.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrVector3f * put(bool clear = true) noexcept {
            if (clear) {*this = Vector3f{};}
            return reinterpret_cast<XrVector3f*>(this);
        }
        float x;
        float y;
        float z;
    };
     static_assert(sizeof(XrVector3f) == sizeof(Vector3f), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVector3f pointer to const from a Vector3f reference to const.
 * @relates Vector3f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector3f const* get(Vector3f const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector3f as the address of a raw XrVector3f
 * @relates Vector3f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector3f * put(Vector3f &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSpaceVelocity
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceVelocity>
 * @xrentity{XrSpaceVelocity}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceVelocity : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SpaceVelocity (
            void * next_ = nullptr)

: Parent(StructureType::SpaceVelocity
             , next_)
            {}

        //! Default copy constructor
        SpaceVelocity(const SpaceVelocity& rhs) = default;
        //! Default copy assignment
        SpaceVelocity& operator=(const SpaceVelocity& rhs) = default;
        //! Copy construct from raw
        SpaceVelocity(const XrSpaceVelocity& rhs) : SpaceVelocity() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceVelocity& operator=(const XrSpaceVelocity& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceVelocity &() const { return *reinterpret_cast<const XrSpaceVelocity*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceVelocity &() {
            return *reinterpret_cast<XrSpaceVelocity*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceVelocity
        XrSpaceVelocity const* get() const noexcept { return reinterpret_cast<XrSpaceVelocity const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceVelocity.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceVelocity * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceVelocity{};next = oldNext;}
            return reinterpret_cast<XrSpaceVelocity*>(this);
        }
        SpaceVelocityFlags velocityFlags;
        Vector3f linearVelocity;
        Vector3f angularVelocity;
    };
     static_assert(sizeof(XrSpaceVelocity) == sizeof(SpaceVelocity), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceVelocity pointer to const from a SpaceVelocity reference to const.
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceVelocity const* get(SpaceVelocity const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceVelocity as the address of a raw XrSpaceVelocity
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceVelocity * put(SpaceVelocity &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrQuaternionf
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrQuaternionf>
 * @xrentity{XrQuaternionf}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Quaternionf 
    {
    public:
        //! Constructor initializing all members.
                Quaternionf (
 float x_,  float y_,  float z_,  float w_                  )
: x {x_}
, y {y_}
, z {z_}
, w {w_}
        {
        }


        //! Default/empty constructor
                 Quaternionf (
            )

: x{0.0f}
, y{0.0f}
, z{0.0f}
, w{1.0f}
            {}

        //! Default copy constructor
        Quaternionf(const Quaternionf& rhs) = default;
        //! Default copy assignment
        Quaternionf& operator=(const Quaternionf& rhs) = default;
        //! Copy construct from raw
        Quaternionf(const XrQuaternionf& rhs) : Quaternionf() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Quaternionf& operator=(const XrQuaternionf& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrQuaternionf &() const { return *reinterpret_cast<const XrQuaternionf*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrQuaternionf &() {
            return *reinterpret_cast<XrQuaternionf*>(this);
        }

        //! Accessor for this as the address of a raw XrQuaternionf
        XrQuaternionf const* get() const noexcept { return reinterpret_cast<XrQuaternionf const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrQuaternionf.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrQuaternionf * put(bool clear = true) noexcept {
            if (clear) {*this = Quaternionf{};}
            return reinterpret_cast<XrQuaternionf*>(this);
        }
        float x;
        float y;
        float z;
        float w;
    };
     static_assert(sizeof(XrQuaternionf) == sizeof(Quaternionf), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrQuaternionf pointer to const from a Quaternionf reference to const.
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrQuaternionf const* get(Quaternionf const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Quaternionf as the address of a raw XrQuaternionf
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrQuaternionf * put(Quaternionf &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrPosef
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPosef>
 * @xrentity{XrPosef}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Posef 
    {
    public:
        //! Constructor initializing all members.
                Posef (
 const Quaternionf& orientation_,  const Vector3f& position_                  )
: orientation {orientation_}
, position {position_}
        {
        }


        //! Default/empty constructor
                 Posef (
            )

: orientation{}
, position{}
            {}

        //! Default copy constructor
        Posef(const Posef& rhs) = default;
        //! Default copy assignment
        Posef& operator=(const Posef& rhs) = default;
        //! Copy construct from raw
        Posef(const XrPosef& rhs) : Posef() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Posef& operator=(const XrPosef& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPosef &() const { return *reinterpret_cast<const XrPosef*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPosef &() {
            return *reinterpret_cast<XrPosef*>(this);
        }

        //! Accessor for this as the address of a raw XrPosef
        XrPosef const* get() const noexcept { return reinterpret_cast<XrPosef const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPosef.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrPosef * put(bool clear = true) noexcept {
            if (clear) {*this = Posef{};}
            return reinterpret_cast<XrPosef*>(this);
        }
        Quaternionf orientation;
        Vector3f position;
    };
     static_assert(sizeof(XrPosef) == sizeof(Posef), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPosef pointer to const from a Posef reference to const.
 * @relates Posef
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPosef const* get(Posef const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Posef as the address of a raw XrPosef
 * @relates Posef
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPosef * put(Posef &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrReferenceSpaceCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceCreateInfo>
 * @xrentity{XrReferenceSpaceCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ReferenceSpaceCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ReferenceSpaceCreateInfo (
 const ReferenceSpaceType& referenceSpaceType_,  const Posef& poseInReferenceSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::ReferenceSpaceCreateInfo
, next_)
, referenceSpaceType {referenceSpaceType_}
, poseInReferenceSpace {poseInReferenceSpace_}
        {
        }


        //! Default/empty constructor
                 ReferenceSpaceCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ReferenceSpaceCreateInfo
             , next_)
, referenceSpaceType{}
, poseInReferenceSpace{}
            {}

        //! Default copy constructor
        ReferenceSpaceCreateInfo(const ReferenceSpaceCreateInfo& rhs) = default;
        //! Default copy assignment
        ReferenceSpaceCreateInfo& operator=(const ReferenceSpaceCreateInfo& rhs) = default;
        //! Copy construct from raw
        ReferenceSpaceCreateInfo(const XrReferenceSpaceCreateInfo& rhs) : ReferenceSpaceCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ReferenceSpaceCreateInfo& operator=(const XrReferenceSpaceCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrReferenceSpaceCreateInfo &() const { return *reinterpret_cast<const XrReferenceSpaceCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrReferenceSpaceCreateInfo &() {
            return *reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrReferenceSpaceCreateInfo
        XrReferenceSpaceCreateInfo const* get() const noexcept { return reinterpret_cast<XrReferenceSpaceCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrReferenceSpaceCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrReferenceSpaceCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ReferenceSpaceCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
        }
        ReferenceSpaceType referenceSpaceType;
        Posef poseInReferenceSpace;
    };
     static_assert(sizeof(XrReferenceSpaceCreateInfo) == sizeof(ReferenceSpaceCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrReferenceSpaceCreateInfo pointer to const from a ReferenceSpaceCreateInfo reference to const.
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo const* get(ReferenceSpaceCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ReferenceSpaceCreateInfo as the address of a raw XrReferenceSpaceCreateInfo
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo * put(ReferenceSpaceCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrExtent2Df
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Df>
 * @xrentity{XrExtent2Df}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Extent2Df 
    {
    public:
        //! Constructor initializing all members.
                Extent2Df (
 float width_,  float height_                  )
: width {width_}
, height {height_}
        {
        }


        //! Default/empty constructor
                 Extent2Df (
            )

: width{0.0f}
, height{0.0f}
            {}

        //! Default copy constructor
        Extent2Df(const Extent2Df& rhs) = default;
        //! Default copy assignment
        Extent2Df& operator=(const Extent2Df& rhs) = default;
        //! Copy construct from raw
        Extent2Df(const XrExtent2Df& rhs) : Extent2Df() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Extent2Df& operator=(const XrExtent2Df& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExtent2Df &() const { return *reinterpret_cast<const XrExtent2Df*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExtent2Df &() {
            return *reinterpret_cast<XrExtent2Df*>(this);
        }

        //! Accessor for this as the address of a raw XrExtent2Df
        XrExtent2Df const* get() const noexcept { return reinterpret_cast<XrExtent2Df const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Df.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrExtent2Df * put(bool clear = true) noexcept {
            if (clear) {*this = Extent2Df{};}
            return reinterpret_cast<XrExtent2Df*>(this);
        }
        float width;
        float height;
    };
     static_assert(sizeof(XrExtent2Df) == sizeof(Extent2Df), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExtent2Df pointer to const from a Extent2Df reference to const.
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent2Df const* get(Extent2Df const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Df as the address of a raw XrExtent2Df
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent2Df * put(Extent2Df &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionSpaceCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSpaceCreateInfo>
 * @xrentity{XrActionSpaceCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionSpaceCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ActionSpaceCreateInfo (
 const Action& action_,  const Path& subactionPath_,  const Posef& poseInActionSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::ActionSpaceCreateInfo
, next_)
, action {action_}
, subactionPath {subactionPath_}
, poseInActionSpace {poseInActionSpace_}
        {
        }


        //! Default/empty constructor
                 ActionSpaceCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ActionSpaceCreateInfo
             , next_)
, action{}
, subactionPath{}
, poseInActionSpace{}
            {}

        //! Default copy constructor
        ActionSpaceCreateInfo(const ActionSpaceCreateInfo& rhs) = default;
        //! Default copy assignment
        ActionSpaceCreateInfo& operator=(const ActionSpaceCreateInfo& rhs) = default;
        //! Copy construct from raw
        ActionSpaceCreateInfo(const XrActionSpaceCreateInfo& rhs) : ActionSpaceCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionSpaceCreateInfo& operator=(const XrActionSpaceCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionSpaceCreateInfo &() const { return *reinterpret_cast<const XrActionSpaceCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionSpaceCreateInfo &() {
            return *reinterpret_cast<XrActionSpaceCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrActionSpaceCreateInfo
        XrActionSpaceCreateInfo const* get() const noexcept { return reinterpret_cast<XrActionSpaceCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionSpaceCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionSpaceCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionSpaceCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrActionSpaceCreateInfo*>(this);
        }
        Action action;
        Path subactionPath;
        Posef poseInActionSpace;
    };
     static_assert(sizeof(XrActionSpaceCreateInfo) == sizeof(ActionSpaceCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionSpaceCreateInfo pointer to const from a ActionSpaceCreateInfo reference to const.
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionSpaceCreateInfo const* get(ActionSpaceCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSpaceCreateInfo as the address of a raw XrActionSpaceCreateInfo
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionSpaceCreateInfo * put(ActionSpaceCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSpaceLocation
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceLocation>
 * @xrentity{XrSpaceLocation}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceLocation : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SpaceLocation (
            void * next_ = nullptr)

: Parent(StructureType::SpaceLocation
             , next_)
            {}

        //! Default copy constructor
        SpaceLocation(const SpaceLocation& rhs) = default;
        //! Default copy assignment
        SpaceLocation& operator=(const SpaceLocation& rhs) = default;
        //! Copy construct from raw
        SpaceLocation(const XrSpaceLocation& rhs) : SpaceLocation() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceLocation& operator=(const XrSpaceLocation& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceLocation &() const { return *reinterpret_cast<const XrSpaceLocation*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceLocation &() {
            return *reinterpret_cast<XrSpaceLocation*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceLocation
        XrSpaceLocation const* get() const noexcept { return reinterpret_cast<XrSpaceLocation const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceLocation.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceLocation * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceLocation{};next = oldNext;}
            return reinterpret_cast<XrSpaceLocation*>(this);
        }
        SpaceLocationFlags locationFlags;
        Posef pose;
    };
     static_assert(sizeof(XrSpaceLocation) == sizeof(SpaceLocation), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceLocation pointer to const from a SpaceLocation reference to const.
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceLocation const* get(SpaceLocation const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceLocation as the address of a raw XrSpaceLocation
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceLocation * put(SpaceLocation &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrViewConfigurationProperties
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationProperties>
 * @xrentity{XrViewConfigurationProperties}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewConfigurationProperties : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ViewConfigurationProperties (
            void * next_ = nullptr)

: Parent(StructureType::ViewConfigurationProperties
             , next_)
            {}

        //! Default copy constructor
        ViewConfigurationProperties(const ViewConfigurationProperties& rhs) = default;
        //! Default copy assignment
        ViewConfigurationProperties& operator=(const ViewConfigurationProperties& rhs) = default;
        //! Copy construct from raw
        ViewConfigurationProperties(const XrViewConfigurationProperties& rhs) : ViewConfigurationProperties() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewConfigurationProperties& operator=(const XrViewConfigurationProperties& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewConfigurationProperties &() const { return *reinterpret_cast<const XrViewConfigurationProperties*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewConfigurationProperties &() {
            return *reinterpret_cast<XrViewConfigurationProperties*>(this);
        }

        //! Accessor for this as the address of a raw XrViewConfigurationProperties
        XrViewConfigurationProperties const* get() const noexcept { return reinterpret_cast<XrViewConfigurationProperties const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationProperties.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewConfigurationProperties * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewConfigurationProperties{};next = oldNext;}
            return reinterpret_cast<XrViewConfigurationProperties*>(this);
        }
        ViewConfigurationType viewConfigurationType;
        Bool32 fovMutable;
    };
     static_assert(sizeof(XrViewConfigurationProperties) == sizeof(ViewConfigurationProperties), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewConfigurationProperties pointer to const from a ViewConfigurationProperties reference to const.
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationProperties const* get(ViewConfigurationProperties const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationProperties as the address of a raw XrViewConfigurationProperties
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationProperties * put(ViewConfigurationProperties &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrViewConfigurationView
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationView>
 * @xrentity{XrViewConfigurationView}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewConfigurationView : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ViewConfigurationView (
            void * next_ = nullptr)

: Parent(StructureType::ViewConfigurationView
             , next_)
            {}

        //! Default copy constructor
        ViewConfigurationView(const ViewConfigurationView& rhs) = default;
        //! Default copy assignment
        ViewConfigurationView& operator=(const ViewConfigurationView& rhs) = default;
        //! Copy construct from raw
        ViewConfigurationView(const XrViewConfigurationView& rhs) : ViewConfigurationView() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewConfigurationView& operator=(const XrViewConfigurationView& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewConfigurationView &() const { return *reinterpret_cast<const XrViewConfigurationView*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewConfigurationView &() {
            return *reinterpret_cast<XrViewConfigurationView*>(this);
        }

        //! Accessor for this as the address of a raw XrViewConfigurationView
        XrViewConfigurationView const* get() const noexcept { return reinterpret_cast<XrViewConfigurationView const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationView.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewConfigurationView * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewConfigurationView{};next = oldNext;}
            return reinterpret_cast<XrViewConfigurationView*>(this);
        }
        uint32_t recommendedImageRectWidth;
        uint32_t maxImageRectWidth;
        uint32_t recommendedImageRectHeight;
        uint32_t maxImageRectHeight;
        uint32_t recommendedSwapchainSampleCount;
        uint32_t maxSwapchainSampleCount;
    };
     static_assert(sizeof(XrViewConfigurationView) == sizeof(ViewConfigurationView), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewConfigurationView pointer to const from a ViewConfigurationView reference to const.
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationView const* get(ViewConfigurationView const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationView as the address of a raw XrViewConfigurationView
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationView * put(ViewConfigurationView &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSwapchainCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfo>
 * @xrentity{XrSwapchainCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SwapchainCreateInfo (
 const SwapchainCreateFlags& createFlags_,  const SwapchainUsageFlags& usageFlags_,  int64_t format_,  uint32_t sampleCount_,  uint32_t width_,  uint32_t height_,  uint32_t faceCount_,  uint32_t arraySize_,  uint32_t mipCount_,  const void * next_ = nullptr                  )
: Parent(StructureType::SwapchainCreateInfo
, next_)
, createFlags {createFlags_}
, usageFlags {usageFlags_}
, format {format_}
, sampleCount {sampleCount_}
, width {width_}
, height {height_}
, faceCount {faceCount_}
, arraySize {arraySize_}
, mipCount {mipCount_}
        {
        }


        //! Default/empty constructor
                 SwapchainCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SwapchainCreateInfo
             , next_)
, createFlags{}
, usageFlags{}
, format{0}
, sampleCount{0}
, width{0}
, height{0}
, faceCount{0}
, arraySize{0}
, mipCount{0}
            {}

        //! Default copy constructor
        SwapchainCreateInfo(const SwapchainCreateInfo& rhs) = default;
        //! Default copy assignment
        SwapchainCreateInfo& operator=(const SwapchainCreateInfo& rhs) = default;
        //! Copy construct from raw
        SwapchainCreateInfo(const XrSwapchainCreateInfo& rhs) : SwapchainCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainCreateInfo& operator=(const XrSwapchainCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainCreateInfo &() const { return *reinterpret_cast<const XrSwapchainCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainCreateInfo &() {
            return *reinterpret_cast<XrSwapchainCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainCreateInfo
        XrSwapchainCreateInfo const* get() const noexcept { return reinterpret_cast<XrSwapchainCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrSwapchainCreateInfo*>(this);
        }
        SwapchainCreateFlags createFlags;
        SwapchainUsageFlags usageFlags;
        int64_t format;
        uint32_t sampleCount;
        uint32_t width;
        uint32_t height;
        uint32_t faceCount;
        uint32_t arraySize;
        uint32_t mipCount;
    };
     static_assert(sizeof(XrSwapchainCreateInfo) == sizeof(SwapchainCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfo pointer to const from a SwapchainCreateInfo reference to const.
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainCreateInfo const* get(SwapchainCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainCreateInfo as the address of a raw XrSwapchainCreateInfo
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainCreateInfo * put(SwapchainCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSwapchainImageBaseHeader
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageBaseHeader>
 * @xrentity{XrSwapchainImageBaseHeader}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageBaseHeader : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                SwapchainImageBaseHeader (
  StructureType type_ ,  void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageBaseHeader &() const { return *reinterpret_cast<const XrSwapchainImageBaseHeader*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageBaseHeader &() {
            return *reinterpret_cast<XrSwapchainImageBaseHeader*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainImageBaseHeader
        XrSwapchainImageBaseHeader const* get() const noexcept { return reinterpret_cast<XrSwapchainImageBaseHeader const *>(this); }

    };
     static_assert(sizeof(XrSwapchainImageBaseHeader) == sizeof(SwapchainImageBaseHeader), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageBaseHeader pointer to const from a SwapchainImageBaseHeader reference to const.
 * @relates SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get(SwapchainImageBaseHeader const& s) {
        return s.get();
    }

































    
/*!
 * C++ projection of XrSwapchainImageAcquireInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageAcquireInfo>
 * @xrentity{XrSwapchainImageAcquireInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageAcquireInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Default/empty constructor
                 SwapchainImageAcquireInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SwapchainImageAcquireInfo
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageAcquireInfo(const SwapchainImageAcquireInfo& rhs) = default;
        //! Default copy assignment
        SwapchainImageAcquireInfo& operator=(const SwapchainImageAcquireInfo& rhs) = default;
        //! Copy construct from raw
        SwapchainImageAcquireInfo(const XrSwapchainImageAcquireInfo& rhs) : SwapchainImageAcquireInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageAcquireInfo& operator=(const XrSwapchainImageAcquireInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageAcquireInfo &() const { return *reinterpret_cast<const XrSwapchainImageAcquireInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageAcquireInfo &() {
            return *reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainImageAcquireInfo
        XrSwapchainImageAcquireInfo const* get() const noexcept { return reinterpret_cast<XrSwapchainImageAcquireInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageAcquireInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageAcquireInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageAcquireInfo{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
        }
    };
     static_assert(sizeof(XrSwapchainImageAcquireInfo) == sizeof(SwapchainImageAcquireInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageAcquireInfo pointer to const from a SwapchainImageAcquireInfo reference to const.
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo const* get(SwapchainImageAcquireInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageAcquireInfo as the address of a raw XrSwapchainImageAcquireInfo
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo * put(SwapchainImageAcquireInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSwapchainImageWaitInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageWaitInfo>
 * @xrentity{XrSwapchainImageWaitInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageWaitInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SwapchainImageWaitInfo (
 const Duration& timeout_,  const void * next_ = nullptr                  )
: Parent(StructureType::SwapchainImageWaitInfo
, next_)
, timeout {timeout_}
        {
        }


        //! Default/empty constructor
                 SwapchainImageWaitInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SwapchainImageWaitInfo
             , next_)
, timeout{}
            {}

        //! Default copy constructor
        SwapchainImageWaitInfo(const SwapchainImageWaitInfo& rhs) = default;
        //! Default copy assignment
        SwapchainImageWaitInfo& operator=(const SwapchainImageWaitInfo& rhs) = default;
        //! Copy construct from raw
        SwapchainImageWaitInfo(const XrSwapchainImageWaitInfo& rhs) : SwapchainImageWaitInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageWaitInfo& operator=(const XrSwapchainImageWaitInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageWaitInfo &() const { return *reinterpret_cast<const XrSwapchainImageWaitInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageWaitInfo &() {
            return *reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainImageWaitInfo
        XrSwapchainImageWaitInfo const* get() const noexcept { return reinterpret_cast<XrSwapchainImageWaitInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageWaitInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageWaitInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageWaitInfo{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
        }
        Duration timeout;
    };
     static_assert(sizeof(XrSwapchainImageWaitInfo) == sizeof(SwapchainImageWaitInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageWaitInfo pointer to const from a SwapchainImageWaitInfo reference to const.
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo const* get(SwapchainImageWaitInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageWaitInfo as the address of a raw XrSwapchainImageWaitInfo
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo * put(SwapchainImageWaitInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSwapchainImageReleaseInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageReleaseInfo>
 * @xrentity{XrSwapchainImageReleaseInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageReleaseInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Default/empty constructor
                 SwapchainImageReleaseInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SwapchainImageReleaseInfo
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageReleaseInfo(const SwapchainImageReleaseInfo& rhs) = default;
        //! Default copy assignment
        SwapchainImageReleaseInfo& operator=(const SwapchainImageReleaseInfo& rhs) = default;
        //! Copy construct from raw
        SwapchainImageReleaseInfo(const XrSwapchainImageReleaseInfo& rhs) : SwapchainImageReleaseInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageReleaseInfo& operator=(const XrSwapchainImageReleaseInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageReleaseInfo &() const { return *reinterpret_cast<const XrSwapchainImageReleaseInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageReleaseInfo &() {
            return *reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainImageReleaseInfo
        XrSwapchainImageReleaseInfo const* get() const noexcept { return reinterpret_cast<XrSwapchainImageReleaseInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageReleaseInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageReleaseInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageReleaseInfo{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
        }
    };
     static_assert(sizeof(XrSwapchainImageReleaseInfo) == sizeof(SwapchainImageReleaseInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageReleaseInfo pointer to const from a SwapchainImageReleaseInfo reference to const.
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo const* get(SwapchainImageReleaseInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageReleaseInfo as the address of a raw XrSwapchainImageReleaseInfo
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo * put(SwapchainImageReleaseInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSessionBeginInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionBeginInfo>
 * @xrentity{XrSessionBeginInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SessionBeginInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SessionBeginInfo (
 const ViewConfigurationType& primaryViewConfigurationType_,  const void * next_ = nullptr                  )
: Parent(StructureType::SessionBeginInfo
, next_)
, primaryViewConfigurationType {primaryViewConfigurationType_}
        {
        }


        //! Default/empty constructor
                 SessionBeginInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SessionBeginInfo
             , next_)
, primaryViewConfigurationType{}
            {}

        //! Default copy constructor
        SessionBeginInfo(const SessionBeginInfo& rhs) = default;
        //! Default copy assignment
        SessionBeginInfo& operator=(const SessionBeginInfo& rhs) = default;
        //! Copy construct from raw
        SessionBeginInfo(const XrSessionBeginInfo& rhs) : SessionBeginInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SessionBeginInfo& operator=(const XrSessionBeginInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSessionBeginInfo &() const { return *reinterpret_cast<const XrSessionBeginInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSessionBeginInfo &() {
            return *reinterpret_cast<XrSessionBeginInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSessionBeginInfo
        XrSessionBeginInfo const* get() const noexcept { return reinterpret_cast<XrSessionBeginInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSessionBeginInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSessionBeginInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SessionBeginInfo{};next = oldNext;}
            return reinterpret_cast<XrSessionBeginInfo*>(this);
        }
        ViewConfigurationType primaryViewConfigurationType;
    };
     static_assert(sizeof(XrSessionBeginInfo) == sizeof(SessionBeginInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSessionBeginInfo pointer to const from a SessionBeginInfo reference to const.
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionBeginInfo const* get(SessionBeginInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionBeginInfo as the address of a raw XrSessionBeginInfo
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionBeginInfo * put(SessionBeginInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrFrameWaitInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameWaitInfo>
 * @xrentity{XrFrameWaitInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FrameWaitInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Default/empty constructor
                 FrameWaitInfo (
            const void * next_ = nullptr)

: Parent(StructureType::FrameWaitInfo
             , next_)
            {}

        //! Default copy constructor
        FrameWaitInfo(const FrameWaitInfo& rhs) = default;
        //! Default copy assignment
        FrameWaitInfo& operator=(const FrameWaitInfo& rhs) = default;
        //! Copy construct from raw
        FrameWaitInfo(const XrFrameWaitInfo& rhs) : FrameWaitInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FrameWaitInfo& operator=(const XrFrameWaitInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFrameWaitInfo &() const { return *reinterpret_cast<const XrFrameWaitInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFrameWaitInfo &() {
            return *reinterpret_cast<XrFrameWaitInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrFrameWaitInfo
        XrFrameWaitInfo const* get() const noexcept { return reinterpret_cast<XrFrameWaitInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFrameWaitInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFrameWaitInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FrameWaitInfo{};next = oldNext;}
            return reinterpret_cast<XrFrameWaitInfo*>(this);
        }
    };
     static_assert(sizeof(XrFrameWaitInfo) == sizeof(FrameWaitInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFrameWaitInfo pointer to const from a FrameWaitInfo reference to const.
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameWaitInfo const* get(FrameWaitInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameWaitInfo as the address of a raw XrFrameWaitInfo
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameWaitInfo * put(FrameWaitInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrFrameState
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameState>
 * @xrentity{XrFrameState}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FrameState : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 FrameState (
            void * next_ = nullptr)

: Parent(StructureType::FrameState
             , next_)
            {}

        //! Default copy constructor
        FrameState(const FrameState& rhs) = default;
        //! Default copy assignment
        FrameState& operator=(const FrameState& rhs) = default;
        //! Copy construct from raw
        FrameState(const XrFrameState& rhs) : FrameState() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FrameState& operator=(const XrFrameState& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFrameState &() const { return *reinterpret_cast<const XrFrameState*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFrameState &() {
            return *reinterpret_cast<XrFrameState*>(this);
        }

        //! Accessor for this as the address of a raw XrFrameState
        XrFrameState const* get() const noexcept { return reinterpret_cast<XrFrameState const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFrameState.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFrameState * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FrameState{};next = oldNext;}
            return reinterpret_cast<XrFrameState*>(this);
        }
        Time predictedDisplayTime;
        Duration predictedDisplayPeriod;
        Bool32 shouldRender;
    };
     static_assert(sizeof(XrFrameState) == sizeof(FrameState), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFrameState pointer to const from a FrameState reference to const.
 * @relates FrameState
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameState const* get(FrameState const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameState as the address of a raw XrFrameState
 * @relates FrameState
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameState * put(FrameState &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrFrameBeginInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameBeginInfo>
 * @xrentity{XrFrameBeginInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FrameBeginInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Default/empty constructor
                 FrameBeginInfo (
            const void * next_ = nullptr)

: Parent(StructureType::FrameBeginInfo
             , next_)
            {}

        //! Default copy constructor
        FrameBeginInfo(const FrameBeginInfo& rhs) = default;
        //! Default copy assignment
        FrameBeginInfo& operator=(const FrameBeginInfo& rhs) = default;
        //! Copy construct from raw
        FrameBeginInfo(const XrFrameBeginInfo& rhs) : FrameBeginInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FrameBeginInfo& operator=(const XrFrameBeginInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFrameBeginInfo &() const { return *reinterpret_cast<const XrFrameBeginInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFrameBeginInfo &() {
            return *reinterpret_cast<XrFrameBeginInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrFrameBeginInfo
        XrFrameBeginInfo const* get() const noexcept { return reinterpret_cast<XrFrameBeginInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFrameBeginInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFrameBeginInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FrameBeginInfo{};next = oldNext;}
            return reinterpret_cast<XrFrameBeginInfo*>(this);
        }
    };
     static_assert(sizeof(XrFrameBeginInfo) == sizeof(FrameBeginInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFrameBeginInfo pointer to const from a FrameBeginInfo reference to const.
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameBeginInfo const* get(FrameBeginInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameBeginInfo as the address of a raw XrFrameBeginInfo
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameBeginInfo * put(FrameBeginInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrCompositionLayerBaseHeader
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerBaseHeader>
 * @xrentity{XrCompositionLayerBaseHeader}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerBaseHeader : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                CompositionLayerBaseHeader (
  StructureType type_ ,  const CompositionLayerFlags& layerFlags_,  const Space& space_,  const void * next_ = nullptr                  )
: Parent(type_ 
, next_)
, layerFlags {layerFlags_}
, space {space_}
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerBaseHeader &() const { return *reinterpret_cast<const XrCompositionLayerBaseHeader*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerBaseHeader &() {
            return *reinterpret_cast<XrCompositionLayerBaseHeader*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerBaseHeader
        XrCompositionLayerBaseHeader const* get() const noexcept { return reinterpret_cast<XrCompositionLayerBaseHeader const *>(this); }

        CompositionLayerFlags layerFlags;
        Space space;
    };
     static_assert(sizeof(XrCompositionLayerBaseHeader) == sizeof(CompositionLayerBaseHeader), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerBaseHeader pointer to const from a CompositionLayerBaseHeader reference to const.
 * @relates CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get(CompositionLayerBaseHeader const& s) {
        return s.get();
    }

































    
/*!
 * C++ projection of XrFrameEndInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameEndInfo>
 * @xrentity{XrFrameEndInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FrameEndInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FrameEndInfo (
 const Time& displayTime_,  const EnvironmentBlendMode& environmentBlendMode_,  uint32_t layerCount_,  const CompositionLayerBaseHeader* const* layers_,  const void * next_ = nullptr                  )
: Parent(StructureType::FrameEndInfo
, next_)
, displayTime {displayTime_}
, environmentBlendMode {environmentBlendMode_}
, layerCount {layerCount_}
, layers {layers_}
        {
        }


        //! Default/empty constructor
                 FrameEndInfo (
            const void * next_ = nullptr)

: Parent(StructureType::FrameEndInfo
             , next_)
, displayTime{}
, environmentBlendMode{}
, layerCount{0}
, layers{nullptr}
            {}

        //! Default copy constructor
        FrameEndInfo(const FrameEndInfo& rhs) = default;
        //! Default copy assignment
        FrameEndInfo& operator=(const FrameEndInfo& rhs) = default;
        //! Copy construct from raw
        FrameEndInfo(const XrFrameEndInfo& rhs) : FrameEndInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FrameEndInfo& operator=(const XrFrameEndInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFrameEndInfo &() const { return *reinterpret_cast<const XrFrameEndInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFrameEndInfo &() {
            return *reinterpret_cast<XrFrameEndInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrFrameEndInfo
        XrFrameEndInfo const* get() const noexcept { return reinterpret_cast<XrFrameEndInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFrameEndInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFrameEndInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FrameEndInfo{};next = oldNext;}
            return reinterpret_cast<XrFrameEndInfo*>(this);
        }
        Time displayTime;
        EnvironmentBlendMode environmentBlendMode;
        uint32_t layerCount;
        const CompositionLayerBaseHeader* const* layers;
    };
     static_assert(sizeof(XrFrameEndInfo) == sizeof(FrameEndInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFrameEndInfo pointer to const from a FrameEndInfo reference to const.
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameEndInfo const* get(FrameEndInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameEndInfo as the address of a raw XrFrameEndInfo
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameEndInfo * put(FrameEndInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrViewLocateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateInfo>
 * @xrentity{XrViewLocateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewLocateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ViewLocateInfo (
 const ViewConfigurationType& viewConfigurationType_,  const Time& displayTime_,  const Space& space_,  const void * next_ = nullptr                  )
: Parent(StructureType::ViewLocateInfo
, next_)
, viewConfigurationType {viewConfigurationType_}
, displayTime {displayTime_}
, space {space_}
        {
        }


        //! Default/empty constructor
                 ViewLocateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ViewLocateInfo
             , next_)
, viewConfigurationType{}
, displayTime{}
, space{}
            {}

        //! Default copy constructor
        ViewLocateInfo(const ViewLocateInfo& rhs) = default;
        //! Default copy assignment
        ViewLocateInfo& operator=(const ViewLocateInfo& rhs) = default;
        //! Copy construct from raw
        ViewLocateInfo(const XrViewLocateInfo& rhs) : ViewLocateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewLocateInfo& operator=(const XrViewLocateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewLocateInfo &() const { return *reinterpret_cast<const XrViewLocateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewLocateInfo &() {
            return *reinterpret_cast<XrViewLocateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrViewLocateInfo
        XrViewLocateInfo const* get() const noexcept { return reinterpret_cast<XrViewLocateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewLocateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewLocateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewLocateInfo{};next = oldNext;}
            return reinterpret_cast<XrViewLocateInfo*>(this);
        }
        ViewConfigurationType viewConfigurationType;
        Time displayTime;
        Space space;
    };
     static_assert(sizeof(XrViewLocateInfo) == sizeof(ViewLocateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewLocateInfo pointer to const from a ViewLocateInfo reference to const.
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewLocateInfo const* get(ViewLocateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewLocateInfo as the address of a raw XrViewLocateInfo
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewLocateInfo * put(ViewLocateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrViewState
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewState>
 * @xrentity{XrViewState}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewState : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ViewState (
            void * next_ = nullptr)

: Parent(StructureType::ViewState
             , next_)
            {}

        //! Default copy constructor
        ViewState(const ViewState& rhs) = default;
        //! Default copy assignment
        ViewState& operator=(const ViewState& rhs) = default;
        //! Copy construct from raw
        ViewState(const XrViewState& rhs) : ViewState() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewState& operator=(const XrViewState& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewState &() const { return *reinterpret_cast<const XrViewState*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewState &() {
            return *reinterpret_cast<XrViewState*>(this);
        }

        //! Accessor for this as the address of a raw XrViewState
        XrViewState const* get() const noexcept { return reinterpret_cast<XrViewState const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewState.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewState * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewState{};next = oldNext;}
            return reinterpret_cast<XrViewState*>(this);
        }
        ViewStateFlags viewStateFlags;
    };
     static_assert(sizeof(XrViewState) == sizeof(ViewState), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewState pointer to const from a ViewState reference to const.
 * @relates ViewState
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewState const* get(ViewState const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewState as the address of a raw XrViewState
 * @relates ViewState
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewState * put(ViewState &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrFovf
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFovf>
 * @xrentity{XrFovf}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Fovf 
    {
    public:
        //! Constructor initializing all members.
                Fovf (
 float angleLeft_,  float angleRight_,  float angleUp_,  float angleDown_                  )
: angleLeft {angleLeft_}
, angleRight {angleRight_}
, angleUp {angleUp_}
, angleDown {angleDown_}
        {
        }


        //! Default/empty constructor
                 Fovf (
            )

: angleLeft{0.0f}
, angleRight{0.0f}
, angleUp{0.0f}
, angleDown{0.0f}
            {}

        //! Default copy constructor
        Fovf(const Fovf& rhs) = default;
        //! Default copy assignment
        Fovf& operator=(const Fovf& rhs) = default;
        //! Copy construct from raw
        Fovf(const XrFovf& rhs) : Fovf() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Fovf& operator=(const XrFovf& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFovf &() const { return *reinterpret_cast<const XrFovf*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFovf &() {
            return *reinterpret_cast<XrFovf*>(this);
        }

        //! Accessor for this as the address of a raw XrFovf
        XrFovf const* get() const noexcept { return reinterpret_cast<XrFovf const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFovf.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrFovf * put(bool clear = true) noexcept {
            if (clear) {*this = Fovf{};}
            return reinterpret_cast<XrFovf*>(this);
        }
        float angleLeft;
        float angleRight;
        float angleUp;
        float angleDown;
    };
     static_assert(sizeof(XrFovf) == sizeof(Fovf), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFovf pointer to const from a Fovf reference to const.
 * @relates Fovf
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFovf const* get(Fovf const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Fovf as the address of a raw XrFovf
 * @relates Fovf
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFovf * put(Fovf &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrView
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrView>
 * @xrentity{XrView}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS View : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 View (
            void * next_ = nullptr)

: Parent(StructureType::View
             , next_)
            {}

        //! Default copy constructor
        View(const View& rhs) = default;
        //! Default copy assignment
        View& operator=(const View& rhs) = default;
        //! Copy construct from raw
        View(const XrView& rhs) : View() {
            *put() = rhs;
        }
        //! Copy assign from raw
        View& operator=(const XrView& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrView &() const { return *reinterpret_cast<const XrView*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrView &() {
            return *reinterpret_cast<XrView*>(this);
        }

        //! Accessor for this as the address of a raw XrView
        XrView const* get() const noexcept { return reinterpret_cast<XrView const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrView.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrView * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = View{};next = oldNext;}
            return reinterpret_cast<XrView*>(this);
        }
        Posef pose;
        Fovf fov;
    };
     static_assert(sizeof(XrView) == sizeof(View), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrView pointer to const from a View reference to const.
 * @relates View
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrView const* get(View const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing View as the address of a raw XrView
 * @relates View
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrView * put(View &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionSetCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSetCreateInfo>
 * @xrentity{XrActionSetCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionSetCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ActionSetCreateInfo (
 const char* actionSetName_,  const char* localizedActionSetName_,  uint32_t priority_,  const void * next_ = nullptr                  )
: Parent(StructureType::ActionSetCreateInfo
, next_)
, priority {priority_}
        {
            if (nullptr != actionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
    strncpy_s(actionSetName, XR_MAX_ACTION_SET_NAME_SIZE, actionSetName_, XR_MAX_ACTION_SET_NAME_SIZE );
#else
    strncpy(actionSetName, actionSetName_, XR_MAX_ACTION_SET_NAME_SIZE - 1);
    actionSetName[XR_MAX_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
}

            if (nullptr != localizedActionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
    strncpy_s(localizedActionSetName, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE, localizedActionSetName_, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE );
#else
    strncpy(localizedActionSetName, localizedActionSetName_, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1);
    localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
}

        }


        //! Default/empty constructor
                 ActionSetCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ActionSetCreateInfo
             , next_)
, priority{0}
            {}

        //! Default copy constructor
        ActionSetCreateInfo(const ActionSetCreateInfo& rhs) = default;
        //! Default copy assignment
        ActionSetCreateInfo& operator=(const ActionSetCreateInfo& rhs) = default;
        //! Copy construct from raw
        ActionSetCreateInfo(const XrActionSetCreateInfo& rhs) : ActionSetCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionSetCreateInfo& operator=(const XrActionSetCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionSetCreateInfo &() const { return *reinterpret_cast<const XrActionSetCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionSetCreateInfo &() {
            return *reinterpret_cast<XrActionSetCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrActionSetCreateInfo
        XrActionSetCreateInfo const* get() const noexcept { return reinterpret_cast<XrActionSetCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionSetCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionSetCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionSetCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrActionSetCreateInfo*>(this);
        }
        char actionSetName[XR_MAX_ACTION_SET_NAME_SIZE];
        char localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE];
        uint32_t priority;
    };
     static_assert(sizeof(XrActionSetCreateInfo) == sizeof(ActionSetCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionSetCreateInfo pointer to const from a ActionSetCreateInfo reference to const.
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionSetCreateInfo const* get(ActionSetCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSetCreateInfo as the address of a raw XrActionSetCreateInfo
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionSetCreateInfo * put(ActionSetCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionCreateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionCreateInfo>
 * @xrentity{XrActionCreateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionCreateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ActionCreateInfo (
 const char* actionName_,  const ActionType& actionType_,  uint32_t countSubactionPaths_,  const Path* subactionPaths_,  const char* localizedActionName_,  const void * next_ = nullptr                  )
: Parent(StructureType::ActionCreateInfo
, next_)
, actionType {actionType_}
, countSubactionPaths {countSubactionPaths_}
, subactionPaths {subactionPaths_}
        {
            if (nullptr != actionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
    strncpy_s(actionName, XR_MAX_ACTION_NAME_SIZE, actionName_, XR_MAX_ACTION_NAME_SIZE );
#else
    strncpy(actionName, actionName_, XR_MAX_ACTION_NAME_SIZE - 1);
    actionName[XR_MAX_ACTION_NAME_SIZE - 1] = '\0';
#endif
}

            if (nullptr != localizedActionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
    strncpy_s(localizedActionName, XR_MAX_LOCALIZED_ACTION_NAME_SIZE, localizedActionName_, XR_MAX_LOCALIZED_ACTION_NAME_SIZE );
#else
    strncpy(localizedActionName, localizedActionName_, XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1);
    localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1] = '\0';
#endif
}

        }


        //! Default/empty constructor
                 ActionCreateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ActionCreateInfo
             , next_)
, actionType{}
, countSubactionPaths{0}
, subactionPaths{nullptr}
            {}

        //! Default copy constructor
        ActionCreateInfo(const ActionCreateInfo& rhs) = default;
        //! Default copy assignment
        ActionCreateInfo& operator=(const ActionCreateInfo& rhs) = default;
        //! Copy construct from raw
        ActionCreateInfo(const XrActionCreateInfo& rhs) : ActionCreateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionCreateInfo& operator=(const XrActionCreateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionCreateInfo &() const { return *reinterpret_cast<const XrActionCreateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionCreateInfo &() {
            return *reinterpret_cast<XrActionCreateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrActionCreateInfo
        XrActionCreateInfo const* get() const noexcept { return reinterpret_cast<XrActionCreateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionCreateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionCreateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionCreateInfo{};next = oldNext;}
            return reinterpret_cast<XrActionCreateInfo*>(this);
        }
        char actionName[XR_MAX_ACTION_NAME_SIZE];
        ActionType actionType;
        uint32_t countSubactionPaths;
        const Path* subactionPaths;
        char localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE];
    };
     static_assert(sizeof(XrActionCreateInfo) == sizeof(ActionCreateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionCreateInfo pointer to const from a ActionCreateInfo reference to const.
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionCreateInfo const* get(ActionCreateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionCreateInfo as the address of a raw XrActionCreateInfo
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionCreateInfo * put(ActionCreateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionSuggestedBinding
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSuggestedBinding>
 * @xrentity{XrActionSuggestedBinding}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ActionSuggestedBinding 
    {
    public:
        //! Constructor initializing all members.
                ActionSuggestedBinding (
 const Action& action_,  const Path& binding_                  )
: action {action_}
, binding {binding_}
        {
        }


        //! Default/empty constructor
                 ActionSuggestedBinding (
            )

: action{}
, binding{}
            {}

        //! Default copy constructor
        ActionSuggestedBinding(const ActionSuggestedBinding& rhs) = default;
        //! Default copy assignment
        ActionSuggestedBinding& operator=(const ActionSuggestedBinding& rhs) = default;
        //! Copy construct from raw
        ActionSuggestedBinding(const XrActionSuggestedBinding& rhs) : ActionSuggestedBinding() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionSuggestedBinding& operator=(const XrActionSuggestedBinding& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionSuggestedBinding &() const { return *reinterpret_cast<const XrActionSuggestedBinding*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionSuggestedBinding &() {
            return *reinterpret_cast<XrActionSuggestedBinding*>(this);
        }

        //! Accessor for this as the address of a raw XrActionSuggestedBinding
        XrActionSuggestedBinding const* get() const noexcept { return reinterpret_cast<XrActionSuggestedBinding const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionSuggestedBinding.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrActionSuggestedBinding * put(bool clear = true) noexcept {
            if (clear) {*this = ActionSuggestedBinding{};}
            return reinterpret_cast<XrActionSuggestedBinding*>(this);
        }
        Action action;
        Path binding;
    };
     static_assert(sizeof(XrActionSuggestedBinding) == sizeof(ActionSuggestedBinding), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionSuggestedBinding pointer to const from a ActionSuggestedBinding reference to const.
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionSuggestedBinding const* get(ActionSuggestedBinding const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSuggestedBinding as the address of a raw XrActionSuggestedBinding
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionSuggestedBinding * put(ActionSuggestedBinding &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrInteractionProfileSuggestedBinding
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileSuggestedBinding>
 * @xrentity{XrInteractionProfileSuggestedBinding}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InteractionProfileSuggestedBinding : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                InteractionProfileSuggestedBinding (
 const Path& interactionProfile_,  uint32_t countSuggestedBindings_,  const ActionSuggestedBinding* suggestedBindings_,  const void * next_ = nullptr                  )
: Parent(StructureType::InteractionProfileSuggestedBinding
, next_)
, interactionProfile {interactionProfile_}
, countSuggestedBindings {countSuggestedBindings_}
, suggestedBindings {suggestedBindings_}
        {
        }


        //! Default/empty constructor
                 InteractionProfileSuggestedBinding (
            const void * next_ = nullptr)

: Parent(StructureType::InteractionProfileSuggestedBinding
             , next_)
, interactionProfile{}
, countSuggestedBindings{0}
, suggestedBindings{nullptr}
            {}

        //! Default copy constructor
        InteractionProfileSuggestedBinding(const InteractionProfileSuggestedBinding& rhs) = default;
        //! Default copy assignment
        InteractionProfileSuggestedBinding& operator=(const InteractionProfileSuggestedBinding& rhs) = default;
        //! Copy construct from raw
        InteractionProfileSuggestedBinding(const XrInteractionProfileSuggestedBinding& rhs) : InteractionProfileSuggestedBinding() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InteractionProfileSuggestedBinding& operator=(const XrInteractionProfileSuggestedBinding& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInteractionProfileSuggestedBinding &() const { return *reinterpret_cast<const XrInteractionProfileSuggestedBinding*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInteractionProfileSuggestedBinding &() {
            return *reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
        }

        //! Accessor for this as the address of a raw XrInteractionProfileSuggestedBinding
        XrInteractionProfileSuggestedBinding const* get() const noexcept { return reinterpret_cast<XrInteractionProfileSuggestedBinding const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInteractionProfileSuggestedBinding.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInteractionProfileSuggestedBinding * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InteractionProfileSuggestedBinding{};next = oldNext;}
            return reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
        }
        Path interactionProfile;
        uint32_t countSuggestedBindings;
        const ActionSuggestedBinding* suggestedBindings;
    };
     static_assert(sizeof(XrInteractionProfileSuggestedBinding) == sizeof(InteractionProfileSuggestedBinding), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInteractionProfileSuggestedBinding pointer to const from a InteractionProfileSuggestedBinding reference to const.
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding const* get(InteractionProfileSuggestedBinding const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileSuggestedBinding as the address of a raw XrInteractionProfileSuggestedBinding
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding * put(InteractionProfileSuggestedBinding &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSessionActionSetsAttachInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionActionSetsAttachInfo>
 * @xrentity{XrSessionActionSetsAttachInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SessionActionSetsAttachInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SessionActionSetsAttachInfo (
 uint32_t countActionSets_,  const ActionSet* actionSets_,  const void * next_ = nullptr                  )
: Parent(StructureType::SessionActionSetsAttachInfo
, next_)
, countActionSets {countActionSets_}
, actionSets {actionSets_}
        {
        }


        //! Default/empty constructor
                 SessionActionSetsAttachInfo (
            const void * next_ = nullptr)

: Parent(StructureType::SessionActionSetsAttachInfo
             , next_)
, countActionSets{0}
, actionSets{nullptr}
            {}

        //! Default copy constructor
        SessionActionSetsAttachInfo(const SessionActionSetsAttachInfo& rhs) = default;
        //! Default copy assignment
        SessionActionSetsAttachInfo& operator=(const SessionActionSetsAttachInfo& rhs) = default;
        //! Copy construct from raw
        SessionActionSetsAttachInfo(const XrSessionActionSetsAttachInfo& rhs) : SessionActionSetsAttachInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SessionActionSetsAttachInfo& operator=(const XrSessionActionSetsAttachInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSessionActionSetsAttachInfo &() const { return *reinterpret_cast<const XrSessionActionSetsAttachInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSessionActionSetsAttachInfo &() {
            return *reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrSessionActionSetsAttachInfo
        XrSessionActionSetsAttachInfo const* get() const noexcept { return reinterpret_cast<XrSessionActionSetsAttachInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSessionActionSetsAttachInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSessionActionSetsAttachInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SessionActionSetsAttachInfo{};next = oldNext;}
            return reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
        }
        uint32_t countActionSets;
        const ActionSet* actionSets;
    };
     static_assert(sizeof(XrSessionActionSetsAttachInfo) == sizeof(SessionActionSetsAttachInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSessionActionSetsAttachInfo pointer to const from a SessionActionSetsAttachInfo reference to const.
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo const* get(SessionActionSetsAttachInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionActionSetsAttachInfo as the address of a raw XrSessionActionSetsAttachInfo
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo * put(SessionActionSetsAttachInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrInteractionProfileState
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileState>
 * @xrentity{XrInteractionProfileState}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InteractionProfileState : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 InteractionProfileState (
            void * next_ = nullptr)

: Parent(StructureType::InteractionProfileState
             , next_)
            {}

        //! Default copy constructor
        InteractionProfileState(const InteractionProfileState& rhs) = default;
        //! Default copy assignment
        InteractionProfileState& operator=(const InteractionProfileState& rhs) = default;
        //! Copy construct from raw
        InteractionProfileState(const XrInteractionProfileState& rhs) : InteractionProfileState() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InteractionProfileState& operator=(const XrInteractionProfileState& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInteractionProfileState &() const { return *reinterpret_cast<const XrInteractionProfileState*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInteractionProfileState &() {
            return *reinterpret_cast<XrInteractionProfileState*>(this);
        }

        //! Accessor for this as the address of a raw XrInteractionProfileState
        XrInteractionProfileState const* get() const noexcept { return reinterpret_cast<XrInteractionProfileState const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInteractionProfileState.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInteractionProfileState * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InteractionProfileState{};next = oldNext;}
            return reinterpret_cast<XrInteractionProfileState*>(this);
        }
        Path interactionProfile;
    };
     static_assert(sizeof(XrInteractionProfileState) == sizeof(InteractionProfileState), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInteractionProfileState pointer to const from a InteractionProfileState reference to const.
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileState const* get(InteractionProfileState const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileState as the address of a raw XrInteractionProfileState
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileState * put(InteractionProfileState &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionStateGetInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateGetInfo>
 * @xrentity{XrActionStateGetInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionStateGetInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ActionStateGetInfo (
 const Action& action_,  const Path& subactionPath_,  const void * next_ = nullptr                  )
: Parent(StructureType::ActionStateGetInfo
, next_)
, action {action_}
, subactionPath {subactionPath_}
        {
        }


        //! Default/empty constructor
                 ActionStateGetInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ActionStateGetInfo
             , next_)
, action{}
, subactionPath{}
            {}

        //! Default copy constructor
        ActionStateGetInfo(const ActionStateGetInfo& rhs) = default;
        //! Default copy assignment
        ActionStateGetInfo& operator=(const ActionStateGetInfo& rhs) = default;
        //! Copy construct from raw
        ActionStateGetInfo(const XrActionStateGetInfo& rhs) : ActionStateGetInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionStateGetInfo& operator=(const XrActionStateGetInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionStateGetInfo &() const { return *reinterpret_cast<const XrActionStateGetInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionStateGetInfo &() {
            return *reinterpret_cast<XrActionStateGetInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrActionStateGetInfo
        XrActionStateGetInfo const* get() const noexcept { return reinterpret_cast<XrActionStateGetInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionStateGetInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionStateGetInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionStateGetInfo{};next = oldNext;}
            return reinterpret_cast<XrActionStateGetInfo*>(this);
        }
        Action action;
        Path subactionPath;
    };
     static_assert(sizeof(XrActionStateGetInfo) == sizeof(ActionStateGetInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionStateGetInfo pointer to const from a ActionStateGetInfo reference to const.
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateGetInfo const* get(ActionStateGetInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateGetInfo as the address of a raw XrActionStateGetInfo
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateGetInfo * put(ActionStateGetInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionStateBoolean
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateBoolean>
 * @xrentity{XrActionStateBoolean}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionStateBoolean : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ActionStateBoolean (
            void * next_ = nullptr)

: Parent(StructureType::ActionStateBoolean
             , next_)
            {}

        //! Default copy constructor
        ActionStateBoolean(const ActionStateBoolean& rhs) = default;
        //! Default copy assignment
        ActionStateBoolean& operator=(const ActionStateBoolean& rhs) = default;
        //! Copy construct from raw
        ActionStateBoolean(const XrActionStateBoolean& rhs) : ActionStateBoolean() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionStateBoolean& operator=(const XrActionStateBoolean& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionStateBoolean &() const { return *reinterpret_cast<const XrActionStateBoolean*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionStateBoolean &() {
            return *reinterpret_cast<XrActionStateBoolean*>(this);
        }

        //! Accessor for this as the address of a raw XrActionStateBoolean
        XrActionStateBoolean const* get() const noexcept { return reinterpret_cast<XrActionStateBoolean const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionStateBoolean.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionStateBoolean * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionStateBoolean{};next = oldNext;}
            return reinterpret_cast<XrActionStateBoolean*>(this);
        }
        Bool32 currentState;
        Bool32 changedSinceLastSync;
        Time lastChangeTime;
        Bool32 isActive;
    };
     static_assert(sizeof(XrActionStateBoolean) == sizeof(ActionStateBoolean), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionStateBoolean pointer to const from a ActionStateBoolean reference to const.
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateBoolean const* get(ActionStateBoolean const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateBoolean as the address of a raw XrActionStateBoolean
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateBoolean * put(ActionStateBoolean &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionStateFloat
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateFloat>
 * @xrentity{XrActionStateFloat}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionStateFloat : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ActionStateFloat (
            void * next_ = nullptr)

: Parent(StructureType::ActionStateFloat
             , next_)
            {}

        //! Default copy constructor
        ActionStateFloat(const ActionStateFloat& rhs) = default;
        //! Default copy assignment
        ActionStateFloat& operator=(const ActionStateFloat& rhs) = default;
        //! Copy construct from raw
        ActionStateFloat(const XrActionStateFloat& rhs) : ActionStateFloat() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionStateFloat& operator=(const XrActionStateFloat& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionStateFloat &() const { return *reinterpret_cast<const XrActionStateFloat*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionStateFloat &() {
            return *reinterpret_cast<XrActionStateFloat*>(this);
        }

        //! Accessor for this as the address of a raw XrActionStateFloat
        XrActionStateFloat const* get() const noexcept { return reinterpret_cast<XrActionStateFloat const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionStateFloat.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionStateFloat * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionStateFloat{};next = oldNext;}
            return reinterpret_cast<XrActionStateFloat*>(this);
        }
        float currentState;
        Bool32 changedSinceLastSync;
        Time lastChangeTime;
        Bool32 isActive;
    };
     static_assert(sizeof(XrActionStateFloat) == sizeof(ActionStateFloat), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionStateFloat pointer to const from a ActionStateFloat reference to const.
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateFloat const* get(ActionStateFloat const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateFloat as the address of a raw XrActionStateFloat
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateFloat * put(ActionStateFloat &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrVector2f
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector2f>
 * @xrentity{XrVector2f}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Vector2f 
    {
    public:
        //! Constructor initializing all members.
                Vector2f (
 float x_,  float y_                  )
: x {x_}
, y {y_}
        {
        }


        //! Default/empty constructor
                 Vector2f (
            )

: x{0.0f}
, y{0.0f}
            {}

        //! Default copy constructor
        Vector2f(const Vector2f& rhs) = default;
        //! Default copy assignment
        Vector2f& operator=(const Vector2f& rhs) = default;
        //! Copy construct from raw
        Vector2f(const XrVector2f& rhs) : Vector2f() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Vector2f& operator=(const XrVector2f& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVector2f &() const { return *reinterpret_cast<const XrVector2f*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVector2f &() {
            return *reinterpret_cast<XrVector2f*>(this);
        }

        //! Accessor for this as the address of a raw XrVector2f
        XrVector2f const* get() const noexcept { return reinterpret_cast<XrVector2f const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVector2f.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrVector2f * put(bool clear = true) noexcept {
            if (clear) {*this = Vector2f{};}
            return reinterpret_cast<XrVector2f*>(this);
        }
        float x;
        float y;
    };
     static_assert(sizeof(XrVector2f) == sizeof(Vector2f), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVector2f pointer to const from a Vector2f reference to const.
 * @relates Vector2f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector2f const* get(Vector2f const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector2f as the address of a raw XrVector2f
 * @relates Vector2f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector2f * put(Vector2f &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionStateVector2f
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateVector2f>
 * @xrentity{XrActionStateVector2f}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionStateVector2f : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ActionStateVector2f (
            void * next_ = nullptr)

: Parent(StructureType::ActionStateVector2F
             , next_)
            {}

        //! Default copy constructor
        ActionStateVector2f(const ActionStateVector2f& rhs) = default;
        //! Default copy assignment
        ActionStateVector2f& operator=(const ActionStateVector2f& rhs) = default;
        //! Copy construct from raw
        ActionStateVector2f(const XrActionStateVector2f& rhs) : ActionStateVector2f() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionStateVector2f& operator=(const XrActionStateVector2f& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionStateVector2f &() const { return *reinterpret_cast<const XrActionStateVector2f*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionStateVector2f &() {
            return *reinterpret_cast<XrActionStateVector2f*>(this);
        }

        //! Accessor for this as the address of a raw XrActionStateVector2f
        XrActionStateVector2f const* get() const noexcept { return reinterpret_cast<XrActionStateVector2f const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionStateVector2f.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionStateVector2f * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionStateVector2f{};next = oldNext;}
            return reinterpret_cast<XrActionStateVector2f*>(this);
        }
        Vector2f currentState;
        Bool32 changedSinceLastSync;
        Time lastChangeTime;
        Bool32 isActive;
    };
     static_assert(sizeof(XrActionStateVector2f) == sizeof(ActionStateVector2f), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionStateVector2f pointer to const from a ActionStateVector2f reference to const.
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateVector2f const* get(ActionStateVector2f const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateVector2f as the address of a raw XrActionStateVector2f
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStateVector2f * put(ActionStateVector2f &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionStatePose
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStatePose>
 * @xrentity{XrActionStatePose}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionStatePose : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ActionStatePose (
            void * next_ = nullptr)

: Parent(StructureType::ActionStatePose
             , next_)
            {}

        //! Default copy constructor
        ActionStatePose(const ActionStatePose& rhs) = default;
        //! Default copy assignment
        ActionStatePose& operator=(const ActionStatePose& rhs) = default;
        //! Copy construct from raw
        ActionStatePose(const XrActionStatePose& rhs) : ActionStatePose() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionStatePose& operator=(const XrActionStatePose& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionStatePose &() const { return *reinterpret_cast<const XrActionStatePose*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionStatePose &() {
            return *reinterpret_cast<XrActionStatePose*>(this);
        }

        //! Accessor for this as the address of a raw XrActionStatePose
        XrActionStatePose const* get() const noexcept { return reinterpret_cast<XrActionStatePose const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionStatePose.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionStatePose * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionStatePose{};next = oldNext;}
            return reinterpret_cast<XrActionStatePose*>(this);
        }
        Bool32 isActive;
    };
     static_assert(sizeof(XrActionStatePose) == sizeof(ActionStatePose), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionStatePose pointer to const from a ActionStatePose reference to const.
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStatePose const* get(ActionStatePose const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStatePose as the address of a raw XrActionStatePose
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionStatePose * put(ActionStatePose &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActiveActionSet
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSet>
 * @xrentity{XrActiveActionSet}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ActiveActionSet 
    {
    public:
        //! Constructor initializing all members.
                ActiveActionSet (
 const ActionSet& actionSet_,  const Path& subactionPath_                  )
: actionSet {actionSet_}
, subactionPath {subactionPath_}
        {
        }


        //! Default/empty constructor
                 ActiveActionSet (
            )

: actionSet{}
, subactionPath{}
            {}

        //! Default copy constructor
        ActiveActionSet(const ActiveActionSet& rhs) = default;
        //! Default copy assignment
        ActiveActionSet& operator=(const ActiveActionSet& rhs) = default;
        //! Copy construct from raw
        ActiveActionSet(const XrActiveActionSet& rhs) : ActiveActionSet() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActiveActionSet& operator=(const XrActiveActionSet& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActiveActionSet &() const { return *reinterpret_cast<const XrActiveActionSet*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActiveActionSet &() {
            return *reinterpret_cast<XrActiveActionSet*>(this);
        }

        //! Accessor for this as the address of a raw XrActiveActionSet
        XrActiveActionSet const* get() const noexcept { return reinterpret_cast<XrActiveActionSet const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActiveActionSet.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrActiveActionSet * put(bool clear = true) noexcept {
            if (clear) {*this = ActiveActionSet{};}
            return reinterpret_cast<XrActiveActionSet*>(this);
        }
        ActionSet actionSet;
        Path subactionPath;
    };
     static_assert(sizeof(XrActiveActionSet) == sizeof(ActiveActionSet), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActiveActionSet pointer to const from a ActiveActionSet reference to const.
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActiveActionSet const* get(ActiveActionSet const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSet as the address of a raw XrActiveActionSet
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActiveActionSet * put(ActiveActionSet &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrActionsSyncInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionsSyncInfo>
 * @xrentity{XrActionsSyncInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActionsSyncInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ActionsSyncInfo (
 uint32_t countActiveActionSets_,  const ActiveActionSet* activeActionSets_,  const void * next_ = nullptr                  )
: Parent(StructureType::ActionsSyncInfo
, next_)
, countActiveActionSets {countActiveActionSets_}
, activeActionSets {activeActionSets_}
        {
        }


        //! Default/empty constructor
                 ActionsSyncInfo (
            const void * next_ = nullptr)

: Parent(StructureType::ActionsSyncInfo
             , next_)
, countActiveActionSets{0}
, activeActionSets{nullptr}
            {}

        //! Default copy constructor
        ActionsSyncInfo(const ActionsSyncInfo& rhs) = default;
        //! Default copy assignment
        ActionsSyncInfo& operator=(const ActionsSyncInfo& rhs) = default;
        //! Copy construct from raw
        ActionsSyncInfo(const XrActionsSyncInfo& rhs) : ActionsSyncInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActionsSyncInfo& operator=(const XrActionsSyncInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActionsSyncInfo &() const { return *reinterpret_cast<const XrActionsSyncInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActionsSyncInfo &() {
            return *reinterpret_cast<XrActionsSyncInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrActionsSyncInfo
        XrActionsSyncInfo const* get() const noexcept { return reinterpret_cast<XrActionsSyncInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActionsSyncInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActionsSyncInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActionsSyncInfo{};next = oldNext;}
            return reinterpret_cast<XrActionsSyncInfo*>(this);
        }
        uint32_t countActiveActionSets;
        const ActiveActionSet* activeActionSets;
    };
     static_assert(sizeof(XrActionsSyncInfo) == sizeof(ActionsSyncInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActionsSyncInfo pointer to const from a ActionsSyncInfo reference to const.
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionsSyncInfo const* get(ActionsSyncInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionsSyncInfo as the address of a raw XrActionsSyncInfo
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActionsSyncInfo * put(ActionsSyncInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrBoundSourcesForActionEnumerateInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoundSourcesForActionEnumerateInfo>
 * @xrentity{XrBoundSourcesForActionEnumerateInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS BoundSourcesForActionEnumerateInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                BoundSourcesForActionEnumerateInfo (
 const Action& action_,  const void * next_ = nullptr                  )
: Parent(StructureType::BoundSourcesForActionEnumerateInfo
, next_)
, action {action_}
        {
        }


        //! Default/empty constructor
                 BoundSourcesForActionEnumerateInfo (
            const void * next_ = nullptr)

: Parent(StructureType::BoundSourcesForActionEnumerateInfo
             , next_)
, action{}
            {}

        //! Default copy constructor
        BoundSourcesForActionEnumerateInfo(const BoundSourcesForActionEnumerateInfo& rhs) = default;
        //! Default copy assignment
        BoundSourcesForActionEnumerateInfo& operator=(const BoundSourcesForActionEnumerateInfo& rhs) = default;
        //! Copy construct from raw
        BoundSourcesForActionEnumerateInfo(const XrBoundSourcesForActionEnumerateInfo& rhs) : BoundSourcesForActionEnumerateInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BoundSourcesForActionEnumerateInfo& operator=(const XrBoundSourcesForActionEnumerateInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBoundSourcesForActionEnumerateInfo &() const { return *reinterpret_cast<const XrBoundSourcesForActionEnumerateInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBoundSourcesForActionEnumerateInfo &() {
            return *reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrBoundSourcesForActionEnumerateInfo
        XrBoundSourcesForActionEnumerateInfo const* get() const noexcept { return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBoundSourcesForActionEnumerateInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBoundSourcesForActionEnumerateInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = BoundSourcesForActionEnumerateInfo{};next = oldNext;}
            return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
        }
        Action action;
    };
     static_assert(sizeof(XrBoundSourcesForActionEnumerateInfo) == sizeof(BoundSourcesForActionEnumerateInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBoundSourcesForActionEnumerateInfo pointer to const from a BoundSourcesForActionEnumerateInfo reference to const.
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo const* get(BoundSourcesForActionEnumerateInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BoundSourcesForActionEnumerateInfo as the address of a raw XrBoundSourcesForActionEnumerateInfo
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo * put(BoundSourcesForActionEnumerateInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrInputSourceLocalizedNameGetInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInputSourceLocalizedNameGetInfo>
 * @xrentity{XrInputSourceLocalizedNameGetInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InputSourceLocalizedNameGetInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                InputSourceLocalizedNameGetInfo (
 const Path& sourcePath_,  const InputSourceLocalizedNameFlags& whichComponents_,  const void * next_ = nullptr                  )
: Parent(StructureType::InputSourceLocalizedNameGetInfo
, next_)
, sourcePath {sourcePath_}
, whichComponents {whichComponents_}
        {
        }


        //! Default/empty constructor
                 InputSourceLocalizedNameGetInfo (
            const void * next_ = nullptr)

: Parent(StructureType::InputSourceLocalizedNameGetInfo
             , next_)
, sourcePath{}
, whichComponents{}
            {}

        //! Default copy constructor
        InputSourceLocalizedNameGetInfo(const InputSourceLocalizedNameGetInfo& rhs) = default;
        //! Default copy assignment
        InputSourceLocalizedNameGetInfo& operator=(const InputSourceLocalizedNameGetInfo& rhs) = default;
        //! Copy construct from raw
        InputSourceLocalizedNameGetInfo(const XrInputSourceLocalizedNameGetInfo& rhs) : InputSourceLocalizedNameGetInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InputSourceLocalizedNameGetInfo& operator=(const XrInputSourceLocalizedNameGetInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInputSourceLocalizedNameGetInfo &() const { return *reinterpret_cast<const XrInputSourceLocalizedNameGetInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInputSourceLocalizedNameGetInfo &() {
            return *reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrInputSourceLocalizedNameGetInfo
        XrInputSourceLocalizedNameGetInfo const* get() const noexcept { return reinterpret_cast<XrInputSourceLocalizedNameGetInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInputSourceLocalizedNameGetInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInputSourceLocalizedNameGetInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InputSourceLocalizedNameGetInfo{};next = oldNext;}
            return reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
        }
        Path sourcePath;
        InputSourceLocalizedNameFlags whichComponents;
    };
     static_assert(sizeof(XrInputSourceLocalizedNameGetInfo) == sizeof(InputSourceLocalizedNameGetInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInputSourceLocalizedNameGetInfo pointer to const from a InputSourceLocalizedNameGetInfo reference to const.
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo const* get(InputSourceLocalizedNameGetInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InputSourceLocalizedNameGetInfo as the address of a raw XrInputSourceLocalizedNameGetInfo
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo * put(InputSourceLocalizedNameGetInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrHapticActionInfo
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticActionInfo>
 * @xrentity{XrHapticActionInfo}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HapticActionInfo : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HapticActionInfo (
 const Action& action_,  const Path& subactionPath_,  const void * next_ = nullptr                  )
: Parent(StructureType::HapticActionInfo
, next_)
, action {action_}
, subactionPath {subactionPath_}
        {
        }


        //! Default/empty constructor
                 HapticActionInfo (
            const void * next_ = nullptr)

: Parent(StructureType::HapticActionInfo
             , next_)
, action{}
, subactionPath{}
            {}

        //! Default copy constructor
        HapticActionInfo(const HapticActionInfo& rhs) = default;
        //! Default copy assignment
        HapticActionInfo& operator=(const HapticActionInfo& rhs) = default;
        //! Copy construct from raw
        HapticActionInfo(const XrHapticActionInfo& rhs) : HapticActionInfo() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HapticActionInfo& operator=(const XrHapticActionInfo& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHapticActionInfo &() const { return *reinterpret_cast<const XrHapticActionInfo*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHapticActionInfo &() {
            return *reinterpret_cast<XrHapticActionInfo*>(this);
        }

        //! Accessor for this as the address of a raw XrHapticActionInfo
        XrHapticActionInfo const* get() const noexcept { return reinterpret_cast<XrHapticActionInfo const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHapticActionInfo.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHapticActionInfo * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HapticActionInfo{};next = oldNext;}
            return reinterpret_cast<XrHapticActionInfo*>(this);
        }
        Action action;
        Path subactionPath;
    };
     static_assert(sizeof(XrHapticActionInfo) == sizeof(HapticActionInfo), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHapticActionInfo pointer to const from a HapticActionInfo reference to const.
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticActionInfo const* get(HapticActionInfo const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticActionInfo as the address of a raw XrHapticActionInfo
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticActionInfo * put(HapticActionInfo &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrHapticBaseHeader
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticBaseHeader>
 * @xrentity{XrHapticBaseHeader}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS HapticBaseHeader : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                HapticBaseHeader (
  StructureType type_ ,  const void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHapticBaseHeader &() const { return *reinterpret_cast<const XrHapticBaseHeader*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHapticBaseHeader &() {
            return *reinterpret_cast<XrHapticBaseHeader*>(this);
        }

        //! Accessor for this as the address of a raw XrHapticBaseHeader
        XrHapticBaseHeader const* get() const noexcept { return reinterpret_cast<XrHapticBaseHeader const *>(this); }

    };
     static_assert(sizeof(XrHapticBaseHeader) == sizeof(HapticBaseHeader), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHapticBaseHeader pointer to const from a HapticBaseHeader reference to const.
 * @relates HapticBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticBaseHeader const* get(HapticBaseHeader const& s) {
        return s.get();
    }

































    
/*!
 * C++ projection of XrOffset2Di
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Di>
 * @xrentity{XrOffset2Di}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Offset2Di 
    {
    public:
        //! Constructor initializing all members.
                Offset2Di (
 int32_t x_,  int32_t y_                  )
: x {x_}
, y {y_}
        {
        }


        //! Default/empty constructor
                 Offset2Di (
            )

: x{0}
, y{0}
            {}

        //! Default copy constructor
        Offset2Di(const Offset2Di& rhs) = default;
        //! Default copy assignment
        Offset2Di& operator=(const Offset2Di& rhs) = default;
        //! Copy construct from raw
        Offset2Di(const XrOffset2Di& rhs) : Offset2Di() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Offset2Di& operator=(const XrOffset2Di& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrOffset2Di &() const { return *reinterpret_cast<const XrOffset2Di*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrOffset2Di &() {
            return *reinterpret_cast<XrOffset2Di*>(this);
        }

        //! Accessor for this as the address of a raw XrOffset2Di
        XrOffset2Di const* get() const noexcept { return reinterpret_cast<XrOffset2Di const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Di.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrOffset2Di * put(bool clear = true) noexcept {
            if (clear) {*this = Offset2Di{};}
            return reinterpret_cast<XrOffset2Di*>(this);
        }
        int32_t x;
        int32_t y;
    };
     static_assert(sizeof(XrOffset2Di) == sizeof(Offset2Di), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrOffset2Di pointer to const from a Offset2Di reference to const.
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrOffset2Di const* get(Offset2Di const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Di as the address of a raw XrOffset2Di
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrOffset2Di * put(Offset2Di &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrExtent2Di
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Di>
 * @xrentity{XrExtent2Di}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Extent2Di 
    {
    public:
        //! Constructor initializing all members.
                Extent2Di (
 int32_t width_,  int32_t height_                  )
: width {width_}
, height {height_}
        {
        }


        //! Default/empty constructor
                 Extent2Di (
            )

: width{0}
, height{0}
            {}

        //! Default copy constructor
        Extent2Di(const Extent2Di& rhs) = default;
        //! Default copy assignment
        Extent2Di& operator=(const Extent2Di& rhs) = default;
        //! Copy construct from raw
        Extent2Di(const XrExtent2Di& rhs) : Extent2Di() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Extent2Di& operator=(const XrExtent2Di& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExtent2Di &() const { return *reinterpret_cast<const XrExtent2Di*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExtent2Di &() {
            return *reinterpret_cast<XrExtent2Di*>(this);
        }

        //! Accessor for this as the address of a raw XrExtent2Di
        XrExtent2Di const* get() const noexcept { return reinterpret_cast<XrExtent2Di const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Di.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrExtent2Di * put(bool clear = true) noexcept {
            if (clear) {*this = Extent2Di{};}
            return reinterpret_cast<XrExtent2Di*>(this);
        }
        int32_t width;
        int32_t height;
    };
     static_assert(sizeof(XrExtent2Di) == sizeof(Extent2Di), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExtent2Di pointer to const from a Extent2Di reference to const.
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent2Di const* get(Extent2Di const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Di as the address of a raw XrExtent2Di
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent2Di * put(Extent2Di &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrRect2Di
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Di>
 * @xrentity{XrRect2Di}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Rect2Di 
    {
    public:
        //! Constructor initializing all members.
                Rect2Di (
 const Offset2Di& offset_,  const Extent2Di& extent_                  )
: offset {offset_}
, extent {extent_}
        {
        }


        //! Default/empty constructor
                 Rect2Di (
            )

: offset{}
, extent{}
            {}

        //! Default copy constructor
        Rect2Di(const Rect2Di& rhs) = default;
        //! Default copy assignment
        Rect2Di& operator=(const Rect2Di& rhs) = default;
        //! Copy construct from raw
        Rect2Di(const XrRect2Di& rhs) : Rect2Di() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Rect2Di& operator=(const XrRect2Di& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRect2Di &() const { return *reinterpret_cast<const XrRect2Di*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRect2Di &() {
            return *reinterpret_cast<XrRect2Di*>(this);
        }

        //! Accessor for this as the address of a raw XrRect2Di
        XrRect2Di const* get() const noexcept { return reinterpret_cast<XrRect2Di const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRect2Di.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrRect2Di * put(bool clear = true) noexcept {
            if (clear) {*this = Rect2Di{};}
            return reinterpret_cast<XrRect2Di*>(this);
        }
        Offset2Di offset;
        Extent2Di extent;
    };
     static_assert(sizeof(XrRect2Di) == sizeof(Rect2Di), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRect2Di pointer to const from a Rect2Di reference to const.
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRect2Di const* get(Rect2Di const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Di as the address of a raw XrRect2Di
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRect2Di * put(Rect2Di &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrSwapchainSubImage
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainSubImage>
 * @xrentity{XrSwapchainSubImage}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS SwapchainSubImage 
    {
    public:
        //! Constructor initializing all members.
                SwapchainSubImage (
 const Swapchain& swapchain_,  const Rect2Di& imageRect_,  uint32_t imageArrayIndex_                  )
: swapchain {swapchain_}
, imageRect {imageRect_}
, imageArrayIndex {imageArrayIndex_}
        {
        }


        //! Default/empty constructor
                 SwapchainSubImage (
            )

: swapchain{}
, imageRect{}
, imageArrayIndex{0}
            {}

        //! Default copy constructor
        SwapchainSubImage(const SwapchainSubImage& rhs) = default;
        //! Default copy assignment
        SwapchainSubImage& operator=(const SwapchainSubImage& rhs) = default;
        //! Copy construct from raw
        SwapchainSubImage(const XrSwapchainSubImage& rhs) : SwapchainSubImage() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainSubImage& operator=(const XrSwapchainSubImage& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainSubImage &() const { return *reinterpret_cast<const XrSwapchainSubImage*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainSubImage &() {
            return *reinterpret_cast<XrSwapchainSubImage*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainSubImage
        XrSwapchainSubImage const* get() const noexcept { return reinterpret_cast<XrSwapchainSubImage const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainSubImage.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrSwapchainSubImage * put(bool clear = true) noexcept {
            if (clear) {*this = SwapchainSubImage{};}
            return reinterpret_cast<XrSwapchainSubImage*>(this);
        }
        Swapchain swapchain;
        Rect2Di imageRect;
        uint32_t imageArrayIndex;
    };
     static_assert(sizeof(XrSwapchainSubImage) == sizeof(SwapchainSubImage), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainSubImage pointer to const from a SwapchainSubImage reference to const.
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainSubImage const* get(SwapchainSubImage const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainSubImage as the address of a raw XrSwapchainSubImage
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainSubImage * put(SwapchainSubImage &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrCompositionLayerProjectionView
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjectionView>
 * @xrentity{XrCompositionLayerProjectionView}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerProjectionView : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerProjectionView (
 const Posef& pose_,  const Fovf& fov_,  const SwapchainSubImage& subImage_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerProjectionView
, next_)
, pose {pose_}
, fov {fov_}
, subImage {subImage_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerProjectionView (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerProjectionView
             , next_)
, pose{}
, fov{}
, subImage{}
            {}

        //! Default copy constructor
        CompositionLayerProjectionView(const CompositionLayerProjectionView& rhs) = default;
        //! Default copy assignment
        CompositionLayerProjectionView& operator=(const CompositionLayerProjectionView& rhs) = default;
        //! Copy construct from raw
        CompositionLayerProjectionView(const XrCompositionLayerProjectionView& rhs) : CompositionLayerProjectionView() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerProjectionView& operator=(const XrCompositionLayerProjectionView& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerProjectionView &() const { return *reinterpret_cast<const XrCompositionLayerProjectionView*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerProjectionView &() {
            return *reinterpret_cast<XrCompositionLayerProjectionView*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerProjectionView
        XrCompositionLayerProjectionView const* get() const noexcept { return reinterpret_cast<XrCompositionLayerProjectionView const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerProjectionView.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerProjectionView * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerProjectionView{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerProjectionView*>(this);
        }
        Posef pose;
        Fovf fov;
        SwapchainSubImage subImage;
    };
     static_assert(sizeof(XrCompositionLayerProjectionView) == sizeof(CompositionLayerProjectionView), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjectionView pointer to const from a CompositionLayerProjectionView reference to const.
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerProjectionView const* get(CompositionLayerProjectionView const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerProjectionView as the address of a raw XrCompositionLayerProjectionView
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerProjectionView * put(CompositionLayerProjectionView &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrCompositionLayerProjection
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjection>
 * @xrentity{XrCompositionLayerProjection}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerProjection : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerProjection (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  uint32_t viewCount_,  const CompositionLayerProjectionView* views_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerProjection
, layerFlags_, space_, next_)
, viewCount {viewCount_}
, views {views_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerProjection (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerProjection
, {}, {}             , next_)
, viewCount{0}
, views{nullptr}
            {}

        //! Default copy constructor
        CompositionLayerProjection(const CompositionLayerProjection& rhs) = default;
        //! Default copy assignment
        CompositionLayerProjection& operator=(const CompositionLayerProjection& rhs) = default;
        //! Copy construct from raw
        CompositionLayerProjection(const XrCompositionLayerProjection& rhs) : CompositionLayerProjection() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerProjection& operator=(const XrCompositionLayerProjection& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerProjection &() const { return *reinterpret_cast<const XrCompositionLayerProjection*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerProjection &() {
            return *reinterpret_cast<XrCompositionLayerProjection*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerProjection
        XrCompositionLayerProjection const* get() const noexcept { return reinterpret_cast<XrCompositionLayerProjection const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerProjection.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerProjection * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerProjection{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerProjection*>(this);
        }
        uint32_t viewCount;
        const CompositionLayerProjectionView* views;
    };
     static_assert(sizeof(XrCompositionLayerProjection) == sizeof(CompositionLayerProjection), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjection pointer to const from a CompositionLayerProjection reference to const.
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerProjection const* get(CompositionLayerProjection const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerProjection as the address of a raw XrCompositionLayerProjection
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerProjection * put(CompositionLayerProjection &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerProjection as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerProjection
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerProjection const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrCompositionLayerQuad
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerQuad>
 * @xrentity{XrCompositionLayerQuad}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerQuad : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerQuad (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  const EyeVisibility& eyeVisibility_,  const SwapchainSubImage& subImage_,  const Posef& pose_,  const Extent2Df& size_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerQuad
, layerFlags_, space_, next_)
, eyeVisibility {eyeVisibility_}
, subImage {subImage_}
, pose {pose_}
, size {size_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerQuad (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerQuad
, {}, {}             , next_)
, eyeVisibility{}
, subImage{}
, pose{}
, size{}
            {}

        //! Default copy constructor
        CompositionLayerQuad(const CompositionLayerQuad& rhs) = default;
        //! Default copy assignment
        CompositionLayerQuad& operator=(const CompositionLayerQuad& rhs) = default;
        //! Copy construct from raw
        CompositionLayerQuad(const XrCompositionLayerQuad& rhs) : CompositionLayerQuad() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerQuad& operator=(const XrCompositionLayerQuad& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerQuad &() const { return *reinterpret_cast<const XrCompositionLayerQuad*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerQuad &() {
            return *reinterpret_cast<XrCompositionLayerQuad*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerQuad
        XrCompositionLayerQuad const* get() const noexcept { return reinterpret_cast<XrCompositionLayerQuad const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerQuad.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerQuad * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerQuad{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerQuad*>(this);
        }
        EyeVisibility eyeVisibility;
        SwapchainSubImage subImage;
        Posef pose;
        Extent2Df size;
    };
     static_assert(sizeof(XrCompositionLayerQuad) == sizeof(CompositionLayerQuad), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerQuad pointer to const from a CompositionLayerQuad reference to const.
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerQuad const* get(CompositionLayerQuad const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerQuad as the address of a raw XrCompositionLayerQuad
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerQuad * put(CompositionLayerQuad &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerQuad as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerQuad
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerQuad const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrEventDataBaseHeader
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBaseHeader>
 * @xrentity{XrEventDataBaseHeader}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS EventDataBaseHeader : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                EventDataBaseHeader (
  StructureType type_ ,  void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataBaseHeader &() const { return *reinterpret_cast<const XrEventDataBaseHeader*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataBaseHeader &() {
            return *reinterpret_cast<XrEventDataBaseHeader*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataBaseHeader
        XrEventDataBaseHeader const* get() const noexcept { return reinterpret_cast<XrEventDataBaseHeader const *>(this); }

    };
     static_assert(sizeof(XrEventDataBaseHeader) == sizeof(EventDataBaseHeader), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataBaseHeader pointer to const from a EventDataBaseHeader reference to const.
 * @relates EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get(EventDataBaseHeader const& s) {
        return s.get();
    }

































    
/*!
 * C++ projection of XrEventDataEventsLost
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataEventsLost>
 * @xrentity{XrEventDataEventsLost}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataEventsLost : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataEventsLost (
            void * next_ = nullptr)

: Parent(StructureType::EventDataEventsLost
             , next_)
            {}

        //! Default copy constructor
        EventDataEventsLost(const EventDataEventsLost& rhs) = default;
        //! Default copy assignment
        EventDataEventsLost& operator=(const EventDataEventsLost& rhs) = default;
        //! Copy construct from raw
        EventDataEventsLost(const XrEventDataEventsLost& rhs) : EventDataEventsLost() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataEventsLost& operator=(const XrEventDataEventsLost& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataEventsLost &() const { return *reinterpret_cast<const XrEventDataEventsLost*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataEventsLost &() {
            return *reinterpret_cast<XrEventDataEventsLost*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataEventsLost
        XrEventDataEventsLost const* get() const noexcept { return reinterpret_cast<XrEventDataEventsLost const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataEventsLost.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataEventsLost * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataEventsLost{};next = oldNext;}
            return reinterpret_cast<XrEventDataEventsLost*>(this);
        }
        uint32_t lostEventCount;
    };
     static_assert(sizeof(XrEventDataEventsLost) == sizeof(EventDataEventsLost), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataEventsLost pointer to const from a EventDataEventsLost reference to const.
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataEventsLost const* get(EventDataEventsLost const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataEventsLost as the address of a raw XrEventDataEventsLost
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataEventsLost * put(EventDataEventsLost &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataEventsLost as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataEventsLost
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataEventsLost const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrEventDataInstanceLossPending
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInstanceLossPending>
 * @xrentity{XrEventDataInstanceLossPending}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataInstanceLossPending : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataInstanceLossPending (
            void * next_ = nullptr)

: Parent(StructureType::EventDataInstanceLossPending
             , next_)
            {}

        //! Default copy constructor
        EventDataInstanceLossPending(const EventDataInstanceLossPending& rhs) = default;
        //! Default copy assignment
        EventDataInstanceLossPending& operator=(const EventDataInstanceLossPending& rhs) = default;
        //! Copy construct from raw
        EventDataInstanceLossPending(const XrEventDataInstanceLossPending& rhs) : EventDataInstanceLossPending() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataInstanceLossPending& operator=(const XrEventDataInstanceLossPending& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataInstanceLossPending &() const { return *reinterpret_cast<const XrEventDataInstanceLossPending*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataInstanceLossPending &() {
            return *reinterpret_cast<XrEventDataInstanceLossPending*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataInstanceLossPending
        XrEventDataInstanceLossPending const* get() const noexcept { return reinterpret_cast<XrEventDataInstanceLossPending const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataInstanceLossPending.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataInstanceLossPending * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataInstanceLossPending{};next = oldNext;}
            return reinterpret_cast<XrEventDataInstanceLossPending*>(this);
        }
        Time lossTime;
    };
     static_assert(sizeof(XrEventDataInstanceLossPending) == sizeof(EventDataInstanceLossPending), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataInstanceLossPending pointer to const from a EventDataInstanceLossPending reference to const.
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataInstanceLossPending const* get(EventDataInstanceLossPending const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataInstanceLossPending as the address of a raw XrEventDataInstanceLossPending
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataInstanceLossPending * put(EventDataInstanceLossPending &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataInstanceLossPending as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInstanceLossPending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataInstanceLossPending const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrEventDataSessionStateChanged
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSessionStateChanged>
 * @xrentity{XrEventDataSessionStateChanged}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSessionStateChanged : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSessionStateChanged (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSessionStateChanged
             , next_)
            {}

        //! Default copy constructor
        EventDataSessionStateChanged(const EventDataSessionStateChanged& rhs) = default;
        //! Default copy assignment
        EventDataSessionStateChanged& operator=(const EventDataSessionStateChanged& rhs) = default;
        //! Copy construct from raw
        EventDataSessionStateChanged(const XrEventDataSessionStateChanged& rhs) : EventDataSessionStateChanged() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSessionStateChanged& operator=(const XrEventDataSessionStateChanged& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSessionStateChanged &() const { return *reinterpret_cast<const XrEventDataSessionStateChanged*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSessionStateChanged &() {
            return *reinterpret_cast<XrEventDataSessionStateChanged*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSessionStateChanged
        XrEventDataSessionStateChanged const* get() const noexcept { return reinterpret_cast<XrEventDataSessionStateChanged const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSessionStateChanged.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSessionStateChanged * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSessionStateChanged{};next = oldNext;}
            return reinterpret_cast<XrEventDataSessionStateChanged*>(this);
        }
        Session session;
        SessionState state;
        Time time;
    };
     static_assert(sizeof(XrEventDataSessionStateChanged) == sizeof(EventDataSessionStateChanged), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSessionStateChanged pointer to const from a EventDataSessionStateChanged reference to const.
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSessionStateChanged const* get(EventDataSessionStateChanged const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSessionStateChanged as the address of a raw XrEventDataSessionStateChanged
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSessionStateChanged * put(EventDataSessionStateChanged &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSessionStateChanged as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSessionStateChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSessionStateChanged const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrEventDataReferenceSpaceChangePending
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataReferenceSpaceChangePending>
 * @xrentity{XrEventDataReferenceSpaceChangePending}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataReferenceSpaceChangePending : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataReferenceSpaceChangePending (
            void * next_ = nullptr)

: Parent(StructureType::EventDataReferenceSpaceChangePending
             , next_)
            {}

        //! Default copy constructor
        EventDataReferenceSpaceChangePending(const EventDataReferenceSpaceChangePending& rhs) = default;
        //! Default copy assignment
        EventDataReferenceSpaceChangePending& operator=(const EventDataReferenceSpaceChangePending& rhs) = default;
        //! Copy construct from raw
        EventDataReferenceSpaceChangePending(const XrEventDataReferenceSpaceChangePending& rhs) : EventDataReferenceSpaceChangePending() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataReferenceSpaceChangePending& operator=(const XrEventDataReferenceSpaceChangePending& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataReferenceSpaceChangePending &() const { return *reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataReferenceSpaceChangePending &() {
            return *reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataReferenceSpaceChangePending
        XrEventDataReferenceSpaceChangePending const* get() const noexcept { return reinterpret_cast<XrEventDataReferenceSpaceChangePending const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataReferenceSpaceChangePending.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataReferenceSpaceChangePending * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataReferenceSpaceChangePending{};next = oldNext;}
            return reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
        }
        Session session;
        ReferenceSpaceType referenceSpaceType;
        Time changeTime;
        Bool32 poseValid;
        Posef poseInPreviousSpace;
    };
     static_assert(sizeof(XrEventDataReferenceSpaceChangePending) == sizeof(EventDataReferenceSpaceChangePending), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataReferenceSpaceChangePending pointer to const from a EventDataReferenceSpaceChangePending reference to const.
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending const* get(EventDataReferenceSpaceChangePending const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataReferenceSpaceChangePending as the address of a raw XrEventDataReferenceSpaceChangePending
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending * put(EventDataReferenceSpaceChangePending &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataReferenceSpaceChangePending as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataReferenceSpaceChangePending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataReferenceSpaceChangePending const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrEventDataInteractionProfileChanged
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInteractionProfileChanged>
 * @xrentity{XrEventDataInteractionProfileChanged}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataInteractionProfileChanged : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataInteractionProfileChanged (
            void * next_ = nullptr)

: Parent(StructureType::EventDataInteractionProfileChanged
             , next_)
            {}

        //! Default copy constructor
        EventDataInteractionProfileChanged(const EventDataInteractionProfileChanged& rhs) = default;
        //! Default copy assignment
        EventDataInteractionProfileChanged& operator=(const EventDataInteractionProfileChanged& rhs) = default;
        //! Copy construct from raw
        EventDataInteractionProfileChanged(const XrEventDataInteractionProfileChanged& rhs) : EventDataInteractionProfileChanged() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataInteractionProfileChanged& operator=(const XrEventDataInteractionProfileChanged& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataInteractionProfileChanged &() const { return *reinterpret_cast<const XrEventDataInteractionProfileChanged*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataInteractionProfileChanged &() {
            return *reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataInteractionProfileChanged
        XrEventDataInteractionProfileChanged const* get() const noexcept { return reinterpret_cast<XrEventDataInteractionProfileChanged const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataInteractionProfileChanged.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataInteractionProfileChanged * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataInteractionProfileChanged{};next = oldNext;}
            return reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
        }
        Session session;
    };
     static_assert(sizeof(XrEventDataInteractionProfileChanged) == sizeof(EventDataInteractionProfileChanged), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataInteractionProfileChanged pointer to const from a EventDataInteractionProfileChanged reference to const.
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged const* get(EventDataInteractionProfileChanged const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataInteractionProfileChanged as the address of a raw XrEventDataInteractionProfileChanged
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged * put(EventDataInteractionProfileChanged &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataInteractionProfileChanged as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInteractionProfileChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataInteractionProfileChanged const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrHapticVibration
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticVibration>
 * @xrentity{XrHapticVibration}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HapticVibration : public HapticBaseHeader
    {
    private:
        using Parent = HapticBaseHeader;
    public:
        //! Constructor initializing all members.
                HapticVibration (
 const Duration& duration_,  float frequency_,  float amplitude_,  const void * next_ = nullptr                  )
: Parent(StructureType::HapticVibration
, next_)
, duration {duration_}
, frequency {frequency_}
, amplitude {amplitude_}
        {
        }


        //! Default/empty constructor
                 HapticVibration (
            const void * next_ = nullptr)

: Parent(StructureType::HapticVibration
             , next_)
, duration{}
, frequency{0.0f}
, amplitude{0.0f}
            {}

        //! Default copy constructor
        HapticVibration(const HapticVibration& rhs) = default;
        //! Default copy assignment
        HapticVibration& operator=(const HapticVibration& rhs) = default;
        //! Copy construct from raw
        HapticVibration(const XrHapticVibration& rhs) : HapticVibration() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HapticVibration& operator=(const XrHapticVibration& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHapticVibration &() const { return *reinterpret_cast<const XrHapticVibration*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHapticVibration &() {
            return *reinterpret_cast<XrHapticVibration*>(this);
        }

        //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
        XrHapticBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrHapticBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrHapticVibration
        XrHapticVibration const* get() const noexcept { return reinterpret_cast<XrHapticVibration const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHapticVibration.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHapticVibration * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HapticVibration{};next = oldNext;}
            return reinterpret_cast<XrHapticVibration*>(this);
        }
        Duration duration;
        float frequency;
        float amplitude;
    };
     static_assert(sizeof(XrHapticVibration) == sizeof(HapticVibration), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHapticVibration pointer to const from a HapticVibration reference to const.
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticVibration const* get(HapticVibration const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticVibration as the address of a raw XrHapticVibration
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticVibration * put(HapticVibration &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const HapticVibration as a raw, pointer to const XrHapticBaseHeader (the base type)
 * @relates HapticVibration
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticVibration const& h) {
        return h.get_base();
    }
































    
/*!
 * C++ projection of XrOffset2Df
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Df>
 * @xrentity{XrOffset2Df}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Offset2Df 
    {
    public:
        //! Constructor initializing all members.
                Offset2Df (
 float x_,  float y_                  )
: x {x_}
, y {y_}
        {
        }


        //! Default/empty constructor
                 Offset2Df (
            )

: x{0.0f}
, y{0.0f}
            {}

        //! Default copy constructor
        Offset2Df(const Offset2Df& rhs) = default;
        //! Default copy assignment
        Offset2Df& operator=(const Offset2Df& rhs) = default;
        //! Copy construct from raw
        Offset2Df(const XrOffset2Df& rhs) : Offset2Df() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Offset2Df& operator=(const XrOffset2Df& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrOffset2Df &() const { return *reinterpret_cast<const XrOffset2Df*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrOffset2Df &() {
            return *reinterpret_cast<XrOffset2Df*>(this);
        }

        //! Accessor for this as the address of a raw XrOffset2Df
        XrOffset2Df const* get() const noexcept { return reinterpret_cast<XrOffset2Df const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Df.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrOffset2Df * put(bool clear = true) noexcept {
            if (clear) {*this = Offset2Df{};}
            return reinterpret_cast<XrOffset2Df*>(this);
        }
        float x;
        float y;
    };
     static_assert(sizeof(XrOffset2Df) == sizeof(Offset2Df), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrOffset2Df pointer to const from a Offset2Df reference to const.
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrOffset2Df const* get(Offset2Df const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Df as the address of a raw XrOffset2Df
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrOffset2Df * put(Offset2Df &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrRect2Df
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Df>
 * @xrentity{XrRect2Df}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Rect2Df 
    {
    public:
        //! Constructor initializing all members.
                Rect2Df (
 const Offset2Df& offset_,  const Extent2Df& extent_                  )
: offset {offset_}
, extent {extent_}
        {
        }


        //! Default/empty constructor
                 Rect2Df (
            )

: offset{}
, extent{}
            {}

        //! Default copy constructor
        Rect2Df(const Rect2Df& rhs) = default;
        //! Default copy assignment
        Rect2Df& operator=(const Rect2Df& rhs) = default;
        //! Copy construct from raw
        Rect2Df(const XrRect2Df& rhs) : Rect2Df() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Rect2Df& operator=(const XrRect2Df& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRect2Df &() const { return *reinterpret_cast<const XrRect2Df*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRect2Df &() {
            return *reinterpret_cast<XrRect2Df*>(this);
        }

        //! Accessor for this as the address of a raw XrRect2Df
        XrRect2Df const* get() const noexcept { return reinterpret_cast<XrRect2Df const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRect2Df.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrRect2Df * put(bool clear = true) noexcept {
            if (clear) {*this = Rect2Df{};}
            return reinterpret_cast<XrRect2Df*>(this);
        }
        Offset2Df offset;
        Extent2Df extent;
    };
     static_assert(sizeof(XrRect2Df) == sizeof(Rect2Df), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRect2Df pointer to const from a Rect2Df reference to const.
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRect2Df const* get(Rect2Df const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Df as the address of a raw XrRect2Df
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRect2Df * put(Rect2Df &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrVector4f
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4f>
 * @xrentity{XrVector4f}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Vector4f 
    {
    public:
        //! Constructor initializing all members.
                Vector4f (
 float x_,  float y_,  float z_,  float w_                  )
: x {x_}
, y {y_}
, z {z_}
, w {w_}
        {
        }


        //! Default/empty constructor
                 Vector4f (
            )

: x{0.0f}
, y{0.0f}
, z{0.0f}
, w{0.0f}
            {}

        //! Default copy constructor
        Vector4f(const Vector4f& rhs) = default;
        //! Default copy assignment
        Vector4f& operator=(const Vector4f& rhs) = default;
        //! Copy construct from raw
        Vector4f(const XrVector4f& rhs) : Vector4f() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Vector4f& operator=(const XrVector4f& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVector4f &() const { return *reinterpret_cast<const XrVector4f*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVector4f &() {
            return *reinterpret_cast<XrVector4f*>(this);
        }

        //! Accessor for this as the address of a raw XrVector4f
        XrVector4f const* get() const noexcept { return reinterpret_cast<XrVector4f const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVector4f.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrVector4f * put(bool clear = true) noexcept {
            if (clear) {*this = Vector4f{};}
            return reinterpret_cast<XrVector4f*>(this);
        }
        float x;
        float y;
        float z;
        float w;
    };
     static_assert(sizeof(XrVector4f) == sizeof(Vector4f), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVector4f pointer to const from a Vector4f reference to const.
 * @relates Vector4f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector4f const* get(Vector4f const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4f as the address of a raw XrVector4f
 * @relates Vector4f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector4f * put(Vector4f &s, bool clear = true) noexcept { return s.put(clear); }
































    
/*!
 * C++ projection of XrColor4f
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColor4f>
 * @xrentity{XrColor4f}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Color4f 
    {
    public:
        //! Constructor initializing all members.
                Color4f (
 float r_,  float g_,  float b_,  float a_                  )
: r {r_}
, g {g_}
, b {b_}
, a {a_}
        {
        }


        //! Default/empty constructor
                 Color4f (
            )

: r{0.0f}
, g{0.0f}
, b{0.0f}
, a{0.0f}
            {}

        //! Default copy constructor
        Color4f(const Color4f& rhs) = default;
        //! Default copy assignment
        Color4f& operator=(const Color4f& rhs) = default;
        //! Copy construct from raw
        Color4f(const XrColor4f& rhs) : Color4f() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Color4f& operator=(const XrColor4f& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrColor4f &() const { return *reinterpret_cast<const XrColor4f*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrColor4f &() {
            return *reinterpret_cast<XrColor4f*>(this);
        }

        //! Accessor for this as the address of a raw XrColor4f
        XrColor4f const* get() const noexcept { return reinterpret_cast<XrColor4f const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrColor4f.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrColor4f * put(bool clear = true) noexcept {
            if (clear) {*this = Color4f{};}
            return reinterpret_cast<XrColor4f*>(this);
        }
        float r;
        float g;
        float b;
        float a;
    };
     static_assert(sizeof(XrColor4f) == sizeof(Color4f), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrColor4f pointer to const from a Color4f reference to const.
 * @relates Color4f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrColor4f const* get(Color4f const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Color4f as the address of a raw XrColor4f
 * @relates Color4f
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrColor4f * put(Color4f &s, bool clear = true) noexcept { return s.put(clear); }
































    #ifdef XR_KHR_composition_layer_cube
/*!
 * C++ projection of XrCompositionLayerCubeKHR
 * 
 * Provided by the `XR_KHR_composition_layer_cube` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCubeKHR>
 * @xrentity{XrCompositionLayerCubeKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerCubeKHR : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerCubeKHR (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  const EyeVisibility& eyeVisibility_,  const Swapchain& swapchain_,  uint32_t imageArrayIndex_,  const Quaternionf& orientation_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerCubeKHR
, layerFlags_, space_, next_)
, eyeVisibility {eyeVisibility_}
, swapchain {swapchain_}
, imageArrayIndex {imageArrayIndex_}
, orientation {orientation_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerCubeKHR (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerCubeKHR
, {}, {}             , next_)
, eyeVisibility{}
, swapchain{}
, imageArrayIndex{0}
, orientation{}
            {}

        //! Default copy constructor
        CompositionLayerCubeKHR(const CompositionLayerCubeKHR& rhs) = default;
        //! Default copy assignment
        CompositionLayerCubeKHR& operator=(const CompositionLayerCubeKHR& rhs) = default;
        //! Copy construct from raw
        CompositionLayerCubeKHR(const XrCompositionLayerCubeKHR& rhs) : CompositionLayerCubeKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerCubeKHR& operator=(const XrCompositionLayerCubeKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerCubeKHR &() const { return *reinterpret_cast<const XrCompositionLayerCubeKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerCubeKHR &() {
            return *reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerCubeKHR
        XrCompositionLayerCubeKHR const* get() const noexcept { return reinterpret_cast<XrCompositionLayerCubeKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerCubeKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerCubeKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerCubeKHR{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
        }
        EyeVisibility eyeVisibility;
        Swapchain swapchain;
        uint32_t imageArrayIndex;
        Quaternionf orientation;
    };
     static_assert(sizeof(XrCompositionLayerCubeKHR) == sizeof(CompositionLayerCubeKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerCubeKHR pointer to const from a CompositionLayerCubeKHR reference to const.
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR const* get(CompositionLayerCubeKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCubeKHR as the address of a raw XrCompositionLayerCubeKHR
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR * put(CompositionLayerCubeKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCubeKHR as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCubeKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerCubeKHR const& h) {
        return h.get_base();
    }
#endif  // XR_KHR_composition_layer_cube































    #ifdef XR_KHR_android_create_instance
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrInstanceCreateInfoAndroidKHR
 * 
 * Provided by the `XR_KHR_android_create_instance` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfoAndroidKHR>
 * @xrentity{XrInstanceCreateInfoAndroidKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InstanceCreateInfoAndroidKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                InstanceCreateInfoAndroidKHR (
 void* XR_MAY_ALIAS applicationVM_,  void* XR_MAY_ALIAS applicationActivity_,  const void * next_ = nullptr                  )
: Parent(StructureType::InstanceCreateInfoAndroidKHR
, next_)
, applicationVM {applicationVM_}
, applicationActivity {applicationActivity_}
        {
        }


        //! Default/empty constructor
                 InstanceCreateInfoAndroidKHR (
            const void * next_ = nullptr)

: Parent(StructureType::InstanceCreateInfoAndroidKHR
             , next_)
, applicationVM{nullptr}
, applicationActivity{nullptr}
            {}

        //! Default copy constructor
        InstanceCreateInfoAndroidKHR(const InstanceCreateInfoAndroidKHR& rhs) = default;
        //! Default copy assignment
        InstanceCreateInfoAndroidKHR& operator=(const InstanceCreateInfoAndroidKHR& rhs) = default;
        //! Copy construct from raw
        InstanceCreateInfoAndroidKHR(const XrInstanceCreateInfoAndroidKHR& rhs) : InstanceCreateInfoAndroidKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InstanceCreateInfoAndroidKHR& operator=(const XrInstanceCreateInfoAndroidKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInstanceCreateInfoAndroidKHR &() const { return *reinterpret_cast<const XrInstanceCreateInfoAndroidKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInstanceCreateInfoAndroidKHR &() {
            return *reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrInstanceCreateInfoAndroidKHR
        XrInstanceCreateInfoAndroidKHR const* get() const noexcept { return reinterpret_cast<XrInstanceCreateInfoAndroidKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInstanceCreateInfoAndroidKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInstanceCreateInfoAndroidKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InstanceCreateInfoAndroidKHR{};next = oldNext;}
            return reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
        }
        void* XR_MAY_ALIAS applicationVM;
        void* XR_MAY_ALIAS applicationActivity;
    };
     static_assert(sizeof(XrInstanceCreateInfoAndroidKHR) == sizeof(InstanceCreateInfoAndroidKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfoAndroidKHR pointer to const from a InstanceCreateInfoAndroidKHR reference to const.
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR const* get(InstanceCreateInfoAndroidKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfoAndroidKHR as the address of a raw XrInstanceCreateInfoAndroidKHR
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR * put(InstanceCreateInfoAndroidKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_create_instance































    #ifdef XR_KHR_composition_layer_depth
/*!
 * C++ projection of XrCompositionLayerDepthInfoKHR
 * 
 * Provided by the `XR_KHR_composition_layer_depth` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthInfoKHR>
 * @xrentity{XrCompositionLayerDepthInfoKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerDepthInfoKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerDepthInfoKHR (
 const SwapchainSubImage& subImage_,  float minDepth_,  float maxDepth_,  float nearZ_,  float farZ_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerDepthInfoKHR
, next_)
, subImage {subImage_}
, minDepth {minDepth_}
, maxDepth {maxDepth_}
, nearZ {nearZ_}
, farZ {farZ_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerDepthInfoKHR (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerDepthInfoKHR
             , next_)
, subImage{}
, minDepth{0.0f}
, maxDepth{0.0f}
, nearZ{0.0f}
, farZ{0.0f}
            {}

        //! Default copy constructor
        CompositionLayerDepthInfoKHR(const CompositionLayerDepthInfoKHR& rhs) = default;
        //! Default copy assignment
        CompositionLayerDepthInfoKHR& operator=(const CompositionLayerDepthInfoKHR& rhs) = default;
        //! Copy construct from raw
        CompositionLayerDepthInfoKHR(const XrCompositionLayerDepthInfoKHR& rhs) : CompositionLayerDepthInfoKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerDepthInfoKHR& operator=(const XrCompositionLayerDepthInfoKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerDepthInfoKHR &() const { return *reinterpret_cast<const XrCompositionLayerDepthInfoKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerDepthInfoKHR &() {
            return *reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerDepthInfoKHR
        XrCompositionLayerDepthInfoKHR const* get() const noexcept { return reinterpret_cast<XrCompositionLayerDepthInfoKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerDepthInfoKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerDepthInfoKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerDepthInfoKHR{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
        }
        SwapchainSubImage subImage;
        float minDepth;
        float maxDepth;
        float nearZ;
        float farZ;
    };
     static_assert(sizeof(XrCompositionLayerDepthInfoKHR) == sizeof(CompositionLayerDepthInfoKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthInfoKHR pointer to const from a CompositionLayerDepthInfoKHR reference to const.
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR const* get(CompositionLayerDepthInfoKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthInfoKHR as the address of a raw XrCompositionLayerDepthInfoKHR
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR * put(CompositionLayerDepthInfoKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_KHR_composition_layer_depth































    #ifdef XR_KHR_vulkan_swapchain_format_list
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanSwapchainFormatListCreateInfoKHR
 * 
 * Provided by the `XR_KHR_vulkan_swapchain_format_list` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanSwapchainFormatListCreateInfoKHR>
 * @xrentity{XrVulkanSwapchainFormatListCreateInfoKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VulkanSwapchainFormatListCreateInfoKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VulkanSwapchainFormatListCreateInfoKHR (
 uint32_t viewFormatCount_,  const VkFormat* viewFormats_,  const void * next_ = nullptr                  )
: Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR
, next_)
, viewFormatCount {viewFormatCount_}
, viewFormats {viewFormats_}
        {
        }


        //! Default/empty constructor
                 VulkanSwapchainFormatListCreateInfoKHR (
            const void * next_ = nullptr)

: Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR
             , next_)
, viewFormatCount{0}
, viewFormats{nullptr}
            {}

        //! Default copy constructor
        VulkanSwapchainFormatListCreateInfoKHR(const VulkanSwapchainFormatListCreateInfoKHR& rhs) = default;
        //! Default copy assignment
        VulkanSwapchainFormatListCreateInfoKHR& operator=(const VulkanSwapchainFormatListCreateInfoKHR& rhs) = default;
        //! Copy construct from raw
        VulkanSwapchainFormatListCreateInfoKHR(const XrVulkanSwapchainFormatListCreateInfoKHR& rhs) : VulkanSwapchainFormatListCreateInfoKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VulkanSwapchainFormatListCreateInfoKHR& operator=(const XrVulkanSwapchainFormatListCreateInfoKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVulkanSwapchainFormatListCreateInfoKHR &() const { return *reinterpret_cast<const XrVulkanSwapchainFormatListCreateInfoKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVulkanSwapchainFormatListCreateInfoKHR &() {
            return *reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrVulkanSwapchainFormatListCreateInfoKHR
        XrVulkanSwapchainFormatListCreateInfoKHR const* get() const noexcept { return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVulkanSwapchainFormatListCreateInfoKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVulkanSwapchainFormatListCreateInfoKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VulkanSwapchainFormatListCreateInfoKHR{};next = oldNext;}
            return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
        }
        uint32_t viewFormatCount;
        const VkFormat* viewFormats;
    };
     static_assert(sizeof(XrVulkanSwapchainFormatListCreateInfoKHR) == sizeof(VulkanSwapchainFormatListCreateInfoKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVulkanSwapchainFormatListCreateInfoKHR pointer to const from a VulkanSwapchainFormatListCreateInfoKHR reference to const.
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR const* get(VulkanSwapchainFormatListCreateInfoKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanSwapchainFormatListCreateInfoKHR as the address of a raw XrVulkanSwapchainFormatListCreateInfoKHR
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR * put(VulkanSwapchainFormatListCreateInfoKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_swapchain_format_list































    #ifdef XR_KHR_composition_layer_cylinder
/*!
 * C++ projection of XrCompositionLayerCylinderKHR
 * 
 * Provided by the `XR_KHR_composition_layer_cylinder` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCylinderKHR>
 * @xrentity{XrCompositionLayerCylinderKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerCylinderKHR : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerCylinderKHR (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  const EyeVisibility& eyeVisibility_,  const SwapchainSubImage& subImage_,  const Posef& pose_,  float radius_,  float centralAngle_,  float aspectRatio_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerCylinderKHR
, layerFlags_, space_, next_)
, eyeVisibility {eyeVisibility_}
, subImage {subImage_}
, pose {pose_}
, radius {radius_}
, centralAngle {centralAngle_}
, aspectRatio {aspectRatio_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerCylinderKHR (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerCylinderKHR
, {}, {}             , next_)
, eyeVisibility{}
, subImage{}
, pose{}
, radius{0.0f}
, centralAngle{0.0f}
, aspectRatio{0.0f}
            {}

        //! Default copy constructor
        CompositionLayerCylinderKHR(const CompositionLayerCylinderKHR& rhs) = default;
        //! Default copy assignment
        CompositionLayerCylinderKHR& operator=(const CompositionLayerCylinderKHR& rhs) = default;
        //! Copy construct from raw
        CompositionLayerCylinderKHR(const XrCompositionLayerCylinderKHR& rhs) : CompositionLayerCylinderKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerCylinderKHR& operator=(const XrCompositionLayerCylinderKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerCylinderKHR &() const { return *reinterpret_cast<const XrCompositionLayerCylinderKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerCylinderKHR &() {
            return *reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerCylinderKHR
        XrCompositionLayerCylinderKHR const* get() const noexcept { return reinterpret_cast<XrCompositionLayerCylinderKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerCylinderKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerCylinderKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerCylinderKHR{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
        }
        EyeVisibility eyeVisibility;
        SwapchainSubImage subImage;
        Posef pose;
        float radius;
        float centralAngle;
        float aspectRatio;
    };
     static_assert(sizeof(XrCompositionLayerCylinderKHR) == sizeof(CompositionLayerCylinderKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerCylinderKHR pointer to const from a CompositionLayerCylinderKHR reference to const.
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR const* get(CompositionLayerCylinderKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCylinderKHR as the address of a raw XrCompositionLayerCylinderKHR
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR * put(CompositionLayerCylinderKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCylinderKHR as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCylinderKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerCylinderKHR const& h) {
        return h.get_base();
    }
#endif  // XR_KHR_composition_layer_cylinder































    #ifdef XR_KHR_composition_layer_equirect
/*!
 * C++ projection of XrCompositionLayerEquirectKHR
 * 
 * Provided by the `XR_KHR_composition_layer_equirect` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirectKHR>
 * @xrentity{XrCompositionLayerEquirectKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerEquirectKHR : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerEquirectKHR (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  const EyeVisibility& eyeVisibility_,  const SwapchainSubImage& subImage_,  const Posef& pose_,  float radius_,  const Vector2f& scale_,  const Vector2f& bias_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerEquirectKHR
, layerFlags_, space_, next_)
, eyeVisibility {eyeVisibility_}
, subImage {subImage_}
, pose {pose_}
, radius {radius_}
, scale {scale_}
, bias {bias_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerEquirectKHR (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerEquirectKHR
, {}, {}             , next_)
, eyeVisibility{}
, subImage{}
, pose{}
, radius{0.0f}
, scale{}
, bias{}
            {}

        //! Default copy constructor
        CompositionLayerEquirectKHR(const CompositionLayerEquirectKHR& rhs) = default;
        //! Default copy assignment
        CompositionLayerEquirectKHR& operator=(const CompositionLayerEquirectKHR& rhs) = default;
        //! Copy construct from raw
        CompositionLayerEquirectKHR(const XrCompositionLayerEquirectKHR& rhs) : CompositionLayerEquirectKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerEquirectKHR& operator=(const XrCompositionLayerEquirectKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerEquirectKHR &() const { return *reinterpret_cast<const XrCompositionLayerEquirectKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerEquirectKHR &() {
            return *reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerEquirectKHR
        XrCompositionLayerEquirectKHR const* get() const noexcept { return reinterpret_cast<XrCompositionLayerEquirectKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerEquirectKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerEquirectKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerEquirectKHR{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
        }
        EyeVisibility eyeVisibility;
        SwapchainSubImage subImage;
        Posef pose;
        float radius;
        Vector2f scale;
        Vector2f bias;
    };
     static_assert(sizeof(XrCompositionLayerEquirectKHR) == sizeof(CompositionLayerEquirectKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirectKHR pointer to const from a CompositionLayerEquirectKHR reference to const.
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR const* get(CompositionLayerEquirectKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirectKHR as the address of a raw XrCompositionLayerEquirectKHR
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR * put(CompositionLayerEquirectKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirectKHR as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirectKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerEquirectKHR const& h) {
        return h.get_base();
    }
#endif  // XR_KHR_composition_layer_equirect































    #ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWin32KHR
 * 
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWin32KHR>
 * @xrentity{XrGraphicsBindingOpenGLWin32KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingOpenGLWin32KHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingOpenGLWin32KHR (
 HDC hDC_,  HGLRC hGLRC_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingOpenGLWin32KHR
, next_)
, hDC {hDC_}
, hGLRC {hGLRC_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingOpenGLWin32KHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingOpenGLWin32KHR
             , next_)
, hDC{}
, hGLRC{}
            {}

        //! Default copy constructor
        GraphicsBindingOpenGLWin32KHR(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingOpenGLWin32KHR& operator=(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingOpenGLWin32KHR(const XrGraphicsBindingOpenGLWin32KHR& rhs) : GraphicsBindingOpenGLWin32KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingOpenGLWin32KHR& operator=(const XrGraphicsBindingOpenGLWin32KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingOpenGLWin32KHR &() const { return *reinterpret_cast<const XrGraphicsBindingOpenGLWin32KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingOpenGLWin32KHR &() {
            return *reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWin32KHR
        XrGraphicsBindingOpenGLWin32KHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingOpenGLWin32KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingOpenGLWin32KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingOpenGLWin32KHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
        }
        HDC hDC;
        HGLRC hGLRC;
    };
     static_assert(sizeof(XrGraphicsBindingOpenGLWin32KHR) == sizeof(GraphicsBindingOpenGLWin32KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWin32KHR pointer to const from a GraphicsBindingOpenGLWin32KHR reference to const.
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR const* get(GraphicsBindingOpenGLWin32KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLWin32KHR as the address of a raw XrGraphicsBindingOpenGLWin32KHR
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR * put(GraphicsBindingOpenGLWin32KHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_opengl_enable































    #ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXlibKHR
 * 
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXlibKHR>
 * @xrentity{XrGraphicsBindingOpenGLXlibKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingOpenGLXlibKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingOpenGLXlibKHR (
 Display* xDisplay_,  uint32_t visualid_,  GLXFBConfig glxFBConfig_,  GLXDrawable glxDrawable_,  GLXContext glxContext_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingOpenGLXlibKHR
, next_)
, xDisplay {xDisplay_}
, visualid {visualid_}
, glxFBConfig {glxFBConfig_}
, glxDrawable {glxDrawable_}
, glxContext {glxContext_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingOpenGLXlibKHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingOpenGLXlibKHR
             , next_)
, xDisplay{nullptr}
, visualid{0}
, glxFBConfig{}
, glxDrawable{}
, glxContext{}
            {}

        //! Default copy constructor
        GraphicsBindingOpenGLXlibKHR(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingOpenGLXlibKHR& operator=(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingOpenGLXlibKHR(const XrGraphicsBindingOpenGLXlibKHR& rhs) : GraphicsBindingOpenGLXlibKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingOpenGLXlibKHR& operator=(const XrGraphicsBindingOpenGLXlibKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingOpenGLXlibKHR &() const { return *reinterpret_cast<const XrGraphicsBindingOpenGLXlibKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingOpenGLXlibKHR &() {
            return *reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXlibKHR
        XrGraphicsBindingOpenGLXlibKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingOpenGLXlibKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingOpenGLXlibKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingOpenGLXlibKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
        }
        Display* xDisplay;
        uint32_t visualid;
        GLXFBConfig glxFBConfig;
        GLXDrawable glxDrawable;
        GLXContext glxContext;
    };
     static_assert(sizeof(XrGraphicsBindingOpenGLXlibKHR) == sizeof(GraphicsBindingOpenGLXlibKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXlibKHR pointer to const from a GraphicsBindingOpenGLXlibKHR reference to const.
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR const* get(GraphicsBindingOpenGLXlibKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXlibKHR as the address of a raw XrGraphicsBindingOpenGLXlibKHR
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR * put(GraphicsBindingOpenGLXlibKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#endif  // XR_KHR_opengl_enable































    #ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXcbKHR
 * 
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXcbKHR>
 * @xrentity{XrGraphicsBindingOpenGLXcbKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingOpenGLXcbKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingOpenGLXcbKHR (
 xcb_connection_t* connection_,  uint32_t screenNumber_,  xcb_glx_fbconfig_t fbconfigid_,  xcb_visualid_t visualid_,  xcb_glx_drawable_t glxDrawable_,  xcb_glx_context_t glxContext_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingOpenGLXcbKHR
, next_)
, connection {connection_}
, screenNumber {screenNumber_}
, fbconfigid {fbconfigid_}
, visualid {visualid_}
, glxDrawable {glxDrawable_}
, glxContext {glxContext_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingOpenGLXcbKHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingOpenGLXcbKHR
             , next_)
, connection{}
, screenNumber{0}
, fbconfigid{}
, visualid{}
, glxDrawable{}
, glxContext{}
            {}

        //! Default copy constructor
        GraphicsBindingOpenGLXcbKHR(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingOpenGLXcbKHR& operator=(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingOpenGLXcbKHR(const XrGraphicsBindingOpenGLXcbKHR& rhs) : GraphicsBindingOpenGLXcbKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingOpenGLXcbKHR& operator=(const XrGraphicsBindingOpenGLXcbKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingOpenGLXcbKHR &() const { return *reinterpret_cast<const XrGraphicsBindingOpenGLXcbKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingOpenGLXcbKHR &() {
            return *reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXcbKHR
        XrGraphicsBindingOpenGLXcbKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingOpenGLXcbKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingOpenGLXcbKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingOpenGLXcbKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
        }
        xcb_connection_t* connection;
        uint32_t screenNumber;
        xcb_glx_fbconfig_t fbconfigid;
        xcb_visualid_t visualid;
        xcb_glx_drawable_t glxDrawable;
        xcb_glx_context_t glxContext;
    };
     static_assert(sizeof(XrGraphicsBindingOpenGLXcbKHR) == sizeof(GraphicsBindingOpenGLXcbKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXcbKHR pointer to const from a GraphicsBindingOpenGLXcbKHR reference to const.
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR const* get(GraphicsBindingOpenGLXcbKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXcbKHR as the address of a raw XrGraphicsBindingOpenGLXcbKHR
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR * put(GraphicsBindingOpenGLXcbKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#endif  // XR_KHR_opengl_enable































    #ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWaylandKHR
 * 
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWaylandKHR>
 * @xrentity{XrGraphicsBindingOpenGLWaylandKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingOpenGLWaylandKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingOpenGLWaylandKHR (
 struct wl_display* display_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingOpenGLWaylandKHR
, next_)
, display {display_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingOpenGLWaylandKHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingOpenGLWaylandKHR
             , next_)
, display{}
            {}

        //! Default copy constructor
        GraphicsBindingOpenGLWaylandKHR(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingOpenGLWaylandKHR& operator=(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingOpenGLWaylandKHR(const XrGraphicsBindingOpenGLWaylandKHR& rhs) : GraphicsBindingOpenGLWaylandKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingOpenGLWaylandKHR& operator=(const XrGraphicsBindingOpenGLWaylandKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingOpenGLWaylandKHR &() const { return *reinterpret_cast<const XrGraphicsBindingOpenGLWaylandKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingOpenGLWaylandKHR &() {
            return *reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
        XrGraphicsBindingOpenGLWaylandKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingOpenGLWaylandKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingOpenGLWaylandKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingOpenGLWaylandKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
        }
        struct wl_display* display;
    };
     static_assert(sizeof(XrGraphicsBindingOpenGLWaylandKHR) == sizeof(GraphicsBindingOpenGLWaylandKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWaylandKHR pointer to const from a GraphicsBindingOpenGLWaylandKHR reference to const.
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR const* get(GraphicsBindingOpenGLWaylandKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLWaylandKHR as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR * put(GraphicsBindingOpenGLWaylandKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#endif  // XR_KHR_opengl_enable































    #ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrSwapchainImageOpenGLKHR
 * 
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLKHR>
 * @xrentity{XrSwapchainImageOpenGLKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageOpenGLKHR : public SwapchainImageBaseHeader
    {
    private:
        using Parent = SwapchainImageBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainImageOpenGLKHR (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainImageOpenGLKHR
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageOpenGLKHR(const SwapchainImageOpenGLKHR& rhs) = default;
        //! Default copy assignment
        SwapchainImageOpenGLKHR& operator=(const SwapchainImageOpenGLKHR& rhs) = default;
        //! Copy construct from raw
        SwapchainImageOpenGLKHR(const XrSwapchainImageOpenGLKHR& rhs) : SwapchainImageOpenGLKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageOpenGLKHR& operator=(const XrSwapchainImageOpenGLKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageOpenGLKHR &() const { return *reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageOpenGLKHR &() {
            return *reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
        XrSwapchainImageBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainImageOpenGLKHR
        XrSwapchainImageOpenGLKHR const* get() const noexcept { return reinterpret_cast<XrSwapchainImageOpenGLKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageOpenGLKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageOpenGLKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageOpenGLKHR{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
        }
        uint32_t image;
    };
     static_assert(sizeof(XrSwapchainImageOpenGLKHR) == sizeof(SwapchainImageOpenGLKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLKHR pointer to const from a SwapchainImageOpenGLKHR reference to const.
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR const* get(SwapchainImageOpenGLKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLKHR as the address of a raw XrSwapchainImageOpenGLKHR
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR * put(SwapchainImageOpenGLKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLKHR as a raw, pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(SwapchainImageOpenGLKHR const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable































    #ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLKHR
 * 
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsRequirementsOpenGLKHR : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 GraphicsRequirementsOpenGLKHR (
            void * next_ = nullptr)

: Parent(StructureType::GraphicsRequirementsOpenGLKHR
             , next_)
            {}

        //! Default copy constructor
        GraphicsRequirementsOpenGLKHR(const GraphicsRequirementsOpenGLKHR& rhs) = default;
        //! Default copy assignment
        GraphicsRequirementsOpenGLKHR& operator=(const GraphicsRequirementsOpenGLKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsRequirementsOpenGLKHR(const XrGraphicsRequirementsOpenGLKHR& rhs) : GraphicsRequirementsOpenGLKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsRequirementsOpenGLKHR& operator=(const XrGraphicsRequirementsOpenGLKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsRequirementsOpenGLKHR &() const { return *reinterpret_cast<const XrGraphicsRequirementsOpenGLKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsRequirementsOpenGLKHR &() {
            return *reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLKHR
        XrGraphicsRequirementsOpenGLKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsRequirementsOpenGLKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsRequirementsOpenGLKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsRequirementsOpenGLKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
        }
        Version minApiVersionSupported;
        Version maxApiVersionSupported;
    };
     static_assert(sizeof(XrGraphicsRequirementsOpenGLKHR) == sizeof(GraphicsRequirementsOpenGLKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLKHR pointer to const from a GraphicsRequirementsOpenGLKHR reference to const.
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR const* get(GraphicsRequirementsOpenGLKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsOpenGLKHR as the address of a raw XrGraphicsRequirementsOpenGLKHR
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR * put(GraphicsRequirementsOpenGLKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable































    #ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrGraphicsBindingOpenGLESAndroidKHR
 * 
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLESAndroidKHR>
 * @xrentity{XrGraphicsBindingOpenGLESAndroidKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingOpenGLESAndroidKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingOpenGLESAndroidKHR (
 EGLDisplay display_,  EGLConfig config_,  EGLContext context_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR
, next_)
, display {display_}
, config {config_}
, context {context_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingOpenGLESAndroidKHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR
             , next_)
, display{}
, config{}
, context{}
            {}

        //! Default copy constructor
        GraphicsBindingOpenGLESAndroidKHR(const GraphicsBindingOpenGLESAndroidKHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingOpenGLESAndroidKHR& operator=(const GraphicsBindingOpenGLESAndroidKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingOpenGLESAndroidKHR(const XrGraphicsBindingOpenGLESAndroidKHR& rhs) : GraphicsBindingOpenGLESAndroidKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingOpenGLESAndroidKHR& operator=(const XrGraphicsBindingOpenGLESAndroidKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingOpenGLESAndroidKHR &() const { return *reinterpret_cast<const XrGraphicsBindingOpenGLESAndroidKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingOpenGLESAndroidKHR &() {
            return *reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
        XrGraphicsBindingOpenGLESAndroidKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingOpenGLESAndroidKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingOpenGLESAndroidKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
        }
        EGLDisplay display;
        EGLConfig config;
        EGLContext context;
    };
     static_assert(sizeof(XrGraphicsBindingOpenGLESAndroidKHR) == sizeof(GraphicsBindingOpenGLESAndroidKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLESAndroidKHR pointer to const from a GraphicsBindingOpenGLESAndroidKHR reference to const.
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR const* get(GraphicsBindingOpenGLESAndroidKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLESAndroidKHR as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR * put(GraphicsBindingOpenGLESAndroidKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_opengl_es_enable































    #ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainImageOpenGLESKHR
 * 
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLESKHR>
 * @xrentity{XrSwapchainImageOpenGLESKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageOpenGLESKHR : public SwapchainImageBaseHeader
    {
    private:
        using Parent = SwapchainImageBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainImageOpenGLESKHR (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainImageOpenGLESKHR
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageOpenGLESKHR(const SwapchainImageOpenGLESKHR& rhs) = default;
        //! Default copy assignment
        SwapchainImageOpenGLESKHR& operator=(const SwapchainImageOpenGLESKHR& rhs) = default;
        //! Copy construct from raw
        SwapchainImageOpenGLESKHR(const XrSwapchainImageOpenGLESKHR& rhs) : SwapchainImageOpenGLESKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageOpenGLESKHR& operator=(const XrSwapchainImageOpenGLESKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageOpenGLESKHR &() const { return *reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageOpenGLESKHR &() {
            return *reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
        XrSwapchainImageBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainImageOpenGLESKHR
        XrSwapchainImageOpenGLESKHR const* get() const noexcept { return reinterpret_cast<XrSwapchainImageOpenGLESKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageOpenGLESKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageOpenGLESKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageOpenGLESKHR{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
        }
        uint32_t image;
    };
     static_assert(sizeof(XrSwapchainImageOpenGLESKHR) == sizeof(SwapchainImageOpenGLESKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLESKHR pointer to const from a SwapchainImageOpenGLESKHR reference to const.
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR const* get(SwapchainImageOpenGLESKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLESKHR as the address of a raw XrSwapchainImageOpenGLESKHR
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR * put(SwapchainImageOpenGLESKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLESKHR as a raw, pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLESKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(SwapchainImageOpenGLESKHR const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable































    #ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLESKHR
 * 
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLESKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLESKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsRequirementsOpenGLESKHR : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 GraphicsRequirementsOpenGLESKHR (
            void * next_ = nullptr)

: Parent(StructureType::GraphicsRequirementsOpenGLESKHR
             , next_)
            {}

        //! Default copy constructor
        GraphicsRequirementsOpenGLESKHR(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
        //! Default copy assignment
        GraphicsRequirementsOpenGLESKHR& operator=(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsRequirementsOpenGLESKHR(const XrGraphicsRequirementsOpenGLESKHR& rhs) : GraphicsRequirementsOpenGLESKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsRequirementsOpenGLESKHR& operator=(const XrGraphicsRequirementsOpenGLESKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsRequirementsOpenGLESKHR &() const { return *reinterpret_cast<const XrGraphicsRequirementsOpenGLESKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsRequirementsOpenGLESKHR &() {
            return *reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLESKHR
        XrGraphicsRequirementsOpenGLESKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsRequirementsOpenGLESKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsRequirementsOpenGLESKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsRequirementsOpenGLESKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
        }
        Version minApiVersionSupported;
        Version maxApiVersionSupported;
    };
     static_assert(sizeof(XrGraphicsRequirementsOpenGLESKHR) == sizeof(GraphicsRequirementsOpenGLESKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLESKHR pointer to const from a GraphicsRequirementsOpenGLESKHR reference to const.
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR const* get(GraphicsRequirementsOpenGLESKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsOpenGLESKHR as the address of a raw XrGraphicsRequirementsOpenGLESKHR
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR * put(GraphicsRequirementsOpenGLESKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable































    #ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsBindingVulkanKHR
 * 
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingVulkanKHR>
 * @xrentity{XrGraphicsBindingVulkanKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingVulkanKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingVulkanKHR (
 VkInstance instance_,  VkPhysicalDevice physicalDevice_,  VkDevice device_,  uint32_t queueFamilyIndex_,  uint32_t queueIndex_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingVulkanKHR
, next_)
, instance {instance_}
, physicalDevice {physicalDevice_}
, device {device_}
, queueFamilyIndex {queueFamilyIndex_}
, queueIndex {queueIndex_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingVulkanKHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingVulkanKHR
             , next_)
, instance{}
, physicalDevice{}
, device{}
, queueFamilyIndex{0}
, queueIndex{0}
            {}

        //! Default copy constructor
        GraphicsBindingVulkanKHR(const GraphicsBindingVulkanKHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingVulkanKHR& operator=(const GraphicsBindingVulkanKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingVulkanKHR(const XrGraphicsBindingVulkanKHR& rhs) : GraphicsBindingVulkanKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingVulkanKHR& operator=(const XrGraphicsBindingVulkanKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingVulkanKHR &() const { return *reinterpret_cast<const XrGraphicsBindingVulkanKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingVulkanKHR &() {
            return *reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingVulkanKHR
        XrGraphicsBindingVulkanKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingVulkanKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingVulkanKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingVulkanKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingVulkanKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
        }
        VkInstance instance;
        VkPhysicalDevice physicalDevice;
        VkDevice device;
        uint32_t queueFamilyIndex;
        uint32_t queueIndex;
    };
     static_assert(sizeof(XrGraphicsBindingVulkanKHR) == sizeof(GraphicsBindingVulkanKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingVulkanKHR pointer to const from a GraphicsBindingVulkanKHR reference to const.
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR const* get(GraphicsBindingVulkanKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingVulkanKHR as the address of a raw XrGraphicsBindingVulkanKHR
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR * put(GraphicsBindingVulkanKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable































    #ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageVulkanKHR
 * 
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageVulkanKHR>
 * @xrentity{XrSwapchainImageVulkanKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageVulkanKHR : public SwapchainImageBaseHeader
    {
    private:
        using Parent = SwapchainImageBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainImageVulkanKHR (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainImageVulkanKHR
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageVulkanKHR(const SwapchainImageVulkanKHR& rhs) = default;
        //! Default copy assignment
        SwapchainImageVulkanKHR& operator=(const SwapchainImageVulkanKHR& rhs) = default;
        //! Copy construct from raw
        SwapchainImageVulkanKHR(const XrSwapchainImageVulkanKHR& rhs) : SwapchainImageVulkanKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageVulkanKHR& operator=(const XrSwapchainImageVulkanKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageVulkanKHR &() const { return *reinterpret_cast<const XrSwapchainImageVulkanKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageVulkanKHR &() {
            return *reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
        XrSwapchainImageBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainImageVulkanKHR
        XrSwapchainImageVulkanKHR const* get() const noexcept { return reinterpret_cast<XrSwapchainImageVulkanKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageVulkanKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageVulkanKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageVulkanKHR{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
        }
        VkImage image;
    };
     static_assert(sizeof(XrSwapchainImageVulkanKHR) == sizeof(SwapchainImageVulkanKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageVulkanKHR pointer to const from a SwapchainImageVulkanKHR reference to const.
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR const* get(SwapchainImageVulkanKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageVulkanKHR as the address of a raw XrSwapchainImageVulkanKHR
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR * put(SwapchainImageVulkanKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainImageVulkanKHR as a raw, pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageVulkanKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(SwapchainImageVulkanKHR const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable































    #ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsRequirementsVulkanKHR
 * 
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsVulkanKHR>
 * @xrentity{XrGraphicsRequirementsVulkanKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsRequirementsVulkanKHR : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 GraphicsRequirementsVulkanKHR (
            void * next_ = nullptr)

: Parent(StructureType::GraphicsRequirementsVulkanKHR
             , next_)
            {}

        //! Default copy constructor
        GraphicsRequirementsVulkanKHR(const GraphicsRequirementsVulkanKHR& rhs) = default;
        //! Default copy assignment
        GraphicsRequirementsVulkanKHR& operator=(const GraphicsRequirementsVulkanKHR& rhs) = default;
        //! Copy construct from raw
        GraphicsRequirementsVulkanKHR(const XrGraphicsRequirementsVulkanKHR& rhs) : GraphicsRequirementsVulkanKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsRequirementsVulkanKHR& operator=(const XrGraphicsRequirementsVulkanKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsRequirementsVulkanKHR &() const { return *reinterpret_cast<const XrGraphicsRequirementsVulkanKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsRequirementsVulkanKHR &() {
            return *reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsRequirementsVulkanKHR
        XrGraphicsRequirementsVulkanKHR const* get() const noexcept { return reinterpret_cast<XrGraphicsRequirementsVulkanKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsRequirementsVulkanKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsRequirementsVulkanKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsRequirementsVulkanKHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
        }
        Version minApiVersionSupported;
        Version maxApiVersionSupported;
    };
     static_assert(sizeof(XrGraphicsRequirementsVulkanKHR) == sizeof(GraphicsRequirementsVulkanKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsVulkanKHR pointer to const from a GraphicsRequirementsVulkanKHR reference to const.
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR const* get(GraphicsRequirementsVulkanKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsVulkanKHR as the address of a raw XrGraphicsRequirementsVulkanKHR
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR * put(GraphicsRequirementsVulkanKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable































    #ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsBindingD3D11KHR
 * 
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D11KHR>
 * @xrentity{XrGraphicsBindingD3D11KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingD3D11KHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingD3D11KHR (
 ID3D11Device* device_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingD3D11KHR
, next_)
, device {device_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingD3D11KHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingD3D11KHR
             , next_)
, device{nullptr}
            {}

        //! Default copy constructor
        GraphicsBindingD3D11KHR(const GraphicsBindingD3D11KHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingD3D11KHR& operator=(const GraphicsBindingD3D11KHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingD3D11KHR(const XrGraphicsBindingD3D11KHR& rhs) : GraphicsBindingD3D11KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingD3D11KHR& operator=(const XrGraphicsBindingD3D11KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingD3D11KHR &() const { return *reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingD3D11KHR &() {
            return *reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingD3D11KHR
        XrGraphicsBindingD3D11KHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingD3D11KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingD3D11KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingD3D11KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingD3D11KHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
        }
        ID3D11Device* device;
    };
     static_assert(sizeof(XrGraphicsBindingD3D11KHR) == sizeof(GraphicsBindingD3D11KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D11KHR pointer to const from a GraphicsBindingD3D11KHR reference to const.
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR const* get(GraphicsBindingD3D11KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D11KHR as the address of a raw XrGraphicsBindingD3D11KHR
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR * put(GraphicsBindingD3D11KHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable































    #ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrSwapchainImageD3D11KHR
 * 
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D11KHR>
 * @xrentity{XrSwapchainImageD3D11KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageD3D11KHR : public SwapchainImageBaseHeader
    {
    private:
        using Parent = SwapchainImageBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainImageD3D11KHR (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainImageD3D11KHR
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageD3D11KHR(const SwapchainImageD3D11KHR& rhs) = default;
        //! Default copy assignment
        SwapchainImageD3D11KHR& operator=(const SwapchainImageD3D11KHR& rhs) = default;
        //! Copy construct from raw
        SwapchainImageD3D11KHR(const XrSwapchainImageD3D11KHR& rhs) : SwapchainImageD3D11KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageD3D11KHR& operator=(const XrSwapchainImageD3D11KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageD3D11KHR &() const { return *reinterpret_cast<const XrSwapchainImageD3D11KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageD3D11KHR &() {
            return *reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
        XrSwapchainImageBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainImageD3D11KHR
        XrSwapchainImageD3D11KHR const* get() const noexcept { return reinterpret_cast<XrSwapchainImageD3D11KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D11KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageD3D11KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageD3D11KHR{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
        }
        ID3D11Texture2D* texture;
    };
     static_assert(sizeof(XrSwapchainImageD3D11KHR) == sizeof(SwapchainImageD3D11KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D11KHR pointer to const from a SwapchainImageD3D11KHR reference to const.
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR const* get(SwapchainImageD3D11KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D11KHR as the address of a raw XrSwapchainImageD3D11KHR
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR * put(SwapchainImageD3D11KHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D11KHR as a raw, pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D11KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(SwapchainImageD3D11KHR const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable































    #ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsRequirementsD3D11KHR
 * 
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D11KHR>
 * @xrentity{XrGraphicsRequirementsD3D11KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsRequirementsD3D11KHR : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 GraphicsRequirementsD3D11KHR (
            void * next_ = nullptr)

: Parent(StructureType::GraphicsRequirementsD3D11KHR
             , next_)
            {}

        //! Default copy constructor
        GraphicsRequirementsD3D11KHR(const GraphicsRequirementsD3D11KHR& rhs) = default;
        //! Default copy assignment
        GraphicsRequirementsD3D11KHR& operator=(const GraphicsRequirementsD3D11KHR& rhs) = default;
        //! Copy construct from raw
        GraphicsRequirementsD3D11KHR(const XrGraphicsRequirementsD3D11KHR& rhs) : GraphicsRequirementsD3D11KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsRequirementsD3D11KHR& operator=(const XrGraphicsRequirementsD3D11KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsRequirementsD3D11KHR &() const { return *reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsRequirementsD3D11KHR &() {
            return *reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D11KHR
        XrGraphicsRequirementsD3D11KHR const* get() const noexcept { return reinterpret_cast<XrGraphicsRequirementsD3D11KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsRequirementsD3D11KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsRequirementsD3D11KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsRequirementsD3D11KHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
        }
        LUID adapterLuid;
        D3D_FEATURE_LEVEL minFeatureLevel;
    };
     static_assert(sizeof(XrGraphicsRequirementsD3D11KHR) == sizeof(GraphicsRequirementsD3D11KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D11KHR pointer to const from a GraphicsRequirementsD3D11KHR reference to const.
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR const* get(GraphicsRequirementsD3D11KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D11KHR as the address of a raw XrGraphicsRequirementsD3D11KHR
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR * put(GraphicsRequirementsD3D11KHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable































    #ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsBindingD3D12KHR
 * 
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D12KHR>
 * @xrentity{XrGraphicsBindingD3D12KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingD3D12KHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingD3D12KHR (
 ID3D12Device* device_,  ID3D12CommandQueue* queue_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingD3D12KHR
, next_)
, device {device_}
, queue {queue_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingD3D12KHR (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingD3D12KHR
             , next_)
, device{nullptr}
, queue{nullptr}
            {}

        //! Default copy constructor
        GraphicsBindingD3D12KHR(const GraphicsBindingD3D12KHR& rhs) = default;
        //! Default copy assignment
        GraphicsBindingD3D12KHR& operator=(const GraphicsBindingD3D12KHR& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingD3D12KHR(const XrGraphicsBindingD3D12KHR& rhs) : GraphicsBindingD3D12KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingD3D12KHR& operator=(const XrGraphicsBindingD3D12KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingD3D12KHR &() const { return *reinterpret_cast<const XrGraphicsBindingD3D12KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingD3D12KHR &() {
            return *reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingD3D12KHR
        XrGraphicsBindingD3D12KHR const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingD3D12KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingD3D12KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingD3D12KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingD3D12KHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
        }
        ID3D12Device* device;
        ID3D12CommandQueue* queue;
    };
     static_assert(sizeof(XrGraphicsBindingD3D12KHR) == sizeof(GraphicsBindingD3D12KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D12KHR pointer to const from a GraphicsBindingD3D12KHR reference to const.
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR const* get(GraphicsBindingD3D12KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D12KHR as the address of a raw XrGraphicsBindingD3D12KHR
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR * put(GraphicsBindingD3D12KHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable































    #ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrSwapchainImageD3D12KHR
 * 
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D12KHR>
 * @xrentity{XrSwapchainImageD3D12KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageD3D12KHR : public SwapchainImageBaseHeader
    {
    private:
        using Parent = SwapchainImageBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainImageD3D12KHR (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainImageD3D12KHR
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageD3D12KHR(const SwapchainImageD3D12KHR& rhs) = default;
        //! Default copy assignment
        SwapchainImageD3D12KHR& operator=(const SwapchainImageD3D12KHR& rhs) = default;
        //! Copy construct from raw
        SwapchainImageD3D12KHR(const XrSwapchainImageD3D12KHR& rhs) : SwapchainImageD3D12KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageD3D12KHR& operator=(const XrSwapchainImageD3D12KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageD3D12KHR &() const { return *reinterpret_cast<const XrSwapchainImageD3D12KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageD3D12KHR &() {
            return *reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
        XrSwapchainImageBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainImageD3D12KHR
        XrSwapchainImageD3D12KHR const* get() const noexcept { return reinterpret_cast<XrSwapchainImageD3D12KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D12KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageD3D12KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageD3D12KHR{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
        }
        ID3D12Resource* texture;
    };
     static_assert(sizeof(XrSwapchainImageD3D12KHR) == sizeof(SwapchainImageD3D12KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D12KHR pointer to const from a SwapchainImageD3D12KHR reference to const.
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR const* get(SwapchainImageD3D12KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D12KHR as the address of a raw XrSwapchainImageD3D12KHR
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR * put(SwapchainImageD3D12KHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D12KHR as a raw, pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D12KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(SwapchainImageD3D12KHR const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable































    #ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsRequirementsD3D12KHR
 * 
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D12KHR>
 * @xrentity{XrGraphicsRequirementsD3D12KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsRequirementsD3D12KHR : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 GraphicsRequirementsD3D12KHR (
            void * next_ = nullptr)

: Parent(StructureType::GraphicsRequirementsD3D12KHR
             , next_)
            {}

        //! Default copy constructor
        GraphicsRequirementsD3D12KHR(const GraphicsRequirementsD3D12KHR& rhs) = default;
        //! Default copy assignment
        GraphicsRequirementsD3D12KHR& operator=(const GraphicsRequirementsD3D12KHR& rhs) = default;
        //! Copy construct from raw
        GraphicsRequirementsD3D12KHR(const XrGraphicsRequirementsD3D12KHR& rhs) : GraphicsRequirementsD3D12KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsRequirementsD3D12KHR& operator=(const XrGraphicsRequirementsD3D12KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsRequirementsD3D12KHR &() const { return *reinterpret_cast<const XrGraphicsRequirementsD3D12KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsRequirementsD3D12KHR &() {
            return *reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D12KHR
        XrGraphicsRequirementsD3D12KHR const* get() const noexcept { return reinterpret_cast<XrGraphicsRequirementsD3D12KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsRequirementsD3D12KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsRequirementsD3D12KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsRequirementsD3D12KHR{};next = oldNext;}
            return reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
        }
        LUID adapterLuid;
        D3D_FEATURE_LEVEL minFeatureLevel;
    };
     static_assert(sizeof(XrGraphicsRequirementsD3D12KHR) == sizeof(GraphicsRequirementsD3D12KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D12KHR pointer to const from a GraphicsRequirementsD3D12KHR reference to const.
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR const* get(GraphicsRequirementsD3D12KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D12KHR as the address of a raw XrGraphicsRequirementsD3D12KHR
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR * put(GraphicsRequirementsD3D12KHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable































    #ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrVisibilityMaskKHR
 * 
 * Provided by the `XR_KHR_visibility_mask` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskKHR>
 * @xrentity{XrVisibilityMaskKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VisibilityMaskKHR : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 VisibilityMaskKHR (
            void * next_ = nullptr)

: Parent(StructureType::VisibilityMaskKHR
             , next_)
            {}

        //! Default copy constructor
        VisibilityMaskKHR(const VisibilityMaskKHR& rhs) = default;
        //! Default copy assignment
        VisibilityMaskKHR& operator=(const VisibilityMaskKHR& rhs) = default;
        //! Copy construct from raw
        VisibilityMaskKHR(const XrVisibilityMaskKHR& rhs) : VisibilityMaskKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VisibilityMaskKHR& operator=(const XrVisibilityMaskKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVisibilityMaskKHR &() const { return *reinterpret_cast<const XrVisibilityMaskKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVisibilityMaskKHR &() {
            return *reinterpret_cast<XrVisibilityMaskKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrVisibilityMaskKHR
        XrVisibilityMaskKHR const* get() const noexcept { return reinterpret_cast<XrVisibilityMaskKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVisibilityMaskKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVisibilityMaskKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VisibilityMaskKHR{};next = oldNext;}
            return reinterpret_cast<XrVisibilityMaskKHR*>(this);
        }
        uint32_t vertexCapacityInput;
        uint32_t vertexCountOutput;
        Vector2f* vertices;
        uint32_t indexCapacityInput;
        uint32_t indexCountOutput;
        uint32_t* indices;
    };
     static_assert(sizeof(XrVisibilityMaskKHR) == sizeof(VisibilityMaskKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVisibilityMaskKHR pointer to const from a VisibilityMaskKHR reference to const.
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVisibilityMaskKHR const* get(VisibilityMaskKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VisibilityMaskKHR as the address of a raw XrVisibilityMaskKHR
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVisibilityMaskKHR * put(VisibilityMaskKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_KHR_visibility_mask































    #ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrEventDataVisibilityMaskChangedKHR
 * 
 * Provided by the `XR_KHR_visibility_mask` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVisibilityMaskChangedKHR>
 * @xrentity{XrEventDataVisibilityMaskChangedKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataVisibilityMaskChangedKHR : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataVisibilityMaskChangedKHR (
            void * next_ = nullptr)

: Parent(StructureType::EventDataVisibilityMaskChangedKHR
             , next_)
            {}

        //! Default copy constructor
        EventDataVisibilityMaskChangedKHR(const EventDataVisibilityMaskChangedKHR& rhs) = default;
        //! Default copy assignment
        EventDataVisibilityMaskChangedKHR& operator=(const EventDataVisibilityMaskChangedKHR& rhs) = default;
        //! Copy construct from raw
        EventDataVisibilityMaskChangedKHR(const XrEventDataVisibilityMaskChangedKHR& rhs) : EventDataVisibilityMaskChangedKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataVisibilityMaskChangedKHR& operator=(const XrEventDataVisibilityMaskChangedKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataVisibilityMaskChangedKHR &() const { return *reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataVisibilityMaskChangedKHR &() {
            return *reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataVisibilityMaskChangedKHR
        XrEventDataVisibilityMaskChangedKHR const* get() const noexcept { return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataVisibilityMaskChangedKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataVisibilityMaskChangedKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataVisibilityMaskChangedKHR{};next = oldNext;}
            return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
        }
        Session session;
        ViewConfigurationType viewConfigurationType;
        uint32_t viewIndex;
    };
     static_assert(sizeof(XrEventDataVisibilityMaskChangedKHR) == sizeof(EventDataVisibilityMaskChangedKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataVisibilityMaskChangedKHR pointer to const from a EventDataVisibilityMaskChangedKHR reference to const.
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR const* get(EventDataVisibilityMaskChangedKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataVisibilityMaskChangedKHR as the address of a raw XrEventDataVisibilityMaskChangedKHR
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR * put(EventDataVisibilityMaskChangedKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataVisibilityMaskChangedKHR as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataVisibilityMaskChangedKHR
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataVisibilityMaskChangedKHR const& h) {
        return h.get_base();
    }
#endif  // XR_KHR_visibility_mask































    #ifdef XR_KHR_composition_layer_color_scale_bias
/*!
 * C++ projection of XrCompositionLayerColorScaleBiasKHR
 * 
 * Provided by the `XR_KHR_composition_layer_color_scale_bias` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerColorScaleBiasKHR>
 * @xrentity{XrCompositionLayerColorScaleBiasKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerColorScaleBiasKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerColorScaleBiasKHR (
 const Color4f& colorScale_,  const Color4f& colorBias_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerColorScaleBiasKHR
, next_)
, colorScale {colorScale_}
, colorBias {colorBias_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerColorScaleBiasKHR (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerColorScaleBiasKHR
             , next_)
, colorScale{}
, colorBias{}
            {}

        //! Default copy constructor
        CompositionLayerColorScaleBiasKHR(const CompositionLayerColorScaleBiasKHR& rhs) = default;
        //! Default copy assignment
        CompositionLayerColorScaleBiasKHR& operator=(const CompositionLayerColorScaleBiasKHR& rhs) = default;
        //! Copy construct from raw
        CompositionLayerColorScaleBiasKHR(const XrCompositionLayerColorScaleBiasKHR& rhs) : CompositionLayerColorScaleBiasKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerColorScaleBiasKHR& operator=(const XrCompositionLayerColorScaleBiasKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerColorScaleBiasKHR &() const { return *reinterpret_cast<const XrCompositionLayerColorScaleBiasKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerColorScaleBiasKHR &() {
            return *reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerColorScaleBiasKHR
        XrCompositionLayerColorScaleBiasKHR const* get() const noexcept { return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerColorScaleBiasKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerColorScaleBiasKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerColorScaleBiasKHR{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
        }
        Color4f colorScale;
        Color4f colorBias;
    };
     static_assert(sizeof(XrCompositionLayerColorScaleBiasKHR) == sizeof(CompositionLayerColorScaleBiasKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerColorScaleBiasKHR pointer to const from a CompositionLayerColorScaleBiasKHR reference to const.
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR const* get(CompositionLayerColorScaleBiasKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerColorScaleBiasKHR as the address of a raw XrCompositionLayerColorScaleBiasKHR
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR * put(CompositionLayerColorScaleBiasKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_KHR_composition_layer_color_scale_bias































    #ifdef XR_KHR_loader_init
/*!
 * C++ projection of XrLoaderInitInfoBaseHeaderKHR
 * 
 * Provided by the `XR_KHR_loader_init` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoBaseHeaderKHR>
 * @xrentity{XrLoaderInitInfoBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS LoaderInitInfoBaseHeaderKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                LoaderInitInfoBaseHeaderKHR (
  StructureType type_ ,  const void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrLoaderInitInfoBaseHeaderKHR &() const { return *reinterpret_cast<const XrLoaderInitInfoBaseHeaderKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrLoaderInitInfoBaseHeaderKHR &() {
            return *reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrLoaderInitInfoBaseHeaderKHR
        XrLoaderInitInfoBaseHeaderKHR const* get() const noexcept { return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const *>(this); }

    };
     static_assert(sizeof(XrLoaderInitInfoBaseHeaderKHR) == sizeof(LoaderInitInfoBaseHeaderKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoBaseHeaderKHR pointer to const from a LoaderInitInfoBaseHeaderKHR reference to const.
 * @relates LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get(LoaderInitInfoBaseHeaderKHR const& s) {
        return s.get();
    }

#endif  // XR_KHR_loader_init































    #ifdef XR_KHR_loader_init_android
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrLoaderInitInfoAndroidKHR
 * 
 * Provided by the `XR_KHR_loader_init_android` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoAndroidKHR>
 * @xrentity{XrLoaderInitInfoAndroidKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS LoaderInitInfoAndroidKHR : public LoaderInitInfoBaseHeaderKHR
    {
    private:
        using Parent = LoaderInitInfoBaseHeaderKHR;
    public:
        //! Constructor initializing all members.
                LoaderInitInfoAndroidKHR (
 void* XR_MAY_ALIAS applicationVM_,  void* XR_MAY_ALIAS applicationContext_,  const void * next_ = nullptr                  )
: Parent(StructureType::LoaderInitInfoAndroidKHR
, next_)
, applicationVM {applicationVM_}
, applicationContext {applicationContext_}
        {
        }


        //! Default/empty constructor
                 LoaderInitInfoAndroidKHR (
            const void * next_ = nullptr)

: Parent(StructureType::LoaderInitInfoAndroidKHR
             , next_)
, applicationVM{nullptr}
, applicationContext{nullptr}
            {}

        //! Default copy constructor
        LoaderInitInfoAndroidKHR(const LoaderInitInfoAndroidKHR& rhs) = default;
        //! Default copy assignment
        LoaderInitInfoAndroidKHR& operator=(const LoaderInitInfoAndroidKHR& rhs) = default;
        //! Copy construct from raw
        LoaderInitInfoAndroidKHR(const XrLoaderInitInfoAndroidKHR& rhs) : LoaderInitInfoAndroidKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        LoaderInitInfoAndroidKHR& operator=(const XrLoaderInitInfoAndroidKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrLoaderInitInfoAndroidKHR &() const { return *reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrLoaderInitInfoAndroidKHR &() {
            return *reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
        }

        //! Accessor for this as a raw, base XrLoaderInitInfoBaseHeaderKHR const pointer
        XrLoaderInitInfoBaseHeaderKHR const* get_base() const noexcept {
            return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
        }
        //! Accessor for this as the address of a raw XrLoaderInitInfoAndroidKHR
        XrLoaderInitInfoAndroidKHR const* get() const noexcept { return reinterpret_cast<XrLoaderInitInfoAndroidKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrLoaderInitInfoAndroidKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrLoaderInitInfoAndroidKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = LoaderInitInfoAndroidKHR{};next = oldNext;}
            return reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
        }
        void* XR_MAY_ALIAS applicationVM;
        void* XR_MAY_ALIAS applicationContext;
    };
     static_assert(sizeof(XrLoaderInitInfoAndroidKHR) == sizeof(LoaderInitInfoAndroidKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoAndroidKHR pointer to const from a LoaderInitInfoAndroidKHR reference to const.
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR const* get(LoaderInitInfoAndroidKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing LoaderInitInfoAndroidKHR as the address of a raw XrLoaderInitInfoAndroidKHR
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR * put(LoaderInitInfoAndroidKHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const LoaderInitInfoAndroidKHR as a raw, pointer to const XrLoaderInitInfoBaseHeaderKHR (the base type)
 * @relates LoaderInitInfoAndroidKHR
 * @relatesalso LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get_base(LoaderInitInfoAndroidKHR const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_loader_init_android































    #ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanInstanceCreateInfoKHR
 * 
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanInstanceCreateInfoKHR>
 * @xrentity{XrVulkanInstanceCreateInfoKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VulkanInstanceCreateInfoKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VulkanInstanceCreateInfoKHR (
 const SystemId& systemId_,  const VulkanInstanceCreateFlagsKHR& createFlags_,  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,  const VkInstanceCreateInfo* vulkanCreateInfo_,  const VkAllocationCallbacks* vulkanAllocator_,  const void * next_ = nullptr                  )
: Parent(StructureType::VulkanInstanceCreateInfoKHR
, next_)
, systemId {systemId_}
, createFlags {createFlags_}
, pfnGetInstanceProcAddr {pfnGetInstanceProcAddr_}
, vulkanCreateInfo {vulkanCreateInfo_}
, vulkanAllocator {vulkanAllocator_}
        {
        }


        //! Default/empty constructor
                 VulkanInstanceCreateInfoKHR (
            const void * next_ = nullptr)

: Parent(StructureType::VulkanInstanceCreateInfoKHR
             , next_)
, systemId{}
, createFlags{}
, pfnGetInstanceProcAddr{nullptr}
, vulkanCreateInfo{nullptr}
, vulkanAllocator{nullptr}
            {}

        //! Default copy constructor
        VulkanInstanceCreateInfoKHR(const VulkanInstanceCreateInfoKHR& rhs) = default;
        //! Default copy assignment
        VulkanInstanceCreateInfoKHR& operator=(const VulkanInstanceCreateInfoKHR& rhs) = default;
        //! Copy construct from raw
        VulkanInstanceCreateInfoKHR(const XrVulkanInstanceCreateInfoKHR& rhs) : VulkanInstanceCreateInfoKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VulkanInstanceCreateInfoKHR& operator=(const XrVulkanInstanceCreateInfoKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVulkanInstanceCreateInfoKHR &() const { return *reinterpret_cast<const XrVulkanInstanceCreateInfoKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVulkanInstanceCreateInfoKHR &() {
            return *reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrVulkanInstanceCreateInfoKHR
        XrVulkanInstanceCreateInfoKHR const* get() const noexcept { return reinterpret_cast<XrVulkanInstanceCreateInfoKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVulkanInstanceCreateInfoKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVulkanInstanceCreateInfoKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VulkanInstanceCreateInfoKHR{};next = oldNext;}
            return reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
        }
        SystemId systemId;
        VulkanInstanceCreateFlagsKHR createFlags;
        PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
        const VkInstanceCreateInfo* vulkanCreateInfo;
        const VkAllocationCallbacks* vulkanAllocator;
    };
     static_assert(sizeof(XrVulkanInstanceCreateInfoKHR) == sizeof(VulkanInstanceCreateInfoKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVulkanInstanceCreateInfoKHR pointer to const from a VulkanInstanceCreateInfoKHR reference to const.
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR const* get(VulkanInstanceCreateInfoKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanInstanceCreateInfoKHR as the address of a raw XrVulkanInstanceCreateInfoKHR
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR * put(VulkanInstanceCreateInfoKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2































    #ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanDeviceCreateInfoKHR
 * 
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanDeviceCreateInfoKHR>
 * @xrentity{XrVulkanDeviceCreateInfoKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VulkanDeviceCreateInfoKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VulkanDeviceCreateInfoKHR (
 const SystemId& systemId_,  const VulkanDeviceCreateFlagsKHR& createFlags_,  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,  VkPhysicalDevice vulkanPhysicalDevice_,  const VkDeviceCreateInfo* vulkanCreateInfo_,  const VkAllocationCallbacks* vulkanAllocator_,  const void * next_ = nullptr                  )
: Parent(StructureType::VulkanDeviceCreateInfoKHR
, next_)
, systemId {systemId_}
, createFlags {createFlags_}
, pfnGetInstanceProcAddr {pfnGetInstanceProcAddr_}
, vulkanPhysicalDevice {vulkanPhysicalDevice_}
, vulkanCreateInfo {vulkanCreateInfo_}
, vulkanAllocator {vulkanAllocator_}
        {
        }


        //! Default/empty constructor
                 VulkanDeviceCreateInfoKHR (
            const void * next_ = nullptr)

: Parent(StructureType::VulkanDeviceCreateInfoKHR
             , next_)
, systemId{}
, createFlags{}
, pfnGetInstanceProcAddr{nullptr}
, vulkanPhysicalDevice{}
, vulkanCreateInfo{nullptr}
, vulkanAllocator{nullptr}
            {}

        //! Default copy constructor
        VulkanDeviceCreateInfoKHR(const VulkanDeviceCreateInfoKHR& rhs) = default;
        //! Default copy assignment
        VulkanDeviceCreateInfoKHR& operator=(const VulkanDeviceCreateInfoKHR& rhs) = default;
        //! Copy construct from raw
        VulkanDeviceCreateInfoKHR(const XrVulkanDeviceCreateInfoKHR& rhs) : VulkanDeviceCreateInfoKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VulkanDeviceCreateInfoKHR& operator=(const XrVulkanDeviceCreateInfoKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVulkanDeviceCreateInfoKHR &() const { return *reinterpret_cast<const XrVulkanDeviceCreateInfoKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVulkanDeviceCreateInfoKHR &() {
            return *reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrVulkanDeviceCreateInfoKHR
        XrVulkanDeviceCreateInfoKHR const* get() const noexcept { return reinterpret_cast<XrVulkanDeviceCreateInfoKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVulkanDeviceCreateInfoKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVulkanDeviceCreateInfoKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VulkanDeviceCreateInfoKHR{};next = oldNext;}
            return reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
        }
        SystemId systemId;
        VulkanDeviceCreateFlagsKHR createFlags;
        PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
        VkPhysicalDevice vulkanPhysicalDevice;
        const VkDeviceCreateInfo* vulkanCreateInfo;
        const VkAllocationCallbacks* vulkanAllocator;
    };
     static_assert(sizeof(XrVulkanDeviceCreateInfoKHR) == sizeof(VulkanDeviceCreateInfoKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVulkanDeviceCreateInfoKHR pointer to const from a VulkanDeviceCreateInfoKHR reference to const.
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR const* get(VulkanDeviceCreateInfoKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanDeviceCreateInfoKHR as the address of a raw XrVulkanDeviceCreateInfoKHR
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR * put(VulkanDeviceCreateInfoKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2































    #ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanGraphicsDeviceGetInfoKHR
 * 
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanGraphicsDeviceGetInfoKHR>
 * @xrentity{XrVulkanGraphicsDeviceGetInfoKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VulkanGraphicsDeviceGetInfoKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VulkanGraphicsDeviceGetInfoKHR (
 const SystemId& systemId_,  VkInstance vulkanInstance_,  const void * next_ = nullptr                  )
: Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR
, next_)
, systemId {systemId_}
, vulkanInstance {vulkanInstance_}
        {
        }


        //! Default/empty constructor
                 VulkanGraphicsDeviceGetInfoKHR (
            const void * next_ = nullptr)

: Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR
             , next_)
, systemId{}
, vulkanInstance{}
            {}

        //! Default copy constructor
        VulkanGraphicsDeviceGetInfoKHR(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
        //! Default copy assignment
        VulkanGraphicsDeviceGetInfoKHR& operator=(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
        //! Copy construct from raw
        VulkanGraphicsDeviceGetInfoKHR(const XrVulkanGraphicsDeviceGetInfoKHR& rhs) : VulkanGraphicsDeviceGetInfoKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VulkanGraphicsDeviceGetInfoKHR& operator=(const XrVulkanGraphicsDeviceGetInfoKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVulkanGraphicsDeviceGetInfoKHR &() const { return *reinterpret_cast<const XrVulkanGraphicsDeviceGetInfoKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVulkanGraphicsDeviceGetInfoKHR &() {
            return *reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
        XrVulkanGraphicsDeviceGetInfoKHR const* get() const noexcept { return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVulkanGraphicsDeviceGetInfoKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VulkanGraphicsDeviceGetInfoKHR{};next = oldNext;}
            return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
        }
        SystemId systemId;
        VkInstance vulkanInstance;
    };
     static_assert(sizeof(XrVulkanGraphicsDeviceGetInfoKHR) == sizeof(VulkanGraphicsDeviceGetInfoKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVulkanGraphicsDeviceGetInfoKHR pointer to const from a VulkanGraphicsDeviceGetInfoKHR reference to const.
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR const* get(VulkanGraphicsDeviceGetInfoKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanGraphicsDeviceGetInfoKHR as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR * put(VulkanGraphicsDeviceGetInfoKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2































    #ifdef XR_KHR_composition_layer_equirect2
/*!
 * C++ projection of XrCompositionLayerEquirect2KHR
 * 
 * Provided by the `XR_KHR_composition_layer_equirect2` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirect2KHR>
 * @xrentity{XrCompositionLayerEquirect2KHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerEquirect2KHR : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerEquirect2KHR (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  const EyeVisibility& eyeVisibility_,  const SwapchainSubImage& subImage_,  const Posef& pose_,  float radius_,  float centralHorizontalAngle_,  float upperVerticalAngle_,  float lowerVerticalAngle_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerEquirect2KHR
, layerFlags_, space_, next_)
, eyeVisibility {eyeVisibility_}
, subImage {subImage_}
, pose {pose_}
, radius {radius_}
, centralHorizontalAngle {centralHorizontalAngle_}
, upperVerticalAngle {upperVerticalAngle_}
, lowerVerticalAngle {lowerVerticalAngle_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerEquirect2KHR (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerEquirect2KHR
, {}, {}             , next_)
, eyeVisibility{}
, subImage{}
, pose{}
, radius{0.0f}
, centralHorizontalAngle{0.0f}
, upperVerticalAngle{0.0f}
, lowerVerticalAngle{0.0f}
            {}

        //! Default copy constructor
        CompositionLayerEquirect2KHR(const CompositionLayerEquirect2KHR& rhs) = default;
        //! Default copy assignment
        CompositionLayerEquirect2KHR& operator=(const CompositionLayerEquirect2KHR& rhs) = default;
        //! Copy construct from raw
        CompositionLayerEquirect2KHR(const XrCompositionLayerEquirect2KHR& rhs) : CompositionLayerEquirect2KHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerEquirect2KHR& operator=(const XrCompositionLayerEquirect2KHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerEquirect2KHR &() const { return *reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerEquirect2KHR &() {
            return *reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerEquirect2KHR
        XrCompositionLayerEquirect2KHR const* get() const noexcept { return reinterpret_cast<XrCompositionLayerEquirect2KHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerEquirect2KHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerEquirect2KHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerEquirect2KHR{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
        }
        EyeVisibility eyeVisibility;
        SwapchainSubImage subImage;
        Posef pose;
        float radius;
        float centralHorizontalAngle;
        float upperVerticalAngle;
        float lowerVerticalAngle;
    };
     static_assert(sizeof(XrCompositionLayerEquirect2KHR) == sizeof(CompositionLayerEquirect2KHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirect2KHR pointer to const from a CompositionLayerEquirect2KHR reference to const.
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR const* get(CompositionLayerEquirect2KHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirect2KHR as the address of a raw XrCompositionLayerEquirect2KHR
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR * put(CompositionLayerEquirect2KHR &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirect2KHR as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirect2KHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerEquirect2KHR const& h) {
        return h.get_base();
    }
#endif  // XR_KHR_composition_layer_equirect2































    #ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationBaseHeaderKHR
 * 
 * Provided by the `XR_KHR_binding_modification` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationBaseHeaderKHR>
 * @xrentity{XrBindingModificationBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS BindingModificationBaseHeaderKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                BindingModificationBaseHeaderKHR (
  StructureType type_ ,  const void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBindingModificationBaseHeaderKHR &() const { return *reinterpret_cast<const XrBindingModificationBaseHeaderKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBindingModificationBaseHeaderKHR &() {
            return *reinterpret_cast<XrBindingModificationBaseHeaderKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrBindingModificationBaseHeaderKHR
        XrBindingModificationBaseHeaderKHR const* get() const noexcept { return reinterpret_cast<XrBindingModificationBaseHeaderKHR const *>(this); }

    };
     static_assert(sizeof(XrBindingModificationBaseHeaderKHR) == sizeof(BindingModificationBaseHeaderKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBindingModificationBaseHeaderKHR pointer to const from a BindingModificationBaseHeaderKHR reference to const.
 * @relates BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get(BindingModificationBaseHeaderKHR const& s) {
        return s.get();
    }

#endif  // XR_KHR_binding_modification































    #ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationsKHR
 * 
 * Provided by the `XR_KHR_binding_modification` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationsKHR>
 * @xrentity{XrBindingModificationsKHR}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS BindingModificationsKHR : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                BindingModificationsKHR (
 uint32_t bindingModificationCount_,  const BindingModificationBaseHeaderKHR* const* bindingModifications_,  const void * next_ = nullptr                  )
: Parent(StructureType::BindingModificationsKHR
, next_)
, bindingModificationCount {bindingModificationCount_}
, bindingModifications {bindingModifications_}
        {
        }


        //! Default/empty constructor
                 BindingModificationsKHR (
            const void * next_ = nullptr)

: Parent(StructureType::BindingModificationsKHR
             , next_)
, bindingModificationCount{0}
, bindingModifications{nullptr}
            {}

        //! Default copy constructor
        BindingModificationsKHR(const BindingModificationsKHR& rhs) = default;
        //! Default copy assignment
        BindingModificationsKHR& operator=(const BindingModificationsKHR& rhs) = default;
        //! Copy construct from raw
        BindingModificationsKHR(const XrBindingModificationsKHR& rhs) : BindingModificationsKHR() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BindingModificationsKHR& operator=(const XrBindingModificationsKHR& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBindingModificationsKHR &() const { return *reinterpret_cast<const XrBindingModificationsKHR*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBindingModificationsKHR &() {
            return *reinterpret_cast<XrBindingModificationsKHR*>(this);
        }

        //! Accessor for this as the address of a raw XrBindingModificationsKHR
        XrBindingModificationsKHR const* get() const noexcept { return reinterpret_cast<XrBindingModificationsKHR const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBindingModificationsKHR.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBindingModificationsKHR * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = BindingModificationsKHR{};next = oldNext;}
            return reinterpret_cast<XrBindingModificationsKHR*>(this);
        }
        uint32_t bindingModificationCount;
        const BindingModificationBaseHeaderKHR* const* bindingModifications;
    };
     static_assert(sizeof(XrBindingModificationsKHR) == sizeof(BindingModificationsKHR), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBindingModificationsKHR pointer to const from a BindingModificationsKHR reference to const.
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBindingModificationsKHR const* get(BindingModificationsKHR const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BindingModificationsKHR as the address of a raw XrBindingModificationsKHR
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBindingModificationsKHR * put(BindingModificationsKHR &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_KHR_binding_modification































    #ifdef XR_EXT_performance_settings
/*!
 * C++ projection of XrEventDataPerfSettingsEXT
 * 
 * Provided by the `XR_EXT_performance_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPerfSettingsEXT>
 * @xrentity{XrEventDataPerfSettingsEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataPerfSettingsEXT : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataPerfSettingsEXT (
            void * next_ = nullptr)

: Parent(StructureType::EventDataPerfSettingsEXT
             , next_)
            {}

        //! Default copy constructor
        EventDataPerfSettingsEXT(const EventDataPerfSettingsEXT& rhs) = default;
        //! Default copy assignment
        EventDataPerfSettingsEXT& operator=(const EventDataPerfSettingsEXT& rhs) = default;
        //! Copy construct from raw
        EventDataPerfSettingsEXT(const XrEventDataPerfSettingsEXT& rhs) : EventDataPerfSettingsEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataPerfSettingsEXT& operator=(const XrEventDataPerfSettingsEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataPerfSettingsEXT &() const { return *reinterpret_cast<const XrEventDataPerfSettingsEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataPerfSettingsEXT &() {
            return *reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataPerfSettingsEXT
        XrEventDataPerfSettingsEXT const* get() const noexcept { return reinterpret_cast<XrEventDataPerfSettingsEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataPerfSettingsEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataPerfSettingsEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataPerfSettingsEXT{};next = oldNext;}
            return reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
        }
        PerfSettingsDomainEXT domain;
        PerfSettingsSubDomainEXT subDomain;
        PerfSettingsNotificationLevelEXT fromLevel;
        PerfSettingsNotificationLevelEXT toLevel;
    };
     static_assert(sizeof(XrEventDataPerfSettingsEXT) == sizeof(EventDataPerfSettingsEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataPerfSettingsEXT pointer to const from a EventDataPerfSettingsEXT reference to const.
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT const* get(EventDataPerfSettingsEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataPerfSettingsEXT as the address of a raw XrEventDataPerfSettingsEXT
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT * put(EventDataPerfSettingsEXT &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataPerfSettingsEXT as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataPerfSettingsEXT
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataPerfSettingsEXT const& h) {
        return h.get_base();
    }
#endif  // XR_EXT_performance_settings































    #ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsObjectNameInfoEXT
 * 
 * Provided by the `XR_EXT_debug_utils` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsObjectNameInfoEXT>
 * @xrentity{XrDebugUtilsObjectNameInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS DebugUtilsObjectNameInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                DebugUtilsObjectNameInfoEXT (
 const ObjectType& objectType_,  uint64_t objectHandle_,  const char* objectName_,  const void * next_ = nullptr                  )
: Parent(StructureType::DebugUtilsObjectNameInfoEXT
, next_)
, objectType {objectType_}
, objectHandle {objectHandle_}
, objectName {objectName_}
        {
        }


        //! Default/empty constructor
                 DebugUtilsObjectNameInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::DebugUtilsObjectNameInfoEXT
             , next_)
, objectType{}
, objectHandle{0}
, objectName{nullptr}
            {}

        //! Default copy constructor
        DebugUtilsObjectNameInfoEXT(const DebugUtilsObjectNameInfoEXT& rhs) = default;
        //! Default copy assignment
        DebugUtilsObjectNameInfoEXT& operator=(const DebugUtilsObjectNameInfoEXT& rhs) = default;
        //! Copy construct from raw
        DebugUtilsObjectNameInfoEXT(const XrDebugUtilsObjectNameInfoEXT& rhs) : DebugUtilsObjectNameInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        DebugUtilsObjectNameInfoEXT& operator=(const XrDebugUtilsObjectNameInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrDebugUtilsObjectNameInfoEXT &() const { return *reinterpret_cast<const XrDebugUtilsObjectNameInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrDebugUtilsObjectNameInfoEXT &() {
            return *reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrDebugUtilsObjectNameInfoEXT
        XrDebugUtilsObjectNameInfoEXT const* get() const noexcept { return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsObjectNameInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrDebugUtilsObjectNameInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = DebugUtilsObjectNameInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
        }
        ObjectType objectType;
        uint64_t objectHandle;
        const char* objectName;
    };
     static_assert(sizeof(XrDebugUtilsObjectNameInfoEXT) == sizeof(DebugUtilsObjectNameInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrDebugUtilsObjectNameInfoEXT pointer to const from a DebugUtilsObjectNameInfoEXT reference to const.
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT const* get(DebugUtilsObjectNameInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsObjectNameInfoEXT as the address of a raw XrDebugUtilsObjectNameInfoEXT
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT * put(DebugUtilsObjectNameInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_debug_utils































    #ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsLabelEXT
 * 
 * Provided by the `XR_EXT_debug_utils` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsLabelEXT>
 * @xrentity{XrDebugUtilsLabelEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS DebugUtilsLabelEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                DebugUtilsLabelEXT (
 const char* labelName_,  const void * next_ = nullptr                  )
: Parent(StructureType::DebugUtilsLabelEXT
, next_)
, labelName {labelName_}
        {
        }


        //! Default/empty constructor
                 DebugUtilsLabelEXT (
            const void * next_ = nullptr)

: Parent(StructureType::DebugUtilsLabelEXT
             , next_)
, labelName{nullptr}
            {}

        //! Default copy constructor
        DebugUtilsLabelEXT(const DebugUtilsLabelEXT& rhs) = default;
        //! Default copy assignment
        DebugUtilsLabelEXT& operator=(const DebugUtilsLabelEXT& rhs) = default;
        //! Copy construct from raw
        DebugUtilsLabelEXT(const XrDebugUtilsLabelEXT& rhs) : DebugUtilsLabelEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        DebugUtilsLabelEXT& operator=(const XrDebugUtilsLabelEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrDebugUtilsLabelEXT &() const { return *reinterpret_cast<const XrDebugUtilsLabelEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrDebugUtilsLabelEXT &() {
            return *reinterpret_cast<XrDebugUtilsLabelEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrDebugUtilsLabelEXT
        XrDebugUtilsLabelEXT const* get() const noexcept { return reinterpret_cast<XrDebugUtilsLabelEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsLabelEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrDebugUtilsLabelEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = DebugUtilsLabelEXT{};next = oldNext;}
            return reinterpret_cast<XrDebugUtilsLabelEXT*>(this);
        }
        const char* labelName;
    };
     static_assert(sizeof(XrDebugUtilsLabelEXT) == sizeof(DebugUtilsLabelEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrDebugUtilsLabelEXT pointer to const from a DebugUtilsLabelEXT reference to const.
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT const* get(DebugUtilsLabelEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsLabelEXT as the address of a raw XrDebugUtilsLabelEXT
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT * put(DebugUtilsLabelEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_debug_utils































    #ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCallbackDataEXT
 * 
 * Provided by the `XR_EXT_debug_utils` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCallbackDataEXT>
 * @xrentity{XrDebugUtilsMessengerCallbackDataEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS DebugUtilsMessengerCallbackDataEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                DebugUtilsMessengerCallbackDataEXT (
 const char* messageId_,  const char* functionName_,  const char* message_,  uint32_t objectCount_,  DebugUtilsObjectNameInfoEXT* objects_,  uint32_t sessionLabelCount_,  DebugUtilsLabelEXT* sessionLabels_,  const void * next_ = nullptr                  )
: Parent(StructureType::DebugUtilsMessengerCallbackDataEXT
, next_)
, messageId {messageId_}
, functionName {functionName_}
, message {message_}
, objectCount {objectCount_}
, objects {objects_}
, sessionLabelCount {sessionLabelCount_}
, sessionLabels {sessionLabels_}
        {
        }


        //! Default/empty constructor
                 DebugUtilsMessengerCallbackDataEXT (
            const void * next_ = nullptr)

: Parent(StructureType::DebugUtilsMessengerCallbackDataEXT
             , next_)
, messageId{nullptr}
, functionName{nullptr}
, message{nullptr}
, objectCount{0}
, objects{nullptr}
, sessionLabelCount{0}
, sessionLabels{nullptr}
            {}

        //! Default copy constructor
        DebugUtilsMessengerCallbackDataEXT(const DebugUtilsMessengerCallbackDataEXT& rhs) = default;
        //! Default copy assignment
        DebugUtilsMessengerCallbackDataEXT& operator=(const DebugUtilsMessengerCallbackDataEXT& rhs) = default;
        //! Copy construct from raw
        DebugUtilsMessengerCallbackDataEXT(const XrDebugUtilsMessengerCallbackDataEXT& rhs) : DebugUtilsMessengerCallbackDataEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        DebugUtilsMessengerCallbackDataEXT& operator=(const XrDebugUtilsMessengerCallbackDataEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrDebugUtilsMessengerCallbackDataEXT &() const { return *reinterpret_cast<const XrDebugUtilsMessengerCallbackDataEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrDebugUtilsMessengerCallbackDataEXT &() {
            return *reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
        XrDebugUtilsMessengerCallbackDataEXT const* get() const noexcept { return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsMessengerCallbackDataEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrDebugUtilsMessengerCallbackDataEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = DebugUtilsMessengerCallbackDataEXT{};next = oldNext;}
            return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
        }
        const char* messageId;
        const char* functionName;
        const char* message;
        uint32_t objectCount;
        DebugUtilsObjectNameInfoEXT* objects;
        uint32_t sessionLabelCount;
        DebugUtilsLabelEXT* sessionLabels;
    };
     static_assert(sizeof(XrDebugUtilsMessengerCallbackDataEXT) == sizeof(DebugUtilsMessengerCallbackDataEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCallbackDataEXT pointer to const from a DebugUtilsMessengerCallbackDataEXT reference to const.
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT const* get(DebugUtilsMessengerCallbackDataEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsMessengerCallbackDataEXT as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT * put(DebugUtilsMessengerCallbackDataEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_debug_utils































    #ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCreateInfoEXT
 * 
 * Provided by the `XR_EXT_debug_utils` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCreateInfoEXT>
 * @xrentity{XrDebugUtilsMessengerCreateInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS DebugUtilsMessengerCreateInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                DebugUtilsMessengerCreateInfoEXT (
 const DebugUtilsMessageSeverityFlagsEXT& messageSeverities_,  const DebugUtilsMessageTypeFlagsEXT& messageTypes_,  PFN_xrDebugUtilsMessengerCallbackEXT userCallback_,  void* XR_MAY_ALIAS userData_,  const void * next_ = nullptr                  )
: Parent(StructureType::DebugUtilsMessengerCreateInfoEXT
, next_)
, messageSeverities {messageSeverities_}
, messageTypes {messageTypes_}
, userCallback {userCallback_}
, userData {userData_}
        {
        }


        //! Default/empty constructor
                 DebugUtilsMessengerCreateInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::DebugUtilsMessengerCreateInfoEXT
             , next_)
, messageSeverities{}
, messageTypes{}
, userCallback{nullptr}
, userData{nullptr}
            {}

        //! Default copy constructor
        DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessengerCreateInfoEXT& rhs) = default;
        //! Default copy assignment
        DebugUtilsMessengerCreateInfoEXT& operator=(const DebugUtilsMessengerCreateInfoEXT& rhs) = default;
        //! Copy construct from raw
        DebugUtilsMessengerCreateInfoEXT(const XrDebugUtilsMessengerCreateInfoEXT& rhs) : DebugUtilsMessengerCreateInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        DebugUtilsMessengerCreateInfoEXT& operator=(const XrDebugUtilsMessengerCreateInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrDebugUtilsMessengerCreateInfoEXT &() const { return *reinterpret_cast<const XrDebugUtilsMessengerCreateInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrDebugUtilsMessengerCreateInfoEXT &() {
            return *reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
        XrDebugUtilsMessengerCreateInfoEXT const* get() const noexcept { return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsMessengerCreateInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrDebugUtilsMessengerCreateInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = DebugUtilsMessengerCreateInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
        }
        DebugUtilsMessageSeverityFlagsEXT messageSeverities;
        DebugUtilsMessageTypeFlagsEXT messageTypes;
        PFN_xrDebugUtilsMessengerCallbackEXT userCallback;
        void* XR_MAY_ALIAS userData;
    };
     static_assert(sizeof(XrDebugUtilsMessengerCreateInfoEXT) == sizeof(DebugUtilsMessengerCreateInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCreateInfoEXT pointer to const from a DebugUtilsMessengerCreateInfoEXT reference to const.
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT const* get(DebugUtilsMessengerCreateInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsMessengerCreateInfoEXT as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT * put(DebugUtilsMessengerCreateInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_debug_utils































    #ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrSystemEyeGazeInteractionPropertiesEXT
 * 
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEyeGazeInteractionPropertiesEXT>
 * @xrentity{XrSystemEyeGazeInteractionPropertiesEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemEyeGazeInteractionPropertiesEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemEyeGazeInteractionPropertiesEXT (
            void * next_ = nullptr)

: Parent(StructureType::SystemEyeGazeInteractionPropertiesEXT
             , next_)
            {}

        //! Default copy constructor
        SystemEyeGazeInteractionPropertiesEXT(const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
        //! Default copy assignment
        SystemEyeGazeInteractionPropertiesEXT& operator=(const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
        //! Copy construct from raw
        SystemEyeGazeInteractionPropertiesEXT(const XrSystemEyeGazeInteractionPropertiesEXT& rhs) : SystemEyeGazeInteractionPropertiesEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemEyeGazeInteractionPropertiesEXT& operator=(const XrSystemEyeGazeInteractionPropertiesEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemEyeGazeInteractionPropertiesEXT &() const { return *reinterpret_cast<const XrSystemEyeGazeInteractionPropertiesEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemEyeGazeInteractionPropertiesEXT &() {
            return *reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemEyeGazeInteractionPropertiesEXT
        XrSystemEyeGazeInteractionPropertiesEXT const* get() const noexcept { return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemEyeGazeInteractionPropertiesEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemEyeGazeInteractionPropertiesEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemEyeGazeInteractionPropertiesEXT{};next = oldNext;}
            return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
        }
        Bool32 supportsEyeGazeInteraction;
    };
     static_assert(sizeof(XrSystemEyeGazeInteractionPropertiesEXT) == sizeof(SystemEyeGazeInteractionPropertiesEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemEyeGazeInteractionPropertiesEXT pointer to const from a SystemEyeGazeInteractionPropertiesEXT reference to const.
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT const* get(SystemEyeGazeInteractionPropertiesEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemEyeGazeInteractionPropertiesEXT as the address of a raw XrSystemEyeGazeInteractionPropertiesEXT
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT * put(SystemEyeGazeInteractionPropertiesEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_eye_gaze_interaction































    #ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrEyeGazeSampleTimeEXT
 * 
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazeSampleTimeEXT>
 * @xrentity{XrEyeGazeSampleTimeEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EyeGazeSampleTimeEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EyeGazeSampleTimeEXT (
            void * next_ = nullptr)

: Parent(StructureType::EyeGazeSampleTimeEXT
             , next_)
            {}

        //! Default copy constructor
        EyeGazeSampleTimeEXT(const EyeGazeSampleTimeEXT& rhs) = default;
        //! Default copy assignment
        EyeGazeSampleTimeEXT& operator=(const EyeGazeSampleTimeEXT& rhs) = default;
        //! Copy construct from raw
        EyeGazeSampleTimeEXT(const XrEyeGazeSampleTimeEXT& rhs) : EyeGazeSampleTimeEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EyeGazeSampleTimeEXT& operator=(const XrEyeGazeSampleTimeEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEyeGazeSampleTimeEXT &() const { return *reinterpret_cast<const XrEyeGazeSampleTimeEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEyeGazeSampleTimeEXT &() {
            return *reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrEyeGazeSampleTimeEXT
        XrEyeGazeSampleTimeEXT const* get() const noexcept { return reinterpret_cast<XrEyeGazeSampleTimeEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazeSampleTimeEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEyeGazeSampleTimeEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EyeGazeSampleTimeEXT{};next = oldNext;}
            return reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this);
        }
        Time time;
    };
     static_assert(sizeof(XrEyeGazeSampleTimeEXT) == sizeof(EyeGazeSampleTimeEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEyeGazeSampleTimeEXT pointer to const from a EyeGazeSampleTimeEXT reference to const.
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT const* get(EyeGazeSampleTimeEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazeSampleTimeEXT as the address of a raw XrEyeGazeSampleTimeEXT
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT * put(EyeGazeSampleTimeEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_eye_gaze_interaction































    #ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrSessionCreateInfoOverlayEXTX
 * 
 * Provided by the `XR_EXTX_overlay` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfoOverlayEXTX>
 * @xrentity{XrSessionCreateInfoOverlayEXTX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SessionCreateInfoOverlayEXTX : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SessionCreateInfoOverlayEXTX (
 const OverlaySessionCreateFlagsEXTX& createFlags_,  uint32_t sessionLayersPlacement_,  const void * next_ = nullptr                  )
: Parent(StructureType::SessionCreateInfoOverlayEXTX
, next_)
, createFlags {createFlags_}
, sessionLayersPlacement {sessionLayersPlacement_}
        {
        }


        //! Default/empty constructor
                 SessionCreateInfoOverlayEXTX (
            const void * next_ = nullptr)

: Parent(StructureType::SessionCreateInfoOverlayEXTX
             , next_)
, createFlags{}
, sessionLayersPlacement{0}
            {}

        //! Default copy constructor
        SessionCreateInfoOverlayEXTX(const SessionCreateInfoOverlayEXTX& rhs) = default;
        //! Default copy assignment
        SessionCreateInfoOverlayEXTX& operator=(const SessionCreateInfoOverlayEXTX& rhs) = default;
        //! Copy construct from raw
        SessionCreateInfoOverlayEXTX(const XrSessionCreateInfoOverlayEXTX& rhs) : SessionCreateInfoOverlayEXTX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SessionCreateInfoOverlayEXTX& operator=(const XrSessionCreateInfoOverlayEXTX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSessionCreateInfoOverlayEXTX &() const { return *reinterpret_cast<const XrSessionCreateInfoOverlayEXTX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSessionCreateInfoOverlayEXTX &() {
            return *reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
        }

        //! Accessor for this as the address of a raw XrSessionCreateInfoOverlayEXTX
        XrSessionCreateInfoOverlayEXTX const* get() const noexcept { return reinterpret_cast<XrSessionCreateInfoOverlayEXTX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSessionCreateInfoOverlayEXTX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSessionCreateInfoOverlayEXTX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SessionCreateInfoOverlayEXTX{};next = oldNext;}
            return reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
        }
        OverlaySessionCreateFlagsEXTX createFlags;
        uint32_t sessionLayersPlacement;
    };
     static_assert(sizeof(XrSessionCreateInfoOverlayEXTX) == sizeof(SessionCreateInfoOverlayEXTX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSessionCreateInfoOverlayEXTX pointer to const from a SessionCreateInfoOverlayEXTX reference to const.
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX const* get(SessionCreateInfoOverlayEXTX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfoOverlayEXTX as the address of a raw XrSessionCreateInfoOverlayEXTX
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX * put(SessionCreateInfoOverlayEXTX &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXTX_overlay































    #ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrEventDataMainSessionVisibilityChangedEXTX
 * 
 * Provided by the `XR_EXTX_overlay` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMainSessionVisibilityChangedEXTX>
 * @xrentity{XrEventDataMainSessionVisibilityChangedEXTX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataMainSessionVisibilityChangedEXTX : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataMainSessionVisibilityChangedEXTX (
            void * next_ = nullptr)

: Parent(StructureType::EventDataMainSessionVisibilityChangedEXTX
             , next_)
            {}

        //! Default copy constructor
        EventDataMainSessionVisibilityChangedEXTX(const EventDataMainSessionVisibilityChangedEXTX& rhs) = default;
        //! Default copy assignment
        EventDataMainSessionVisibilityChangedEXTX& operator=(const EventDataMainSessionVisibilityChangedEXTX& rhs) = default;
        //! Copy construct from raw
        EventDataMainSessionVisibilityChangedEXTX(const XrEventDataMainSessionVisibilityChangedEXTX& rhs) : EventDataMainSessionVisibilityChangedEXTX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataMainSessionVisibilityChangedEXTX& operator=(const XrEventDataMainSessionVisibilityChangedEXTX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataMainSessionVisibilityChangedEXTX &() const { return *reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataMainSessionVisibilityChangedEXTX &() {
            return *reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataMainSessionVisibilityChangedEXTX
        XrEventDataMainSessionVisibilityChangedEXTX const* get() const noexcept { return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataMainSessionVisibilityChangedEXTX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataMainSessionVisibilityChangedEXTX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataMainSessionVisibilityChangedEXTX{};next = oldNext;}
            return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
        }
        Bool32 visible;
        OverlayMainSessionFlagsEXTX flags;
    };
     static_assert(sizeof(XrEventDataMainSessionVisibilityChangedEXTX) == sizeof(EventDataMainSessionVisibilityChangedEXTX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataMainSessionVisibilityChangedEXTX pointer to const from a EventDataMainSessionVisibilityChangedEXTX reference to const.
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX const* get(EventDataMainSessionVisibilityChangedEXTX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataMainSessionVisibilityChangedEXTX as the address of a raw XrEventDataMainSessionVisibilityChangedEXTX
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX * put(EventDataMainSessionVisibilityChangedEXTX &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataMainSessionVisibilityChangedEXTX as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataMainSessionVisibilityChangedEXTX const& h) {
        return h.get_base();
    }
#endif  // XR_EXTX_overlay































    #ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoMSFT
 * 
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorCreateInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpatialAnchorCreateInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpatialAnchorCreateInfoMSFT (
 const Space& space_,  const Posef& pose_,  const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpatialAnchorCreateInfoMSFT
, next_)
, space {space_}
, pose {pose_}
, time {time_}
        {
        }


        //! Default/empty constructor
                 SpatialAnchorCreateInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SpatialAnchorCreateInfoMSFT
             , next_)
, space{}
, pose{}
, time{}
            {}

        //! Default copy constructor
        SpatialAnchorCreateInfoMSFT(const SpatialAnchorCreateInfoMSFT& rhs) = default;
        //! Default copy assignment
        SpatialAnchorCreateInfoMSFT& operator=(const SpatialAnchorCreateInfoMSFT& rhs) = default;
        //! Copy construct from raw
        SpatialAnchorCreateInfoMSFT(const XrSpatialAnchorCreateInfoMSFT& rhs) : SpatialAnchorCreateInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpatialAnchorCreateInfoMSFT& operator=(const XrSpatialAnchorCreateInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpatialAnchorCreateInfoMSFT &() const { return *reinterpret_cast<const XrSpatialAnchorCreateInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpatialAnchorCreateInfoMSFT &() {
            return *reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoMSFT
        XrSpatialAnchorCreateInfoMSFT const* get() const noexcept { return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpatialAnchorCreateInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpatialAnchorCreateInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpatialAnchorCreateInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
        }
        Space space;
        Posef pose;
        Time time;
    };
     static_assert(sizeof(XrSpatialAnchorCreateInfoMSFT) == sizeof(SpatialAnchorCreateInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoMSFT pointer to const from a SpatialAnchorCreateInfoMSFT reference to const.
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT const* get(SpatialAnchorCreateInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoMSFT as the address of a raw XrSpatialAnchorCreateInfoMSFT
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT * put(SpatialAnchorCreateInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_spatial_anchor































    #ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorSpaceCreateInfoMSFT
 * 
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorSpaceCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpatialAnchorSpaceCreateInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpatialAnchorSpaceCreateInfoMSFT (
 const SpatialAnchorMSFT& anchor_,  const Posef& poseInAnchorSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT
, next_)
, anchor {anchor_}
, poseInAnchorSpace {poseInAnchorSpace_}
        {
        }


        //! Default/empty constructor
                 SpatialAnchorSpaceCreateInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT
             , next_)
, anchor{}
, poseInAnchorSpace{}
            {}

        //! Default copy constructor
        SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorSpaceCreateInfoMSFT& rhs) = default;
        //! Default copy assignment
        SpatialAnchorSpaceCreateInfoMSFT& operator=(const SpatialAnchorSpaceCreateInfoMSFT& rhs) = default;
        //! Copy construct from raw
        SpatialAnchorSpaceCreateInfoMSFT(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs) : SpatialAnchorSpaceCreateInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpatialAnchorSpaceCreateInfoMSFT& operator=(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpatialAnchorSpaceCreateInfoMSFT &() const { return *reinterpret_cast<const XrSpatialAnchorSpaceCreateInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpatialAnchorSpaceCreateInfoMSFT &() {
            return *reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
        XrSpatialAnchorSpaceCreateInfoMSFT const* get() const noexcept { return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpatialAnchorSpaceCreateInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpatialAnchorSpaceCreateInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
        }
        SpatialAnchorMSFT anchor;
        Posef poseInAnchorSpace;
    };
     static_assert(sizeof(XrSpatialAnchorSpaceCreateInfoMSFT) == sizeof(SpatialAnchorSpaceCreateInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpatialAnchorSpaceCreateInfoMSFT pointer to const from a SpatialAnchorSpaceCreateInfoMSFT reference to const.
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT const* get(SpatialAnchorSpaceCreateInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorSpaceCreateInfoMSFT as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT * put(SpatialAnchorSpaceCreateInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_spatial_anchor































    #ifdef XR_FB_composition_layer_image_layout
/*!
 * C++ projection of XrCompositionLayerImageLayoutFB
 * 
 * Provided by the `XR_FB_composition_layer_image_layout` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerImageLayoutFB>
 * @xrentity{XrCompositionLayerImageLayoutFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerImageLayoutFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 CompositionLayerImageLayoutFB (
            void * next_ = nullptr)

: Parent(StructureType::CompositionLayerImageLayoutFB
             , next_)
            {}

        //! Default copy constructor
        CompositionLayerImageLayoutFB(const CompositionLayerImageLayoutFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerImageLayoutFB& operator=(const CompositionLayerImageLayoutFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerImageLayoutFB(const XrCompositionLayerImageLayoutFB& rhs) : CompositionLayerImageLayoutFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerImageLayoutFB& operator=(const XrCompositionLayerImageLayoutFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerImageLayoutFB &() const { return *reinterpret_cast<const XrCompositionLayerImageLayoutFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerImageLayoutFB &() {
            return *reinterpret_cast<XrCompositionLayerImageLayoutFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerImageLayoutFB
        XrCompositionLayerImageLayoutFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerImageLayoutFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerImageLayoutFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerImageLayoutFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerImageLayoutFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerImageLayoutFB*>(this);
        }
        CompositionLayerImageLayoutFlagsFB flags;
    };
     static_assert(sizeof(XrCompositionLayerImageLayoutFB) == sizeof(CompositionLayerImageLayoutFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerImageLayoutFB pointer to const from a CompositionLayerImageLayoutFB reference to const.
 * @relates CompositionLayerImageLayoutFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerImageLayoutFB const* get(CompositionLayerImageLayoutFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerImageLayoutFB as the address of a raw XrCompositionLayerImageLayoutFB
 * @relates CompositionLayerImageLayoutFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerImageLayoutFB * put(CompositionLayerImageLayoutFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_composition_layer_image_layout































    #ifdef XR_FB_composition_layer_alpha_blend
/*!
 * C++ projection of XrCompositionLayerAlphaBlendFB
 * 
 * Provided by the `XR_FB_composition_layer_alpha_blend` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerAlphaBlendFB>
 * @xrentity{XrCompositionLayerAlphaBlendFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerAlphaBlendFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 CompositionLayerAlphaBlendFB (
            void * next_ = nullptr)

: Parent(StructureType::CompositionLayerAlphaBlendFB
             , next_)
            {}

        //! Default copy constructor
        CompositionLayerAlphaBlendFB(const CompositionLayerAlphaBlendFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerAlphaBlendFB& operator=(const CompositionLayerAlphaBlendFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerAlphaBlendFB(const XrCompositionLayerAlphaBlendFB& rhs) : CompositionLayerAlphaBlendFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerAlphaBlendFB& operator=(const XrCompositionLayerAlphaBlendFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerAlphaBlendFB &() const { return *reinterpret_cast<const XrCompositionLayerAlphaBlendFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerAlphaBlendFB &() {
            return *reinterpret_cast<XrCompositionLayerAlphaBlendFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerAlphaBlendFB
        XrCompositionLayerAlphaBlendFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerAlphaBlendFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerAlphaBlendFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerAlphaBlendFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerAlphaBlendFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerAlphaBlendFB*>(this);
        }
        BlendFactorFB srcFactorColor;
        BlendFactorFB dstFactorColor;
        BlendFactorFB srcFactorAlpha;
        BlendFactorFB dstFactorAlpha;
    };
     static_assert(sizeof(XrCompositionLayerAlphaBlendFB) == sizeof(CompositionLayerAlphaBlendFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerAlphaBlendFB pointer to const from a CompositionLayerAlphaBlendFB reference to const.
 * @relates CompositionLayerAlphaBlendFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerAlphaBlendFB const* get(CompositionLayerAlphaBlendFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerAlphaBlendFB as the address of a raw XrCompositionLayerAlphaBlendFB
 * @relates CompositionLayerAlphaBlendFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerAlphaBlendFB * put(CompositionLayerAlphaBlendFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_composition_layer_alpha_blend































    #ifdef XR_EXT_view_configuration_depth_range
/*!
 * C++ projection of XrViewConfigurationDepthRangeEXT
 * 
 * Provided by the `XR_EXT_view_configuration_depth_range` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationDepthRangeEXT>
 * @xrentity{XrViewConfigurationDepthRangeEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewConfigurationDepthRangeEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ViewConfigurationDepthRangeEXT (
            void * next_ = nullptr)

: Parent(StructureType::ViewConfigurationDepthRangeEXT
             , next_)
            {}

        //! Default copy constructor
        ViewConfigurationDepthRangeEXT(const ViewConfigurationDepthRangeEXT& rhs) = default;
        //! Default copy assignment
        ViewConfigurationDepthRangeEXT& operator=(const ViewConfigurationDepthRangeEXT& rhs) = default;
        //! Copy construct from raw
        ViewConfigurationDepthRangeEXT(const XrViewConfigurationDepthRangeEXT& rhs) : ViewConfigurationDepthRangeEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewConfigurationDepthRangeEXT& operator=(const XrViewConfigurationDepthRangeEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewConfigurationDepthRangeEXT &() const { return *reinterpret_cast<const XrViewConfigurationDepthRangeEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewConfigurationDepthRangeEXT &() {
            return *reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrViewConfigurationDepthRangeEXT
        XrViewConfigurationDepthRangeEXT const* get() const noexcept { return reinterpret_cast<XrViewConfigurationDepthRangeEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationDepthRangeEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewConfigurationDepthRangeEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewConfigurationDepthRangeEXT{};next = oldNext;}
            return reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
        }
        float recommendedNearZ;
        float minNearZ;
        float recommendedFarZ;
        float maxFarZ;
    };
     static_assert(sizeof(XrViewConfigurationDepthRangeEXT) == sizeof(ViewConfigurationDepthRangeEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewConfigurationDepthRangeEXT pointer to const from a ViewConfigurationDepthRangeEXT reference to const.
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT const* get(ViewConfigurationDepthRangeEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationDepthRangeEXT as the address of a raw XrViewConfigurationDepthRangeEXT
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT * put(ViewConfigurationDepthRangeEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_view_configuration_depth_range































    #ifdef XR_MNDX_egl_enable
#if defined(XR_USE_PLATFORM_EGL)
/*!
 * C++ projection of XrGraphicsBindingEGLMNDX
 * 
 * Provided by the `XR_MNDX_egl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingEGLMNDX>
 * @xrentity{XrGraphicsBindingEGLMNDX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GraphicsBindingEGLMNDX : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GraphicsBindingEGLMNDX (
 PFN_xrEglGetProcAddressMNDX getProcAddress_,  EGLDisplay display_,  EGLConfig config_,  EGLContext context_,  const void * next_ = nullptr                  )
: Parent(StructureType::GraphicsBindingEGLMNDX
, next_)
, getProcAddress {getProcAddress_}
, display {display_}
, config {config_}
, context {context_}
        {
        }


        //! Default/empty constructor
                 GraphicsBindingEGLMNDX (
            const void * next_ = nullptr)

: Parent(StructureType::GraphicsBindingEGLMNDX
             , next_)
, getProcAddress{nullptr}
, display{}
, config{}
, context{}
            {}

        //! Default copy constructor
        GraphicsBindingEGLMNDX(const GraphicsBindingEGLMNDX& rhs) = default;
        //! Default copy assignment
        GraphicsBindingEGLMNDX& operator=(const GraphicsBindingEGLMNDX& rhs) = default;
        //! Copy construct from raw
        GraphicsBindingEGLMNDX(const XrGraphicsBindingEGLMNDX& rhs) : GraphicsBindingEGLMNDX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GraphicsBindingEGLMNDX& operator=(const XrGraphicsBindingEGLMNDX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGraphicsBindingEGLMNDX &() const { return *reinterpret_cast<const XrGraphicsBindingEGLMNDX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGraphicsBindingEGLMNDX &() {
            return *reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
        }

        //! Accessor for this as the address of a raw XrGraphicsBindingEGLMNDX
        XrGraphicsBindingEGLMNDX const* get() const noexcept { return reinterpret_cast<XrGraphicsBindingEGLMNDX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingEGLMNDX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGraphicsBindingEGLMNDX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GraphicsBindingEGLMNDX{};next = oldNext;}
            return reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
        }
        PFN_xrEglGetProcAddressMNDX getProcAddress;
        EGLDisplay display;
        EGLConfig config;
        EGLContext context;
    };
     static_assert(sizeof(XrGraphicsBindingEGLMNDX) == sizeof(GraphicsBindingEGLMNDX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGraphicsBindingEGLMNDX pointer to const from a GraphicsBindingEGLMNDX reference to const.
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX const* get(GraphicsBindingEGLMNDX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingEGLMNDX as the address of a raw XrGraphicsBindingEGLMNDX
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX * put(GraphicsBindingEGLMNDX &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_PLATFORM_EGL)
#endif  // XR_MNDX_egl_enable































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrSystemHandTrackingPropertiesEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingPropertiesEXT>
 * @xrentity{XrSystemHandTrackingPropertiesEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemHandTrackingPropertiesEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemHandTrackingPropertiesEXT (
            void * next_ = nullptr)

: Parent(StructureType::SystemHandTrackingPropertiesEXT
             , next_)
            {}

        //! Default copy constructor
        SystemHandTrackingPropertiesEXT(const SystemHandTrackingPropertiesEXT& rhs) = default;
        //! Default copy assignment
        SystemHandTrackingPropertiesEXT& operator=(const SystemHandTrackingPropertiesEXT& rhs) = default;
        //! Copy construct from raw
        SystemHandTrackingPropertiesEXT(const XrSystemHandTrackingPropertiesEXT& rhs) : SystemHandTrackingPropertiesEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemHandTrackingPropertiesEXT& operator=(const XrSystemHandTrackingPropertiesEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemHandTrackingPropertiesEXT &() const { return *reinterpret_cast<const XrSystemHandTrackingPropertiesEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemHandTrackingPropertiesEXT &() {
            return *reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemHandTrackingPropertiesEXT
        XrSystemHandTrackingPropertiesEXT const* get() const noexcept { return reinterpret_cast<XrSystemHandTrackingPropertiesEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemHandTrackingPropertiesEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemHandTrackingPropertiesEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemHandTrackingPropertiesEXT{};next = oldNext;}
            return reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
        }
        Bool32 supportsHandTracking;
    };
     static_assert(sizeof(XrSystemHandTrackingPropertiesEXT) == sizeof(SystemHandTrackingPropertiesEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingPropertiesEXT pointer to const from a SystemHandTrackingPropertiesEXT reference to const.
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT const* get(SystemHandTrackingPropertiesEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemHandTrackingPropertiesEXT as the address of a raw XrSystemHandTrackingPropertiesEXT
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT * put(SystemHandTrackingPropertiesEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandTrackerCreateInfoEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerCreateInfoEXT>
 * @xrentity{XrHandTrackerCreateInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackerCreateInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandTrackerCreateInfoEXT (
 const HandEXT& hand_,  const HandJointSetEXT& handJointSet_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandTrackerCreateInfoEXT
, next_)
, hand {hand_}
, handJointSet {handJointSet_}
        {
        }


        //! Default/empty constructor
                 HandTrackerCreateInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::HandTrackerCreateInfoEXT
             , next_)
, hand{}
, handJointSet{}
            {}

        //! Default copy constructor
        HandTrackerCreateInfoEXT(const HandTrackerCreateInfoEXT& rhs) = default;
        //! Default copy assignment
        HandTrackerCreateInfoEXT& operator=(const HandTrackerCreateInfoEXT& rhs) = default;
        //! Copy construct from raw
        HandTrackerCreateInfoEXT(const XrHandTrackerCreateInfoEXT& rhs) : HandTrackerCreateInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackerCreateInfoEXT& operator=(const XrHandTrackerCreateInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackerCreateInfoEXT &() const { return *reinterpret_cast<const XrHandTrackerCreateInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackerCreateInfoEXT &() {
            return *reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackerCreateInfoEXT
        XrHandTrackerCreateInfoEXT const* get() const noexcept { return reinterpret_cast<XrHandTrackerCreateInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackerCreateInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackerCreateInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackerCreateInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
        }
        HandEXT hand;
        HandJointSetEXT handJointSet;
    };
     static_assert(sizeof(XrHandTrackerCreateInfoEXT) == sizeof(HandTrackerCreateInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackerCreateInfoEXT pointer to const from a HandTrackerCreateInfoEXT reference to const.
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT const* get(HandTrackerCreateInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackerCreateInfoEXT as the address of a raw XrHandTrackerCreateInfoEXT
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT * put(HandTrackerCreateInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointsLocateInfoEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsLocateInfoEXT>
 * @xrentity{XrHandJointsLocateInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandJointsLocateInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandJointsLocateInfoEXT (
 const Space& baseSpace_,  const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandJointsLocateInfoEXT
, next_)
, baseSpace {baseSpace_}
, time {time_}
        {
        }


        //! Default/empty constructor
                 HandJointsLocateInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::HandJointsLocateInfoEXT
             , next_)
, baseSpace{}
, time{}
            {}

        //! Default copy constructor
        HandJointsLocateInfoEXT(const HandJointsLocateInfoEXT& rhs) = default;
        //! Default copy assignment
        HandJointsLocateInfoEXT& operator=(const HandJointsLocateInfoEXT& rhs) = default;
        //! Copy construct from raw
        HandJointsLocateInfoEXT(const XrHandJointsLocateInfoEXT& rhs) : HandJointsLocateInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandJointsLocateInfoEXT& operator=(const XrHandJointsLocateInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandJointsLocateInfoEXT &() const { return *reinterpret_cast<const XrHandJointsLocateInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandJointsLocateInfoEXT &() {
            return *reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandJointsLocateInfoEXT
        XrHandJointsLocateInfoEXT const* get() const noexcept { return reinterpret_cast<XrHandJointsLocateInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandJointsLocateInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandJointsLocateInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandJointsLocateInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
        }
        Space baseSpace;
        Time time;
    };
     static_assert(sizeof(XrHandJointsLocateInfoEXT) == sizeof(HandJointsLocateInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandJointsLocateInfoEXT pointer to const from a HandJointsLocateInfoEXT reference to const.
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT const* get(HandJointsLocateInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsLocateInfoEXT as the address of a raw XrHandJointsLocateInfoEXT
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT * put(HandJointsLocateInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationEXT>
 * @xrentity{XrHandJointLocationEXT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS HandJointLocationEXT 
    {
    public:
        //! Constructor initializing all members.
                HandJointLocationEXT (
 const SpaceLocationFlags& locationFlags_,  const Posef& pose_,  float radius_                  )
: locationFlags {locationFlags_}
, pose {pose_}
, radius {radius_}
        {
        }


        //! Default/empty constructor
                 HandJointLocationEXT (
            )

: locationFlags{}
, pose{}
, radius{0.0f}
            {}

        //! Default copy constructor
        HandJointLocationEXT(const HandJointLocationEXT& rhs) = default;
        //! Default copy assignment
        HandJointLocationEXT& operator=(const HandJointLocationEXT& rhs) = default;
        //! Copy construct from raw
        HandJointLocationEXT(const XrHandJointLocationEXT& rhs) : HandJointLocationEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandJointLocationEXT& operator=(const XrHandJointLocationEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandJointLocationEXT &() const { return *reinterpret_cast<const XrHandJointLocationEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandJointLocationEXT &() {
            return *reinterpret_cast<XrHandJointLocationEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandJointLocationEXT
        XrHandJointLocationEXT const* get() const noexcept { return reinterpret_cast<XrHandJointLocationEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationEXT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrHandJointLocationEXT * put(bool clear = true) noexcept {
            if (clear) {*this = HandJointLocationEXT{};}
            return reinterpret_cast<XrHandJointLocationEXT*>(this);
        }
        SpaceLocationFlags locationFlags;
        Posef pose;
        float radius;
    };
     static_assert(sizeof(XrHandJointLocationEXT) == sizeof(HandJointLocationEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandJointLocationEXT pointer to const from a HandJointLocationEXT reference to const.
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointLocationEXT const* get(HandJointLocationEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationEXT as the address of a raw XrHandJointLocationEXT
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointLocationEXT * put(HandJointLocationEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocityEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocityEXT>
 * @xrentity{XrHandJointVelocityEXT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS HandJointVelocityEXT 
    {
    public:
        //! Constructor initializing all members.
                HandJointVelocityEXT (
 const SpaceVelocityFlags& velocityFlags_,  const Vector3f& linearVelocity_,  const Vector3f& angularVelocity_                  )
: velocityFlags {velocityFlags_}
, linearVelocity {linearVelocity_}
, angularVelocity {angularVelocity_}
        {
        }


        //! Default/empty constructor
                 HandJointVelocityEXT (
            )

: velocityFlags{}
, linearVelocity{}
, angularVelocity{}
            {}

        //! Default copy constructor
        HandJointVelocityEXT(const HandJointVelocityEXT& rhs) = default;
        //! Default copy assignment
        HandJointVelocityEXT& operator=(const HandJointVelocityEXT& rhs) = default;
        //! Copy construct from raw
        HandJointVelocityEXT(const XrHandJointVelocityEXT& rhs) : HandJointVelocityEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandJointVelocityEXT& operator=(const XrHandJointVelocityEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandJointVelocityEXT &() const { return *reinterpret_cast<const XrHandJointVelocityEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandJointVelocityEXT &() {
            return *reinterpret_cast<XrHandJointVelocityEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandJointVelocityEXT
        XrHandJointVelocityEXT const* get() const noexcept { return reinterpret_cast<XrHandJointVelocityEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocityEXT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrHandJointVelocityEXT * put(bool clear = true) noexcept {
            if (clear) {*this = HandJointVelocityEXT{};}
            return reinterpret_cast<XrHandJointVelocityEXT*>(this);
        }
        SpaceVelocityFlags velocityFlags;
        Vector3f linearVelocity;
        Vector3f angularVelocity;
    };
     static_assert(sizeof(XrHandJointVelocityEXT) == sizeof(HandJointVelocityEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandJointVelocityEXT pointer to const from a HandJointVelocityEXT reference to const.
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointVelocityEXT const* get(HandJointVelocityEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocityEXT as the address of a raw XrHandJointVelocityEXT
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointVelocityEXT * put(HandJointVelocityEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationsEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationsEXT>
 * @xrentity{XrHandJointLocationsEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandJointLocationsEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandJointLocationsEXT (
            void * next_ = nullptr)

: Parent(StructureType::HandJointLocationsEXT
             , next_)
            {}

        //! Default copy constructor
        HandJointLocationsEXT(const HandJointLocationsEXT& rhs) = default;
        //! Default copy assignment
        HandJointLocationsEXT& operator=(const HandJointLocationsEXT& rhs) = default;
        //! Copy construct from raw
        HandJointLocationsEXT(const XrHandJointLocationsEXT& rhs) : HandJointLocationsEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandJointLocationsEXT& operator=(const XrHandJointLocationsEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandJointLocationsEXT &() const { return *reinterpret_cast<const XrHandJointLocationsEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandJointLocationsEXT &() {
            return *reinterpret_cast<XrHandJointLocationsEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandJointLocationsEXT
        XrHandJointLocationsEXT const* get() const noexcept { return reinterpret_cast<XrHandJointLocationsEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationsEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandJointLocationsEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandJointLocationsEXT{};next = oldNext;}
            return reinterpret_cast<XrHandJointLocationsEXT*>(this);
        }
        Bool32 isActive;
        uint32_t jointCount;
        HandJointLocationEXT* jointLocations;
    };
     static_assert(sizeof(XrHandJointLocationsEXT) == sizeof(HandJointLocationsEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandJointLocationsEXT pointer to const from a HandJointLocationsEXT reference to const.
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointLocationsEXT const* get(HandJointLocationsEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationsEXT as the address of a raw XrHandJointLocationsEXT
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointLocationsEXT * put(HandJointLocationsEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocitiesEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocitiesEXT>
 * @xrentity{XrHandJointVelocitiesEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandJointVelocitiesEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandJointVelocitiesEXT (
            void * next_ = nullptr)

: Parent(StructureType::HandJointVelocitiesEXT
             , next_)
            {}

        //! Default copy constructor
        HandJointVelocitiesEXT(const HandJointVelocitiesEXT& rhs) = default;
        //! Default copy assignment
        HandJointVelocitiesEXT& operator=(const HandJointVelocitiesEXT& rhs) = default;
        //! Copy construct from raw
        HandJointVelocitiesEXT(const XrHandJointVelocitiesEXT& rhs) : HandJointVelocitiesEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandJointVelocitiesEXT& operator=(const XrHandJointVelocitiesEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandJointVelocitiesEXT &() const { return *reinterpret_cast<const XrHandJointVelocitiesEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandJointVelocitiesEXT &() {
            return *reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandJointVelocitiesEXT
        XrHandJointVelocitiesEXT const* get() const noexcept { return reinterpret_cast<XrHandJointVelocitiesEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocitiesEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandJointVelocitiesEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandJointVelocitiesEXT{};next = oldNext;}
            return reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
        }
        uint32_t jointCount;
        HandJointVelocityEXT* jointVelocities;
    };
     static_assert(sizeof(XrHandJointVelocitiesEXT) == sizeof(HandJointVelocitiesEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandJointVelocitiesEXT pointer to const from a HandJointVelocitiesEXT reference to const.
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT const* get(HandJointVelocitiesEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocitiesEXT as the address of a raw XrHandJointVelocitiesEXT
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT * put(HandJointVelocitiesEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrSystemHandTrackingMeshPropertiesMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingMeshPropertiesMSFT>
 * @xrentity{XrSystemHandTrackingMeshPropertiesMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemHandTrackingMeshPropertiesMSFT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemHandTrackingMeshPropertiesMSFT (
            void * next_ = nullptr)

: Parent(StructureType::SystemHandTrackingMeshPropertiesMSFT
             , next_)
            {}

        //! Default copy constructor
        SystemHandTrackingMeshPropertiesMSFT(const SystemHandTrackingMeshPropertiesMSFT& rhs) = default;
        //! Default copy assignment
        SystemHandTrackingMeshPropertiesMSFT& operator=(const SystemHandTrackingMeshPropertiesMSFT& rhs) = default;
        //! Copy construct from raw
        SystemHandTrackingMeshPropertiesMSFT(const XrSystemHandTrackingMeshPropertiesMSFT& rhs) : SystemHandTrackingMeshPropertiesMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemHandTrackingMeshPropertiesMSFT& operator=(const XrSystemHandTrackingMeshPropertiesMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemHandTrackingMeshPropertiesMSFT &() const { return *reinterpret_cast<const XrSystemHandTrackingMeshPropertiesMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemHandTrackingMeshPropertiesMSFT &() {
            return *reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemHandTrackingMeshPropertiesMSFT
        XrSystemHandTrackingMeshPropertiesMSFT const* get() const noexcept { return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemHandTrackingMeshPropertiesMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemHandTrackingMeshPropertiesMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemHandTrackingMeshPropertiesMSFT{};next = oldNext;}
            return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
        }
        Bool32 supportsHandTrackingMesh;
        uint32_t maxHandMeshIndexCount;
        uint32_t maxHandMeshVertexCount;
    };
     static_assert(sizeof(XrSystemHandTrackingMeshPropertiesMSFT) == sizeof(SystemHandTrackingMeshPropertiesMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingMeshPropertiesMSFT pointer to const from a SystemHandTrackingMeshPropertiesMSFT reference to const.
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT const* get(SystemHandTrackingMeshPropertiesMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemHandTrackingMeshPropertiesMSFT as the address of a raw XrSystemHandTrackingMeshPropertiesMSFT
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT * put(SystemHandTrackingMeshPropertiesMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshSpaceCreateInfoMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshSpaceCreateInfoMSFT>
 * @xrentity{XrHandMeshSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandMeshSpaceCreateInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandMeshSpaceCreateInfoMSFT (
 const HandPoseTypeMSFT& handPoseType_,  const Posef& poseInHandMeshSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandMeshSpaceCreateInfoMSFT
, next_)
, handPoseType {handPoseType_}
, poseInHandMeshSpace {poseInHandMeshSpace_}
        {
        }


        //! Default/empty constructor
                 HandMeshSpaceCreateInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::HandMeshSpaceCreateInfoMSFT
             , next_)
, handPoseType{}
, poseInHandMeshSpace{}
            {}

        //! Default copy constructor
        HandMeshSpaceCreateInfoMSFT(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
        //! Default copy assignment
        HandMeshSpaceCreateInfoMSFT& operator=(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
        //! Copy construct from raw
        HandMeshSpaceCreateInfoMSFT(const XrHandMeshSpaceCreateInfoMSFT& rhs) : HandMeshSpaceCreateInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandMeshSpaceCreateInfoMSFT& operator=(const XrHandMeshSpaceCreateInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandMeshSpaceCreateInfoMSFT &() const { return *reinterpret_cast<const XrHandMeshSpaceCreateInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandMeshSpaceCreateInfoMSFT &() {
            return *reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandMeshSpaceCreateInfoMSFT
        XrHandMeshSpaceCreateInfoMSFT const* get() const noexcept { return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshSpaceCreateInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandMeshSpaceCreateInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandMeshSpaceCreateInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
        }
        HandPoseTypeMSFT handPoseType;
        Posef poseInHandMeshSpace;
    };
     static_assert(sizeof(XrHandMeshSpaceCreateInfoMSFT) == sizeof(HandMeshSpaceCreateInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandMeshSpaceCreateInfoMSFT pointer to const from a HandMeshSpaceCreateInfoMSFT reference to const.
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT const* get(HandMeshSpaceCreateInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshSpaceCreateInfoMSFT as the address of a raw XrHandMeshSpaceCreateInfoMSFT
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT * put(HandMeshSpaceCreateInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshUpdateInfoMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshUpdateInfoMSFT>
 * @xrentity{XrHandMeshUpdateInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandMeshUpdateInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandMeshUpdateInfoMSFT (
 const Time& time_,  const HandPoseTypeMSFT& handPoseType_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandMeshUpdateInfoMSFT
, next_)
, time {time_}
, handPoseType {handPoseType_}
        {
        }


        //! Default/empty constructor
                 HandMeshUpdateInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::HandMeshUpdateInfoMSFT
             , next_)
, time{}
, handPoseType{}
            {}

        //! Default copy constructor
        HandMeshUpdateInfoMSFT(const HandMeshUpdateInfoMSFT& rhs) = default;
        //! Default copy assignment
        HandMeshUpdateInfoMSFT& operator=(const HandMeshUpdateInfoMSFT& rhs) = default;
        //! Copy construct from raw
        HandMeshUpdateInfoMSFT(const XrHandMeshUpdateInfoMSFT& rhs) : HandMeshUpdateInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandMeshUpdateInfoMSFT& operator=(const XrHandMeshUpdateInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandMeshUpdateInfoMSFT &() const { return *reinterpret_cast<const XrHandMeshUpdateInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandMeshUpdateInfoMSFT &() {
            return *reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandMeshUpdateInfoMSFT
        XrHandMeshUpdateInfoMSFT const* get() const noexcept { return reinterpret_cast<XrHandMeshUpdateInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshUpdateInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandMeshUpdateInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandMeshUpdateInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
        }
        Time time;
        HandPoseTypeMSFT handPoseType;
    };
     static_assert(sizeof(XrHandMeshUpdateInfoMSFT) == sizeof(HandMeshUpdateInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandMeshUpdateInfoMSFT pointer to const from a HandMeshUpdateInfoMSFT reference to const.
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT const* get(HandMeshUpdateInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshUpdateInfoMSFT as the address of a raw XrHandMeshUpdateInfoMSFT
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT * put(HandMeshUpdateInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshIndexBufferMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshIndexBufferMSFT>
 * @xrentity{XrHandMeshIndexBufferMSFT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS HandMeshIndexBufferMSFT 
    {
    public:
        //! Constructor initializing all members.
                HandMeshIndexBufferMSFT (
 uint32_t indexBufferKey_,  uint32_t indexCapacityInput_,  uint32_t indexCountOutput_,  uint32_t* indices_                  )
: indexBufferKey {indexBufferKey_}
, indexCapacityInput {indexCapacityInput_}
, indexCountOutput {indexCountOutput_}
, indices {indices_}
        {
        }


        //! Default/empty constructor
                 HandMeshIndexBufferMSFT (
            )

: indexBufferKey{0}
, indexCapacityInput{0}
, indexCountOutput{0}
, indices{nullptr}
            {}

        //! Default copy constructor
        HandMeshIndexBufferMSFT(const HandMeshIndexBufferMSFT& rhs) = default;
        //! Default copy assignment
        HandMeshIndexBufferMSFT& operator=(const HandMeshIndexBufferMSFT& rhs) = default;
        //! Copy construct from raw
        HandMeshIndexBufferMSFT(const XrHandMeshIndexBufferMSFT& rhs) : HandMeshIndexBufferMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandMeshIndexBufferMSFT& operator=(const XrHandMeshIndexBufferMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandMeshIndexBufferMSFT &() const { return *reinterpret_cast<const XrHandMeshIndexBufferMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandMeshIndexBufferMSFT &() {
            return *reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandMeshIndexBufferMSFT
        XrHandMeshIndexBufferMSFT const* get() const noexcept { return reinterpret_cast<XrHandMeshIndexBufferMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshIndexBufferMSFT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrHandMeshIndexBufferMSFT * put(bool clear = true) noexcept {
            if (clear) {*this = HandMeshIndexBufferMSFT{};}
            return reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
        }
        uint32_t indexBufferKey;
        uint32_t indexCapacityInput;
        uint32_t indexCountOutput;
        uint32_t* indices;
    };
     static_assert(sizeof(XrHandMeshIndexBufferMSFT) == sizeof(HandMeshIndexBufferMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandMeshIndexBufferMSFT pointer to const from a HandMeshIndexBufferMSFT reference to const.
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT const* get(HandMeshIndexBufferMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshIndexBufferMSFT as the address of a raw XrHandMeshIndexBufferMSFT
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT * put(HandMeshIndexBufferMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexMSFT>
 * @xrentity{XrHandMeshVertexMSFT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS HandMeshVertexMSFT 
    {
    public:
        //! Constructor initializing all members.
                HandMeshVertexMSFT (
 const Vector3f& position_,  const Vector3f& normal_                  )
: position {position_}
, normal {normal_}
        {
        }


        //! Default/empty constructor
                 HandMeshVertexMSFT (
            )

: position{}
, normal{}
            {}

        //! Default copy constructor
        HandMeshVertexMSFT(const HandMeshVertexMSFT& rhs) = default;
        //! Default copy assignment
        HandMeshVertexMSFT& operator=(const HandMeshVertexMSFT& rhs) = default;
        //! Copy construct from raw
        HandMeshVertexMSFT(const XrHandMeshVertexMSFT& rhs) : HandMeshVertexMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandMeshVertexMSFT& operator=(const XrHandMeshVertexMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandMeshVertexMSFT &() const { return *reinterpret_cast<const XrHandMeshVertexMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandMeshVertexMSFT &() {
            return *reinterpret_cast<XrHandMeshVertexMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandMeshVertexMSFT
        XrHandMeshVertexMSFT const* get() const noexcept { return reinterpret_cast<XrHandMeshVertexMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshVertexMSFT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrHandMeshVertexMSFT * put(bool clear = true) noexcept {
            if (clear) {*this = HandMeshVertexMSFT{};}
            return reinterpret_cast<XrHandMeshVertexMSFT*>(this);
        }
        Vector3f position;
        Vector3f normal;
    };
     static_assert(sizeof(XrHandMeshVertexMSFT) == sizeof(HandMeshVertexMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandMeshVertexMSFT pointer to const from a HandMeshVertexMSFT reference to const.
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshVertexMSFT const* get(HandMeshVertexMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexMSFT as the address of a raw XrHandMeshVertexMSFT
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshVertexMSFT * put(HandMeshVertexMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexBufferMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexBufferMSFT>
 * @xrentity{XrHandMeshVertexBufferMSFT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS HandMeshVertexBufferMSFT 
    {
    public:
        //! Constructor initializing all members.
                HandMeshVertexBufferMSFT (
 const Time& vertexUpdateTime_,  uint32_t vertexCapacityInput_,  uint32_t vertexCountOutput_,  HandMeshVertexMSFT* vertices_                  )
: vertexUpdateTime {vertexUpdateTime_}
, vertexCapacityInput {vertexCapacityInput_}
, vertexCountOutput {vertexCountOutput_}
, vertices {vertices_}
        {
        }


        //! Default/empty constructor
                 HandMeshVertexBufferMSFT (
            )

: vertexUpdateTime{}
, vertexCapacityInput{0}
, vertexCountOutput{0}
, vertices{nullptr}
            {}

        //! Default copy constructor
        HandMeshVertexBufferMSFT(const HandMeshVertexBufferMSFT& rhs) = default;
        //! Default copy assignment
        HandMeshVertexBufferMSFT& operator=(const HandMeshVertexBufferMSFT& rhs) = default;
        //! Copy construct from raw
        HandMeshVertexBufferMSFT(const XrHandMeshVertexBufferMSFT& rhs) : HandMeshVertexBufferMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandMeshVertexBufferMSFT& operator=(const XrHandMeshVertexBufferMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandMeshVertexBufferMSFT &() const { return *reinterpret_cast<const XrHandMeshVertexBufferMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandMeshVertexBufferMSFT &() {
            return *reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandMeshVertexBufferMSFT
        XrHandMeshVertexBufferMSFT const* get() const noexcept { return reinterpret_cast<XrHandMeshVertexBufferMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshVertexBufferMSFT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrHandMeshVertexBufferMSFT * put(bool clear = true) noexcept {
            if (clear) {*this = HandMeshVertexBufferMSFT{};}
            return reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
        }
        Time vertexUpdateTime;
        uint32_t vertexCapacityInput;
        uint32_t vertexCountOutput;
        HandMeshVertexMSFT* vertices;
    };
     static_assert(sizeof(XrHandMeshVertexBufferMSFT) == sizeof(HandMeshVertexBufferMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandMeshVertexBufferMSFT pointer to const from a HandMeshVertexBufferMSFT reference to const.
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT const* get(HandMeshVertexBufferMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexBufferMSFT as the address of a raw XrHandMeshVertexBufferMSFT
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT * put(HandMeshVertexBufferMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshMSFT>
 * @xrentity{XrHandMeshMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandMeshMSFT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandMeshMSFT (
            void * next_ = nullptr)

: Parent(StructureType::HandMeshMSFT
             , next_)
            {}

        //! Default copy constructor
        HandMeshMSFT(const HandMeshMSFT& rhs) = default;
        //! Default copy assignment
        HandMeshMSFT& operator=(const HandMeshMSFT& rhs) = default;
        //! Copy construct from raw
        HandMeshMSFT(const XrHandMeshMSFT& rhs) : HandMeshMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandMeshMSFT& operator=(const XrHandMeshMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandMeshMSFT &() const { return *reinterpret_cast<const XrHandMeshMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandMeshMSFT &() {
            return *reinterpret_cast<XrHandMeshMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandMeshMSFT
        XrHandMeshMSFT const* get() const noexcept { return reinterpret_cast<XrHandMeshMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandMeshMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandMeshMSFT{};next = oldNext;}
            return reinterpret_cast<XrHandMeshMSFT*>(this);
        }
        Bool32 isActive;
        Bool32 indexBufferChanged;
        Bool32 vertexBufferChanged;
        HandMeshIndexBufferMSFT indexBuffer;
        HandMeshVertexBufferMSFT vertexBuffer;
    };
     static_assert(sizeof(XrHandMeshMSFT) == sizeof(HandMeshMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandMeshMSFT pointer to const from a HandMeshMSFT reference to const.
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshMSFT const* get(HandMeshMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshMSFT as the address of a raw XrHandMeshMSFT
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandMeshMSFT * put(HandMeshMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandPoseTypeInfoMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeInfoMSFT>
 * @xrentity{XrHandPoseTypeInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandPoseTypeInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandPoseTypeInfoMSFT (
 const HandPoseTypeMSFT& handPoseType_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandPoseTypeInfoMSFT
, next_)
, handPoseType {handPoseType_}
        {
        }


        //! Default/empty constructor
                 HandPoseTypeInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::HandPoseTypeInfoMSFT
             , next_)
, handPoseType{}
            {}

        //! Default copy constructor
        HandPoseTypeInfoMSFT(const HandPoseTypeInfoMSFT& rhs) = default;
        //! Default copy assignment
        HandPoseTypeInfoMSFT& operator=(const HandPoseTypeInfoMSFT& rhs) = default;
        //! Copy construct from raw
        HandPoseTypeInfoMSFT(const XrHandPoseTypeInfoMSFT& rhs) : HandPoseTypeInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandPoseTypeInfoMSFT& operator=(const XrHandPoseTypeInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandPoseTypeInfoMSFT &() const { return *reinterpret_cast<const XrHandPoseTypeInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandPoseTypeInfoMSFT &() {
            return *reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandPoseTypeInfoMSFT
        XrHandPoseTypeInfoMSFT const* get() const noexcept { return reinterpret_cast<XrHandPoseTypeInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandPoseTypeInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandPoseTypeInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandPoseTypeInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this);
        }
        HandPoseTypeMSFT handPoseType;
    };
     static_assert(sizeof(XrHandPoseTypeInfoMSFT) == sizeof(HandPoseTypeInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandPoseTypeInfoMSFT pointer to const from a HandPoseTypeInfoMSFT reference to const.
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT const* get(HandPoseTypeInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandPoseTypeInfoMSFT as the address of a raw XrHandPoseTypeInfoMSFT
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT * put(HandPoseTypeInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_hand_tracking_mesh































    #ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSessionBeginInfoMSFT
 * 
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSessionBeginInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSessionBeginInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SecondaryViewConfigurationSessionBeginInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SecondaryViewConfigurationSessionBeginInfoMSFT (
 uint32_t viewConfigurationCount_,  const ViewConfigurationType* enabledViewConfigurationTypes_,  const void * next_ = nullptr                  )
: Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT
, next_)
, viewConfigurationCount {viewConfigurationCount_}
, enabledViewConfigurationTypes {enabledViewConfigurationTypes_}
        {
        }


        //! Default/empty constructor
                 SecondaryViewConfigurationSessionBeginInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT
             , next_)
, viewConfigurationCount{0}
, enabledViewConfigurationTypes{nullptr}
            {}

        //! Default copy constructor
        SecondaryViewConfigurationSessionBeginInfoMSFT(const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
        //! Default copy assignment
        SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
        //! Copy construct from raw
        SecondaryViewConfigurationSessionBeginInfoMSFT(const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs) : SecondaryViewConfigurationSessionBeginInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSecondaryViewConfigurationSessionBeginInfoMSFT &() const { return *reinterpret_cast<const XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSecondaryViewConfigurationSessionBeginInfoMSFT &() {
            return *reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT
        XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get() const noexcept { return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSecondaryViewConfigurationSessionBeginInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SecondaryViewConfigurationSessionBeginInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
        }
        uint32_t viewConfigurationCount;
        const ViewConfigurationType* enabledViewConfigurationTypes;
    };
     static_assert(sizeof(XrSecondaryViewConfigurationSessionBeginInfoMSFT) == sizeof(SecondaryViewConfigurationSessionBeginInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT pointer to const from a SecondaryViewConfigurationSessionBeginInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get(SecondaryViewConfigurationSessionBeginInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SecondaryViewConfigurationSessionBeginInfoMSFT as the address of a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT * put(SecondaryViewConfigurationSessionBeginInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_secondary_view_configuration































    #ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationStateMSFT
 * 
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationStateMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SecondaryViewConfigurationStateMSFT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SecondaryViewConfigurationStateMSFT (
            void * next_ = nullptr)

: Parent(StructureType::SecondaryViewConfigurationStateMSFT
             , next_)
            {}

        //! Default copy constructor
        SecondaryViewConfigurationStateMSFT(const SecondaryViewConfigurationStateMSFT& rhs) = default;
        //! Default copy assignment
        SecondaryViewConfigurationStateMSFT& operator=(const SecondaryViewConfigurationStateMSFT& rhs) = default;
        //! Copy construct from raw
        SecondaryViewConfigurationStateMSFT(const XrSecondaryViewConfigurationStateMSFT& rhs) : SecondaryViewConfigurationStateMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SecondaryViewConfigurationStateMSFT& operator=(const XrSecondaryViewConfigurationStateMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSecondaryViewConfigurationStateMSFT &() const { return *reinterpret_cast<const XrSecondaryViewConfigurationStateMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSecondaryViewConfigurationStateMSFT &() {
            return *reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSecondaryViewConfigurationStateMSFT
        XrSecondaryViewConfigurationStateMSFT const* get() const noexcept { return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSecondaryViewConfigurationStateMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSecondaryViewConfigurationStateMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SecondaryViewConfigurationStateMSFT{};next = oldNext;}
            return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
        }
        ViewConfigurationType viewConfigurationType;
        Bool32 active;
    };
     static_assert(sizeof(XrSecondaryViewConfigurationStateMSFT) == sizeof(SecondaryViewConfigurationStateMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationStateMSFT pointer to const from a SecondaryViewConfigurationStateMSFT reference to const.
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT const* get(SecondaryViewConfigurationStateMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SecondaryViewConfigurationStateMSFT as the address of a raw XrSecondaryViewConfigurationStateMSFT
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT * put(SecondaryViewConfigurationStateMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_secondary_view_configuration































    #ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameStateMSFT
 * 
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameStateMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SecondaryViewConfigurationFrameStateMSFT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SecondaryViewConfigurationFrameStateMSFT (
            void * next_ = nullptr)

: Parent(StructureType::SecondaryViewConfigurationFrameStateMSFT
             , next_)
            {}

        //! Default copy constructor
        SecondaryViewConfigurationFrameStateMSFT(const SecondaryViewConfigurationFrameStateMSFT& rhs) = default;
        //! Default copy assignment
        SecondaryViewConfigurationFrameStateMSFT& operator=(const SecondaryViewConfigurationFrameStateMSFT& rhs) = default;
        //! Copy construct from raw
        SecondaryViewConfigurationFrameStateMSFT(const XrSecondaryViewConfigurationFrameStateMSFT& rhs) : SecondaryViewConfigurationFrameStateMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SecondaryViewConfigurationFrameStateMSFT& operator=(const XrSecondaryViewConfigurationFrameStateMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSecondaryViewConfigurationFrameStateMSFT &() const { return *reinterpret_cast<const XrSecondaryViewConfigurationFrameStateMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSecondaryViewConfigurationFrameStateMSFT &() {
            return *reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameStateMSFT
        XrSecondaryViewConfigurationFrameStateMSFT const* get() const noexcept { return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSecondaryViewConfigurationFrameStateMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSecondaryViewConfigurationFrameStateMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SecondaryViewConfigurationFrameStateMSFT{};next = oldNext;}
            return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
        }
        uint32_t viewConfigurationCount;
        SecondaryViewConfigurationStateMSFT* viewConfigurationStates;
    };
     static_assert(sizeof(XrSecondaryViewConfigurationFrameStateMSFT) == sizeof(SecondaryViewConfigurationFrameStateMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameStateMSFT pointer to const from a SecondaryViewConfigurationFrameStateMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT const* get(SecondaryViewConfigurationFrameStateMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SecondaryViewConfigurationFrameStateMSFT as the address of a raw XrSecondaryViewConfigurationFrameStateMSFT
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT * put(SecondaryViewConfigurationFrameStateMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_secondary_view_configuration































    #ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationLayerInfoMSFT
 * 
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationLayerInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationLayerInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SecondaryViewConfigurationLayerInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SecondaryViewConfigurationLayerInfoMSFT (
 const ViewConfigurationType& viewConfigurationType_,  const EnvironmentBlendMode& environmentBlendMode_,  uint32_t layerCount_,  const CompositionLayerBaseHeader* const* layers_,  const void * next_ = nullptr                  )
: Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT
, next_)
, viewConfigurationType {viewConfigurationType_}
, environmentBlendMode {environmentBlendMode_}
, layerCount {layerCount_}
, layers {layers_}
        {
        }


        //! Default/empty constructor
                 SecondaryViewConfigurationLayerInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT
             , next_)
, viewConfigurationType{}
, environmentBlendMode{}
, layerCount{0}
, layers{nullptr}
            {}

        //! Default copy constructor
        SecondaryViewConfigurationLayerInfoMSFT(const SecondaryViewConfigurationLayerInfoMSFT& rhs) = default;
        //! Default copy assignment
        SecondaryViewConfigurationLayerInfoMSFT& operator=(const SecondaryViewConfigurationLayerInfoMSFT& rhs) = default;
        //! Copy construct from raw
        SecondaryViewConfigurationLayerInfoMSFT(const XrSecondaryViewConfigurationLayerInfoMSFT& rhs) : SecondaryViewConfigurationLayerInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SecondaryViewConfigurationLayerInfoMSFT& operator=(const XrSecondaryViewConfigurationLayerInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSecondaryViewConfigurationLayerInfoMSFT &() const { return *reinterpret_cast<const XrSecondaryViewConfigurationLayerInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSecondaryViewConfigurationLayerInfoMSFT &() {
            return *reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSecondaryViewConfigurationLayerInfoMSFT
        XrSecondaryViewConfigurationLayerInfoMSFT const* get() const noexcept { return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSecondaryViewConfigurationLayerInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSecondaryViewConfigurationLayerInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SecondaryViewConfigurationLayerInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
        }
        ViewConfigurationType viewConfigurationType;
        EnvironmentBlendMode environmentBlendMode;
        uint32_t layerCount;
        const CompositionLayerBaseHeader* const* layers;
    };
     static_assert(sizeof(XrSecondaryViewConfigurationLayerInfoMSFT) == sizeof(SecondaryViewConfigurationLayerInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationLayerInfoMSFT pointer to const from a SecondaryViewConfigurationLayerInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT const* get(SecondaryViewConfigurationLayerInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SecondaryViewConfigurationLayerInfoMSFT as the address of a raw XrSecondaryViewConfigurationLayerInfoMSFT
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT * put(SecondaryViewConfigurationLayerInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_secondary_view_configuration































    #ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameEndInfoMSFT
 * 
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameEndInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameEndInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SecondaryViewConfigurationFrameEndInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SecondaryViewConfigurationFrameEndInfoMSFT (
 uint32_t viewConfigurationCount_,  const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo_,  const void * next_ = nullptr                  )
: Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT
, next_)
, viewConfigurationCount {viewConfigurationCount_}
, viewConfigurationLayersInfo {viewConfigurationLayersInfo_}
        {
        }


        //! Default/empty constructor
                 SecondaryViewConfigurationFrameEndInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT
             , next_)
, viewConfigurationCount{0}
, viewConfigurationLayersInfo{nullptr}
            {}

        //! Default copy constructor
        SecondaryViewConfigurationFrameEndInfoMSFT(const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
        //! Default copy assignment
        SecondaryViewConfigurationFrameEndInfoMSFT& operator=(const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
        //! Copy construct from raw
        SecondaryViewConfigurationFrameEndInfoMSFT(const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs) : SecondaryViewConfigurationFrameEndInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SecondaryViewConfigurationFrameEndInfoMSFT& operator=(const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSecondaryViewConfigurationFrameEndInfoMSFT &() const { return *reinterpret_cast<const XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSecondaryViewConfigurationFrameEndInfoMSFT &() {
            return *reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameEndInfoMSFT
        XrSecondaryViewConfigurationFrameEndInfoMSFT const* get() const noexcept { return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSecondaryViewConfigurationFrameEndInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSecondaryViewConfigurationFrameEndInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SecondaryViewConfigurationFrameEndInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
        }
        uint32_t viewConfigurationCount;
        const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo;
    };
     static_assert(sizeof(XrSecondaryViewConfigurationFrameEndInfoMSFT) == sizeof(SecondaryViewConfigurationFrameEndInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameEndInfoMSFT pointer to const from a SecondaryViewConfigurationFrameEndInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT const* get(SecondaryViewConfigurationFrameEndInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SecondaryViewConfigurationFrameEndInfoMSFT as the address of a raw XrSecondaryViewConfigurationFrameEndInfoMSFT
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT * put(SecondaryViewConfigurationFrameEndInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_secondary_view_configuration































    #ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * 
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSwapchainCreateInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSwapchainCreateInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SecondaryViewConfigurationSwapchainCreateInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SecondaryViewConfigurationSwapchainCreateInfoMSFT (
 const ViewConfigurationType& viewConfigurationType_,  const void * next_ = nullptr                  )
: Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT
, next_)
, viewConfigurationType {viewConfigurationType_}
        {
        }


        //! Default/empty constructor
                 SecondaryViewConfigurationSwapchainCreateInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT
             , next_)
, viewConfigurationType{}
            {}

        //! Default copy constructor
        SecondaryViewConfigurationSwapchainCreateInfoMSFT(const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
        //! Default copy assignment
        SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
        //! Copy construct from raw
        SecondaryViewConfigurationSwapchainCreateInfoMSFT(const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) : SecondaryViewConfigurationSwapchainCreateInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT &() const { return *reinterpret_cast<const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSecondaryViewConfigurationSwapchainCreateInfoMSFT &() {
            return *reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
        XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get() const noexcept { return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSecondaryViewConfigurationSwapchainCreateInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SecondaryViewConfigurationSwapchainCreateInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
        }
        ViewConfigurationType viewConfigurationType;
    };
     static_assert(sizeof(XrSecondaryViewConfigurationSwapchainCreateInfoMSFT) == sizeof(SecondaryViewConfigurationSwapchainCreateInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT pointer to const from a SecondaryViewConfigurationSwapchainCreateInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get(SecondaryViewConfigurationSwapchainCreateInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SecondaryViewConfigurationSwapchainCreateInfoMSFT as the address of a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT * put(SecondaryViewConfigurationSwapchainCreateInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_secondary_view_configuration































    #ifdef XR_EPIC_view_configuration_fov
/*!
 * C++ projection of XrViewConfigurationViewFovEPIC
 * 
 * Provided by the `XR_EPIC_view_configuration_fov` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationViewFovEPIC>
 * @xrentity{XrViewConfigurationViewFovEPIC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewConfigurationViewFovEPIC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ViewConfigurationViewFovEPIC (
 const Fovf& recommendedFov_,  const Fovf& maxMutableFov_,  const void * next_ = nullptr                  )
: Parent(StructureType::ViewConfigurationViewFovEPIC
, next_)
, recommendedFov {recommendedFov_}
, maxMutableFov {maxMutableFov_}
        {
        }


        //! Default/empty constructor
                 ViewConfigurationViewFovEPIC (
            const void * next_ = nullptr)

: Parent(StructureType::ViewConfigurationViewFovEPIC
             , next_)
, recommendedFov{}
, maxMutableFov{}
            {}

        //! Default copy constructor
        ViewConfigurationViewFovEPIC(const ViewConfigurationViewFovEPIC& rhs) = default;
        //! Default copy assignment
        ViewConfigurationViewFovEPIC& operator=(const ViewConfigurationViewFovEPIC& rhs) = default;
        //! Copy construct from raw
        ViewConfigurationViewFovEPIC(const XrViewConfigurationViewFovEPIC& rhs) : ViewConfigurationViewFovEPIC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewConfigurationViewFovEPIC& operator=(const XrViewConfigurationViewFovEPIC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewConfigurationViewFovEPIC &() const { return *reinterpret_cast<const XrViewConfigurationViewFovEPIC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewConfigurationViewFovEPIC &() {
            return *reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
        }

        //! Accessor for this as the address of a raw XrViewConfigurationViewFovEPIC
        XrViewConfigurationViewFovEPIC const* get() const noexcept { return reinterpret_cast<XrViewConfigurationViewFovEPIC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationViewFovEPIC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewConfigurationViewFovEPIC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewConfigurationViewFovEPIC{};next = oldNext;}
            return reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
        }
        Fovf recommendedFov;
        Fovf maxMutableFov;
    };
     static_assert(sizeof(XrViewConfigurationViewFovEPIC) == sizeof(ViewConfigurationViewFovEPIC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewConfigurationViewFovEPIC pointer to const from a ViewConfigurationViewFovEPIC reference to const.
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC const* get(ViewConfigurationViewFovEPIC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationViewFovEPIC as the address of a raw XrViewConfigurationViewFovEPIC
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC * put(ViewConfigurationViewFovEPIC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EPIC_view_configuration_fov































    #ifdef XR_MSFT_composition_layer_reprojection
/*!
 * C++ projection of XrCompositionLayerReprojectionInfoMSFT
 * 
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerReprojectionInfoMSFT>
 * @xrentity{XrCompositionLayerReprojectionInfoMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerReprojectionInfoMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerReprojectionInfoMSFT (
 const ReprojectionModeMSFT& reprojectionMode_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerReprojectionInfoMSFT
, next_)
, reprojectionMode {reprojectionMode_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerReprojectionInfoMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerReprojectionInfoMSFT
             , next_)
, reprojectionMode{}
            {}

        //! Default copy constructor
        CompositionLayerReprojectionInfoMSFT(const CompositionLayerReprojectionInfoMSFT& rhs) = default;
        //! Default copy assignment
        CompositionLayerReprojectionInfoMSFT& operator=(const CompositionLayerReprojectionInfoMSFT& rhs) = default;
        //! Copy construct from raw
        CompositionLayerReprojectionInfoMSFT(const XrCompositionLayerReprojectionInfoMSFT& rhs) : CompositionLayerReprojectionInfoMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerReprojectionInfoMSFT& operator=(const XrCompositionLayerReprojectionInfoMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerReprojectionInfoMSFT &() const { return *reinterpret_cast<const XrCompositionLayerReprojectionInfoMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerReprojectionInfoMSFT &() {
            return *reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerReprojectionInfoMSFT
        XrCompositionLayerReprojectionInfoMSFT const* get() const noexcept { return reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerReprojectionInfoMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerReprojectionInfoMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerReprojectionInfoMSFT{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT*>(this);
        }
        ReprojectionModeMSFT reprojectionMode;
    };
     static_assert(sizeof(XrCompositionLayerReprojectionInfoMSFT) == sizeof(CompositionLayerReprojectionInfoMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerReprojectionInfoMSFT pointer to const from a CompositionLayerReprojectionInfoMSFT reference to const.
 * @relates CompositionLayerReprojectionInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerReprojectionInfoMSFT const* get(CompositionLayerReprojectionInfoMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerReprojectionInfoMSFT as the address of a raw XrCompositionLayerReprojectionInfoMSFT
 * @relates CompositionLayerReprojectionInfoMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerReprojectionInfoMSFT * put(CompositionLayerReprojectionInfoMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_composition_layer_reprojection































    #ifdef XR_MSFT_composition_layer_reprojection
/*!
 * C++ projection of XrCompositionLayerReprojectionPlaneOverrideMSFT
 * 
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerReprojectionPlaneOverrideMSFT>
 * @xrentity{XrCompositionLayerReprojectionPlaneOverrideMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerReprojectionPlaneOverrideMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerReprojectionPlaneOverrideMSFT (
 const Vector3f& position_,  const Vector3f& normal_,  const Vector3f& velocity_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerReprojectionPlaneOverrideMSFT
, next_)
, position {position_}
, normal {normal_}
, velocity {velocity_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerReprojectionPlaneOverrideMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerReprojectionPlaneOverrideMSFT
             , next_)
, position{}
, normal{}
, velocity{}
            {}

        //! Default copy constructor
        CompositionLayerReprojectionPlaneOverrideMSFT(const CompositionLayerReprojectionPlaneOverrideMSFT& rhs) = default;
        //! Default copy assignment
        CompositionLayerReprojectionPlaneOverrideMSFT& operator=(const CompositionLayerReprojectionPlaneOverrideMSFT& rhs) = default;
        //! Copy construct from raw
        CompositionLayerReprojectionPlaneOverrideMSFT(const XrCompositionLayerReprojectionPlaneOverrideMSFT& rhs) : CompositionLayerReprojectionPlaneOverrideMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerReprojectionPlaneOverrideMSFT& operator=(const XrCompositionLayerReprojectionPlaneOverrideMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerReprojectionPlaneOverrideMSFT &() const { return *reinterpret_cast<const XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerReprojectionPlaneOverrideMSFT &() {
            return *reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerReprojectionPlaneOverrideMSFT
        XrCompositionLayerReprojectionPlaneOverrideMSFT const* get() const noexcept { return reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerReprojectionPlaneOverrideMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerReprojectionPlaneOverrideMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerReprojectionPlaneOverrideMSFT{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
        }
        Vector3f position;
        Vector3f normal;
        Vector3f velocity;
    };
     static_assert(sizeof(XrCompositionLayerReprojectionPlaneOverrideMSFT) == sizeof(CompositionLayerReprojectionPlaneOverrideMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerReprojectionPlaneOverrideMSFT pointer to const from a CompositionLayerReprojectionPlaneOverrideMSFT reference to const.
 * @relates CompositionLayerReprojectionPlaneOverrideMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerReprojectionPlaneOverrideMSFT const* get(CompositionLayerReprojectionPlaneOverrideMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerReprojectionPlaneOverrideMSFT as the address of a raw XrCompositionLayerReprojectionPlaneOverrideMSFT
 * @relates CompositionLayerReprojectionPlaneOverrideMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerReprojectionPlaneOverrideMSFT * put(CompositionLayerReprojectionPlaneOverrideMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_composition_layer_reprojection































    #ifdef XR_FB_android_surface_swapchain_create
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrAndroidSurfaceSwapchainCreateInfoFB
 * 
 * Provided by the `XR_FB_android_surface_swapchain_create` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAndroidSurfaceSwapchainCreateInfoFB>
 * @xrentity{XrAndroidSurfaceSwapchainCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS AndroidSurfaceSwapchainCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                AndroidSurfaceSwapchainCreateInfoFB (
 const AndroidSurfaceSwapchainFlagsFB& createFlags_,  const void * next_ = nullptr                  )
: Parent(StructureType::AndroidSurfaceSwapchainCreateInfoFB
, next_)
, createFlags {createFlags_}
        {
        }


        //! Default/empty constructor
                 AndroidSurfaceSwapchainCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::AndroidSurfaceSwapchainCreateInfoFB
             , next_)
, createFlags{}
            {}

        //! Default copy constructor
        AndroidSurfaceSwapchainCreateInfoFB(const AndroidSurfaceSwapchainCreateInfoFB& rhs) = default;
        //! Default copy assignment
        AndroidSurfaceSwapchainCreateInfoFB& operator=(const AndroidSurfaceSwapchainCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        AndroidSurfaceSwapchainCreateInfoFB(const XrAndroidSurfaceSwapchainCreateInfoFB& rhs) : AndroidSurfaceSwapchainCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        AndroidSurfaceSwapchainCreateInfoFB& operator=(const XrAndroidSurfaceSwapchainCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrAndroidSurfaceSwapchainCreateInfoFB &() const { return *reinterpret_cast<const XrAndroidSurfaceSwapchainCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrAndroidSurfaceSwapchainCreateInfoFB &() {
            return *reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB
        XrAndroidSurfaceSwapchainCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrAndroidSurfaceSwapchainCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = AndroidSurfaceSwapchainCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
        }
        AndroidSurfaceSwapchainFlagsFB createFlags;
    };
     static_assert(sizeof(XrAndroidSurfaceSwapchainCreateInfoFB) == sizeof(AndroidSurfaceSwapchainCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrAndroidSurfaceSwapchainCreateInfoFB pointer to const from a AndroidSurfaceSwapchainCreateInfoFB reference to const.
 * @relates AndroidSurfaceSwapchainCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrAndroidSurfaceSwapchainCreateInfoFB const* get(AndroidSurfaceSwapchainCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing AndroidSurfaceSwapchainCreateInfoFB as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB
 * @relates AndroidSurfaceSwapchainCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrAndroidSurfaceSwapchainCreateInfoFB * put(AndroidSurfaceSwapchainCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_FB_android_surface_swapchain_create































    #ifdef XR_FB_swapchain_update_state
/*!
 * C++ projection of XrSwapchainStateBaseHeaderFB
 * 
 * Provided by the `XR_FB_swapchain_update_state` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateBaseHeaderFB>
 * @xrentity{XrSwapchainStateBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS SwapchainStateBaseHeaderFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                SwapchainStateBaseHeaderFB (
  StructureType type_ ,  void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainStateBaseHeaderFB &() const { return *reinterpret_cast<const XrSwapchainStateBaseHeaderFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainStateBaseHeaderFB &() {
            return *reinterpret_cast<XrSwapchainStateBaseHeaderFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainStateBaseHeaderFB
        XrSwapchainStateBaseHeaderFB const* get() const noexcept { return reinterpret_cast<XrSwapchainStateBaseHeaderFB const *>(this); }

    };
     static_assert(sizeof(XrSwapchainStateBaseHeaderFB) == sizeof(SwapchainStateBaseHeaderFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainStateBaseHeaderFB pointer to const from a SwapchainStateBaseHeaderFB reference to const.
 * @relates SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get(SwapchainStateBaseHeaderFB const& s) {
        return s.get();
    }

#endif  // XR_FB_swapchain_update_state































    #ifdef XR_FB_composition_layer_secure_content
/*!
 * C++ projection of XrCompositionLayerSecureContentFB
 * 
 * Provided by the `XR_FB_composition_layer_secure_content` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSecureContentFB>
 * @xrentity{XrCompositionLayerSecureContentFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerSecureContentFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerSecureContentFB (
 const CompositionLayerSecureContentFlagsFB& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerSecureContentFB
, next_)
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerSecureContentFB (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerSecureContentFB
             , next_)
, flags{}
            {}

        //! Default copy constructor
        CompositionLayerSecureContentFB(const CompositionLayerSecureContentFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerSecureContentFB& operator=(const CompositionLayerSecureContentFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerSecureContentFB(const XrCompositionLayerSecureContentFB& rhs) : CompositionLayerSecureContentFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerSecureContentFB& operator=(const XrCompositionLayerSecureContentFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerSecureContentFB &() const { return *reinterpret_cast<const XrCompositionLayerSecureContentFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerSecureContentFB &() {
            return *reinterpret_cast<XrCompositionLayerSecureContentFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerSecureContentFB
        XrCompositionLayerSecureContentFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerSecureContentFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerSecureContentFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerSecureContentFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerSecureContentFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerSecureContentFB*>(this);
        }
        CompositionLayerSecureContentFlagsFB flags;
    };
     static_assert(sizeof(XrCompositionLayerSecureContentFB) == sizeof(CompositionLayerSecureContentFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerSecureContentFB pointer to const from a CompositionLayerSecureContentFB reference to const.
 * @relates CompositionLayerSecureContentFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerSecureContentFB const* get(CompositionLayerSecureContentFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerSecureContentFB as the address of a raw XrCompositionLayerSecureContentFB
 * @relates CompositionLayerSecureContentFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerSecureContentFB * put(CompositionLayerSecureContentFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_composition_layer_secure_content































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyJointLocationFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationFB>
 * @xrentity{XrBodyJointLocationFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS BodyJointLocationFB 
    {
    public:
        //! Constructor initializing all members.
                BodyJointLocationFB (
 const SpaceLocationFlags& locationFlags_,  const Posef& pose_                  )
: locationFlags {locationFlags_}
, pose {pose_}
        {
        }


        //! Default/empty constructor
                 BodyJointLocationFB (
            )

: locationFlags{}
, pose{}
            {}

        //! Default copy constructor
        BodyJointLocationFB(const BodyJointLocationFB& rhs) = default;
        //! Default copy assignment
        BodyJointLocationFB& operator=(const BodyJointLocationFB& rhs) = default;
        //! Copy construct from raw
        BodyJointLocationFB(const XrBodyJointLocationFB& rhs) : BodyJointLocationFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BodyJointLocationFB& operator=(const XrBodyJointLocationFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBodyJointLocationFB &() const { return *reinterpret_cast<const XrBodyJointLocationFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBodyJointLocationFB &() {
            return *reinterpret_cast<XrBodyJointLocationFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBodyJointLocationFB
        XrBodyJointLocationFB const* get() const noexcept { return reinterpret_cast<XrBodyJointLocationFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrBodyJointLocationFB * put(bool clear = true) noexcept {
            if (clear) {*this = BodyJointLocationFB{};}
            return reinterpret_cast<XrBodyJointLocationFB*>(this);
        }
        SpaceLocationFlags locationFlags;
        Posef pose;
    };
     static_assert(sizeof(XrBodyJointLocationFB) == sizeof(BodyJointLocationFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBodyJointLocationFB pointer to const from a BodyJointLocationFB reference to const.
 * @relates BodyJointLocationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyJointLocationFB const* get(BodyJointLocationFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationFB as the address of a raw XrBodyJointLocationFB
 * @relates BodyJointLocationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyJointLocationFB * put(BodyJointLocationFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrSystemBodyTrackingPropertiesFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemBodyTrackingPropertiesFB>
 * @xrentity{XrSystemBodyTrackingPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemBodyTrackingPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemBodyTrackingPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemBodyTrackingPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemBodyTrackingPropertiesFB(const SystemBodyTrackingPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemBodyTrackingPropertiesFB& operator=(const SystemBodyTrackingPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemBodyTrackingPropertiesFB(const XrSystemBodyTrackingPropertiesFB& rhs) : SystemBodyTrackingPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemBodyTrackingPropertiesFB& operator=(const XrSystemBodyTrackingPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemBodyTrackingPropertiesFB &() const { return *reinterpret_cast<const XrSystemBodyTrackingPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemBodyTrackingPropertiesFB &() {
            return *reinterpret_cast<XrSystemBodyTrackingPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemBodyTrackingPropertiesFB
        XrSystemBodyTrackingPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemBodyTrackingPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemBodyTrackingPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemBodyTrackingPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemBodyTrackingPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemBodyTrackingPropertiesFB*>(this);
        }
        Bool32 supportsBodyTracking;
    };
     static_assert(sizeof(XrSystemBodyTrackingPropertiesFB) == sizeof(SystemBodyTrackingPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemBodyTrackingPropertiesFB pointer to const from a SystemBodyTrackingPropertiesFB reference to const.
 * @relates SystemBodyTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesFB const* get(SystemBodyTrackingPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemBodyTrackingPropertiesFB as the address of a raw XrSystemBodyTrackingPropertiesFB
 * @relates SystemBodyTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesFB * put(SystemBodyTrackingPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyTrackerCreateInfoFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerCreateInfoFB>
 * @xrentity{XrBodyTrackerCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS BodyTrackerCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                BodyTrackerCreateInfoFB (
 const BodyJointSetFB& bodyJointSet_,  const void * next_ = nullptr                  )
: Parent(StructureType::BodyTrackerCreateInfoFB
, next_)
, bodyJointSet {bodyJointSet_}
        {
        }


        //! Default/empty constructor
                 BodyTrackerCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::BodyTrackerCreateInfoFB
             , next_)
, bodyJointSet{}
            {}

        //! Default copy constructor
        BodyTrackerCreateInfoFB(const BodyTrackerCreateInfoFB& rhs) = default;
        //! Default copy assignment
        BodyTrackerCreateInfoFB& operator=(const BodyTrackerCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        BodyTrackerCreateInfoFB(const XrBodyTrackerCreateInfoFB& rhs) : BodyTrackerCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BodyTrackerCreateInfoFB& operator=(const XrBodyTrackerCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBodyTrackerCreateInfoFB &() const { return *reinterpret_cast<const XrBodyTrackerCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBodyTrackerCreateInfoFB &() {
            return *reinterpret_cast<XrBodyTrackerCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBodyTrackerCreateInfoFB
        XrBodyTrackerCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrBodyTrackerCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBodyTrackerCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBodyTrackerCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = BodyTrackerCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrBodyTrackerCreateInfoFB*>(this);
        }
        BodyJointSetFB bodyJointSet;
    };
     static_assert(sizeof(XrBodyTrackerCreateInfoFB) == sizeof(BodyTrackerCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBodyTrackerCreateInfoFB pointer to const from a BodyTrackerCreateInfoFB reference to const.
 * @relates BodyTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoFB const* get(BodyTrackerCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyTrackerCreateInfoFB as the address of a raw XrBodyTrackerCreateInfoFB
 * @relates BodyTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoFB * put(BodyTrackerCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodySkeletonJointFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodySkeletonJointFB>
 * @xrentity{XrBodySkeletonJointFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS BodySkeletonJointFB 
    {
    public:
        //! Constructor initializing all members.
                BodySkeletonJointFB (
 int32_t joint_,  int32_t parentJoint_,  const Posef& pose_                  )
: joint {joint_}
, parentJoint {parentJoint_}
, pose {pose_}
        {
        }


        //! Default/empty constructor
                 BodySkeletonJointFB (
            )

: joint{0}
, parentJoint{0}
, pose{}
            {}

        //! Default copy constructor
        BodySkeletonJointFB(const BodySkeletonJointFB& rhs) = default;
        //! Default copy assignment
        BodySkeletonJointFB& operator=(const BodySkeletonJointFB& rhs) = default;
        //! Copy construct from raw
        BodySkeletonJointFB(const XrBodySkeletonJointFB& rhs) : BodySkeletonJointFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BodySkeletonJointFB& operator=(const XrBodySkeletonJointFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBodySkeletonJointFB &() const { return *reinterpret_cast<const XrBodySkeletonJointFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBodySkeletonJointFB &() {
            return *reinterpret_cast<XrBodySkeletonJointFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBodySkeletonJointFB
        XrBodySkeletonJointFB const* get() const noexcept { return reinterpret_cast<XrBodySkeletonJointFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBodySkeletonJointFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrBodySkeletonJointFB * put(bool clear = true) noexcept {
            if (clear) {*this = BodySkeletonJointFB{};}
            return reinterpret_cast<XrBodySkeletonJointFB*>(this);
        }
        int32_t joint;
        int32_t parentJoint;
        Posef pose;
    };
     static_assert(sizeof(XrBodySkeletonJointFB) == sizeof(BodySkeletonJointFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBodySkeletonJointFB pointer to const from a BodySkeletonJointFB reference to const.
 * @relates BodySkeletonJointFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodySkeletonJointFB const* get(BodySkeletonJointFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodySkeletonJointFB as the address of a raw XrBodySkeletonJointFB
 * @relates BodySkeletonJointFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodySkeletonJointFB * put(BodySkeletonJointFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodySkeletonFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodySkeletonFB>
 * @xrentity{XrBodySkeletonFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS BodySkeletonFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 BodySkeletonFB (
            void * next_ = nullptr)

: Parent(StructureType::BodySkeletonFB
             , next_)
            {}

        //! Default copy constructor
        BodySkeletonFB(const BodySkeletonFB& rhs) = default;
        //! Default copy assignment
        BodySkeletonFB& operator=(const BodySkeletonFB& rhs) = default;
        //! Copy construct from raw
        BodySkeletonFB(const XrBodySkeletonFB& rhs) : BodySkeletonFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BodySkeletonFB& operator=(const XrBodySkeletonFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBodySkeletonFB &() const { return *reinterpret_cast<const XrBodySkeletonFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBodySkeletonFB &() {
            return *reinterpret_cast<XrBodySkeletonFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBodySkeletonFB
        XrBodySkeletonFB const* get() const noexcept { return reinterpret_cast<XrBodySkeletonFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBodySkeletonFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBodySkeletonFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = BodySkeletonFB{};next = oldNext;}
            return reinterpret_cast<XrBodySkeletonFB*>(this);
        }
        uint32_t jointCount;
        BodySkeletonJointFB* joints;
    };
     static_assert(sizeof(XrBodySkeletonFB) == sizeof(BodySkeletonFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBodySkeletonFB pointer to const from a BodySkeletonFB reference to const.
 * @relates BodySkeletonFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodySkeletonFB const* get(BodySkeletonFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodySkeletonFB as the address of a raw XrBodySkeletonFB
 * @relates BodySkeletonFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodySkeletonFB * put(BodySkeletonFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyJointsLocateInfoFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointsLocateInfoFB>
 * @xrentity{XrBodyJointsLocateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS BodyJointsLocateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                BodyJointsLocateInfoFB (
 const Space& baseSpace_,  const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::BodyJointsLocateInfoFB
, next_)
, baseSpace {baseSpace_}
, time {time_}
        {
        }


        //! Default/empty constructor
                 BodyJointsLocateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::BodyJointsLocateInfoFB
             , next_)
, baseSpace{}
, time{}
            {}

        //! Default copy constructor
        BodyJointsLocateInfoFB(const BodyJointsLocateInfoFB& rhs) = default;
        //! Default copy assignment
        BodyJointsLocateInfoFB& operator=(const BodyJointsLocateInfoFB& rhs) = default;
        //! Copy construct from raw
        BodyJointsLocateInfoFB(const XrBodyJointsLocateInfoFB& rhs) : BodyJointsLocateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BodyJointsLocateInfoFB& operator=(const XrBodyJointsLocateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBodyJointsLocateInfoFB &() const { return *reinterpret_cast<const XrBodyJointsLocateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBodyJointsLocateInfoFB &() {
            return *reinterpret_cast<XrBodyJointsLocateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBodyJointsLocateInfoFB
        XrBodyJointsLocateInfoFB const* get() const noexcept { return reinterpret_cast<XrBodyJointsLocateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointsLocateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBodyJointsLocateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = BodyJointsLocateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrBodyJointsLocateInfoFB*>(this);
        }
        Space baseSpace;
        Time time;
    };
     static_assert(sizeof(XrBodyJointsLocateInfoFB) == sizeof(BodyJointsLocateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBodyJointsLocateInfoFB pointer to const from a BodyJointsLocateInfoFB reference to const.
 * @relates BodyJointsLocateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyJointsLocateInfoFB const* get(BodyJointsLocateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointsLocateInfoFB as the address of a raw XrBodyJointsLocateInfoFB
 * @relates BodyJointsLocateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyJointsLocateInfoFB * put(BodyJointsLocateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyJointLocationsFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationsFB>
 * @xrentity{XrBodyJointLocationsFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS BodyJointLocationsFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 BodyJointLocationsFB (
            void * next_ = nullptr)

: Parent(StructureType::BodyJointLocationsFB
             , next_)
            {}

        //! Default copy constructor
        BodyJointLocationsFB(const BodyJointLocationsFB& rhs) = default;
        //! Default copy assignment
        BodyJointLocationsFB& operator=(const BodyJointLocationsFB& rhs) = default;
        //! Copy construct from raw
        BodyJointLocationsFB(const XrBodyJointLocationsFB& rhs) : BodyJointLocationsFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        BodyJointLocationsFB& operator=(const XrBodyJointLocationsFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBodyJointLocationsFB &() const { return *reinterpret_cast<const XrBodyJointLocationsFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBodyJointLocationsFB &() {
            return *reinterpret_cast<XrBodyJointLocationsFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBodyJointLocationsFB
        XrBodyJointLocationsFB const* get() const noexcept { return reinterpret_cast<XrBodyJointLocationsFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationsFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBodyJointLocationsFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = BodyJointLocationsFB{};next = oldNext;}
            return reinterpret_cast<XrBodyJointLocationsFB*>(this);
        }
        Bool32 isActive;
        float confidence;
        uint32_t jointCount;
        BodyJointLocationFB* jointLocations;
        uint32_t skeletonChangedCount;
        Time time;
    };
     static_assert(sizeof(XrBodyJointLocationsFB) == sizeof(BodyJointLocationsFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBodyJointLocationsFB pointer to const from a BodyJointLocationsFB reference to const.
 * @relates BodyJointLocationsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyJointLocationsFB const* get(BodyJointLocationsFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationsFB as the address of a raw XrBodyJointLocationsFB
 * @relates BodyJointLocationsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBodyJointLocationsFB * put(BodyJointLocationsFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_body_tracking































    #ifdef XR_EXT_dpad_binding
/*!
 * C++ projection of XrInteractionProfileDpadBindingEXT
 * 
 * Provided by the `XR_EXT_dpad_binding` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileDpadBindingEXT>
 * @xrentity{XrInteractionProfileDpadBindingEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InteractionProfileDpadBindingEXT : public BindingModificationBaseHeaderKHR
    {
    private:
        using Parent = BindingModificationBaseHeaderKHR;
    public:
        //! Constructor initializing all members.
                InteractionProfileDpadBindingEXT (
 const Path& binding_,  const ActionSet& actionSet_,  float forceThreshold_,  float forceThresholdReleased_,  float centerRegion_,  float wedgeAngle_,  const Bool32& isSticky_,  const HapticBaseHeader* onHaptic_,  const HapticBaseHeader* offHaptic_,  const void * next_ = nullptr                  )
: Parent(StructureType::InteractionProfileDpadBindingEXT
, next_)
, binding {binding_}
, actionSet {actionSet_}
, forceThreshold {forceThreshold_}
, forceThresholdReleased {forceThresholdReleased_}
, centerRegion {centerRegion_}
, wedgeAngle {wedgeAngle_}
, isSticky {isSticky_}
, onHaptic {onHaptic_}
, offHaptic {offHaptic_}
        {
        }


        //! Default/empty constructor
                 InteractionProfileDpadBindingEXT (
            const void * next_ = nullptr)

: Parent(StructureType::InteractionProfileDpadBindingEXT
             , next_)
, binding{}
, actionSet{}
, forceThreshold{0.0f}
, forceThresholdReleased{0.0f}
, centerRegion{0.0f}
, wedgeAngle{0.0f}
, isSticky{false}
, onHaptic{nullptr}
, offHaptic{nullptr}
            {}

        //! Default copy constructor
        InteractionProfileDpadBindingEXT(const InteractionProfileDpadBindingEXT& rhs) = default;
        //! Default copy assignment
        InteractionProfileDpadBindingEXT& operator=(const InteractionProfileDpadBindingEXT& rhs) = default;
        //! Copy construct from raw
        InteractionProfileDpadBindingEXT(const XrInteractionProfileDpadBindingEXT& rhs) : InteractionProfileDpadBindingEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InteractionProfileDpadBindingEXT& operator=(const XrInteractionProfileDpadBindingEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInteractionProfileDpadBindingEXT &() const { return *reinterpret_cast<const XrInteractionProfileDpadBindingEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInteractionProfileDpadBindingEXT &() {
            return *reinterpret_cast<XrInteractionProfileDpadBindingEXT*>(this);
        }

        //! Accessor for this as a raw, base XrBindingModificationBaseHeaderKHR const pointer
        XrBindingModificationBaseHeaderKHR const* get_base() const noexcept {
            return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
        }
        //! Accessor for this as the address of a raw XrInteractionProfileDpadBindingEXT
        XrInteractionProfileDpadBindingEXT const* get() const noexcept { return reinterpret_cast<XrInteractionProfileDpadBindingEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInteractionProfileDpadBindingEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInteractionProfileDpadBindingEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InteractionProfileDpadBindingEXT{};next = oldNext;}
            return reinterpret_cast<XrInteractionProfileDpadBindingEXT*>(this);
        }
        Path binding;
        ActionSet actionSet;
        float forceThreshold;
        float forceThresholdReleased;
        float centerRegion;
        float wedgeAngle;
        Bool32 isSticky;
        const HapticBaseHeader* onHaptic;
        const HapticBaseHeader* offHaptic;
    };
     static_assert(sizeof(XrInteractionProfileDpadBindingEXT) == sizeof(InteractionProfileDpadBindingEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInteractionProfileDpadBindingEXT pointer to const from a InteractionProfileDpadBindingEXT reference to const.
 * @relates InteractionProfileDpadBindingEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileDpadBindingEXT const* get(InteractionProfileDpadBindingEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileDpadBindingEXT as the address of a raw XrInteractionProfileDpadBindingEXT
 * @relates InteractionProfileDpadBindingEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileDpadBindingEXT * put(InteractionProfileDpadBindingEXT &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const InteractionProfileDpadBindingEXT as a raw, pointer to const XrBindingModificationBaseHeaderKHR (the base type)
 * @relates InteractionProfileDpadBindingEXT
 * @relatesalso BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get_base(InteractionProfileDpadBindingEXT const& h) {
        return h.get_base();
    }
#endif  // XR_EXT_dpad_binding































    #ifdef XR_VALVE_analog_threshold
/*!
 * C++ projection of XrInteractionProfileAnalogThresholdVALVE
 * 
 * Provided by the `XR_VALVE_analog_threshold` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileAnalogThresholdVALVE>
 * @xrentity{XrInteractionProfileAnalogThresholdVALVE}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS InteractionProfileAnalogThresholdVALVE : public BindingModificationBaseHeaderKHR
    {
    private:
        using Parent = BindingModificationBaseHeaderKHR;
    public:
        //! Constructor initializing all members.
                InteractionProfileAnalogThresholdVALVE (
 const Action& action_,  const Path& binding_,  float onThreshold_,  float offThreshold_,  const HapticBaseHeader* onHaptic_,  const HapticBaseHeader* offHaptic_,  const void * next_ = nullptr                  )
: Parent(StructureType::InteractionProfileAnalogThresholdVALVE
, next_)
, action {action_}
, binding {binding_}
, onThreshold {onThreshold_}
, offThreshold {offThreshold_}
, onHaptic {onHaptic_}
, offHaptic {offHaptic_}
        {
        }


        //! Default/empty constructor
                 InteractionProfileAnalogThresholdVALVE (
            const void * next_ = nullptr)

: Parent(StructureType::InteractionProfileAnalogThresholdVALVE
             , next_)
, action{}
, binding{}
, onThreshold{0.0f}
, offThreshold{0.0f}
, onHaptic{nullptr}
, offHaptic{nullptr}
            {}

        //! Default copy constructor
        InteractionProfileAnalogThresholdVALVE(const InteractionProfileAnalogThresholdVALVE& rhs) = default;
        //! Default copy assignment
        InteractionProfileAnalogThresholdVALVE& operator=(const InteractionProfileAnalogThresholdVALVE& rhs) = default;
        //! Copy construct from raw
        InteractionProfileAnalogThresholdVALVE(const XrInteractionProfileAnalogThresholdVALVE& rhs) : InteractionProfileAnalogThresholdVALVE() {
            *put() = rhs;
        }
        //! Copy assign from raw
        InteractionProfileAnalogThresholdVALVE& operator=(const XrInteractionProfileAnalogThresholdVALVE& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrInteractionProfileAnalogThresholdVALVE &() const { return *reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrInteractionProfileAnalogThresholdVALVE &() {
            return *reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
        }

        //! Accessor for this as a raw, base XrBindingModificationBaseHeaderKHR const pointer
        XrBindingModificationBaseHeaderKHR const* get_base() const noexcept {
            return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
        }
        //! Accessor for this as the address of a raw XrInteractionProfileAnalogThresholdVALVE
        XrInteractionProfileAnalogThresholdVALVE const* get() const noexcept { return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrInteractionProfileAnalogThresholdVALVE.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrInteractionProfileAnalogThresholdVALVE * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = InteractionProfileAnalogThresholdVALVE{};next = oldNext;}
            return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
        }
        Action action;
        Path binding;
        float onThreshold;
        float offThreshold;
        const HapticBaseHeader* onHaptic;
        const HapticBaseHeader* offHaptic;
    };
     static_assert(sizeof(XrInteractionProfileAnalogThresholdVALVE) == sizeof(InteractionProfileAnalogThresholdVALVE), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrInteractionProfileAnalogThresholdVALVE pointer to const from a InteractionProfileAnalogThresholdVALVE reference to const.
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE const* get(InteractionProfileAnalogThresholdVALVE const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileAnalogThresholdVALVE as the address of a raw XrInteractionProfileAnalogThresholdVALVE
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE * put(InteractionProfileAnalogThresholdVALVE &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const InteractionProfileAnalogThresholdVALVE as a raw, pointer to const XrBindingModificationBaseHeaderKHR (the base type)
 * @relates InteractionProfileAnalogThresholdVALVE
 * @relatesalso BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get_base(InteractionProfileAnalogThresholdVALVE const& h) {
        return h.get_base();
    }
#endif  // XR_VALVE_analog_threshold































    #ifdef XR_EXT_hand_joints_motion_range
/*!
 * C++ projection of XrHandJointsMotionRangeInfoEXT
 * 
 * Provided by the `XR_EXT_hand_joints_motion_range` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsMotionRangeInfoEXT>
 * @xrentity{XrHandJointsMotionRangeInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandJointsMotionRangeInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandJointsMotionRangeInfoEXT (
 const HandJointsMotionRangeEXT& handJointsMotionRange_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandJointsMotionRangeInfoEXT
, next_)
, handJointsMotionRange {handJointsMotionRange_}
        {
        }


        //! Default/empty constructor
                 HandJointsMotionRangeInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::HandJointsMotionRangeInfoEXT
             , next_)
, handJointsMotionRange{}
            {}

        //! Default copy constructor
        HandJointsMotionRangeInfoEXT(const HandJointsMotionRangeInfoEXT& rhs) = default;
        //! Default copy assignment
        HandJointsMotionRangeInfoEXT& operator=(const HandJointsMotionRangeInfoEXT& rhs) = default;
        //! Copy construct from raw
        HandJointsMotionRangeInfoEXT(const XrHandJointsMotionRangeInfoEXT& rhs) : HandJointsMotionRangeInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandJointsMotionRangeInfoEXT& operator=(const XrHandJointsMotionRangeInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandJointsMotionRangeInfoEXT &() const { return *reinterpret_cast<const XrHandJointsMotionRangeInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandJointsMotionRangeInfoEXT &() {
            return *reinterpret_cast<XrHandJointsMotionRangeInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandJointsMotionRangeInfoEXT
        XrHandJointsMotionRangeInfoEXT const* get() const noexcept { return reinterpret_cast<XrHandJointsMotionRangeInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandJointsMotionRangeInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandJointsMotionRangeInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandJointsMotionRangeInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrHandJointsMotionRangeInfoEXT*>(this);
        }
        HandJointsMotionRangeEXT handJointsMotionRange;
    };
     static_assert(sizeof(XrHandJointsMotionRangeInfoEXT) == sizeof(HandJointsMotionRangeInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandJointsMotionRangeInfoEXT pointer to const from a HandJointsMotionRangeInfoEXT reference to const.
 * @relates HandJointsMotionRangeInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointsMotionRangeInfoEXT const* get(HandJointsMotionRangeInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsMotionRangeInfoEXT as the address of a raw XrHandJointsMotionRangeInfoEXT
 * @relates HandJointsMotionRangeInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandJointsMotionRangeInfoEXT * put(HandJointsMotionRangeInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_joints_motion_range































    #ifdef XR_FB_display_refresh_rate
/*!
 * C++ projection of XrEventDataDisplayRefreshRateChangedFB
 * 
 * Provided by the `XR_FB_display_refresh_rate` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataDisplayRefreshRateChangedFB>
 * @xrentity{XrEventDataDisplayRefreshRateChangedFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataDisplayRefreshRateChangedFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataDisplayRefreshRateChangedFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataDisplayRefreshRateChangedFB
             , next_)
            {}

        //! Default copy constructor
        EventDataDisplayRefreshRateChangedFB(const EventDataDisplayRefreshRateChangedFB& rhs) = default;
        //! Default copy assignment
        EventDataDisplayRefreshRateChangedFB& operator=(const EventDataDisplayRefreshRateChangedFB& rhs) = default;
        //! Copy construct from raw
        EventDataDisplayRefreshRateChangedFB(const XrEventDataDisplayRefreshRateChangedFB& rhs) : EventDataDisplayRefreshRateChangedFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataDisplayRefreshRateChangedFB& operator=(const XrEventDataDisplayRefreshRateChangedFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataDisplayRefreshRateChangedFB &() const { return *reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataDisplayRefreshRateChangedFB &() {
            return *reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataDisplayRefreshRateChangedFB
        XrEventDataDisplayRefreshRateChangedFB const* get() const noexcept { return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataDisplayRefreshRateChangedFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataDisplayRefreshRateChangedFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataDisplayRefreshRateChangedFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
        }
        float fromDisplayRefreshRate;
        float toDisplayRefreshRate;
    };
     static_assert(sizeof(XrEventDataDisplayRefreshRateChangedFB) == sizeof(EventDataDisplayRefreshRateChangedFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataDisplayRefreshRateChangedFB pointer to const from a EventDataDisplayRefreshRateChangedFB reference to const.
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB const* get(EventDataDisplayRefreshRateChangedFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataDisplayRefreshRateChangedFB as the address of a raw XrEventDataDisplayRefreshRateChangedFB
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB * put(EventDataDisplayRefreshRateChangedFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataDisplayRefreshRateChangedFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataDisplayRefreshRateChangedFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataDisplayRefreshRateChangedFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_display_refresh_rate































    #ifdef XR_HTCX_vive_tracker_interaction
/*!
 * C++ projection of XrViveTrackerPathsHTCX
 * 
 * Provided by the `XR_HTCX_vive_tracker_interaction` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViveTrackerPathsHTCX>
 * @xrentity{XrViveTrackerPathsHTCX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViveTrackerPathsHTCX : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ViveTrackerPathsHTCX (
            void * next_ = nullptr)

: Parent(StructureType::ViveTrackerPathsHTCX
             , next_)
            {}

        //! Default copy constructor
        ViveTrackerPathsHTCX(const ViveTrackerPathsHTCX& rhs) = default;
        //! Default copy assignment
        ViveTrackerPathsHTCX& operator=(const ViveTrackerPathsHTCX& rhs) = default;
        //! Copy construct from raw
        ViveTrackerPathsHTCX(const XrViveTrackerPathsHTCX& rhs) : ViveTrackerPathsHTCX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViveTrackerPathsHTCX& operator=(const XrViveTrackerPathsHTCX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViveTrackerPathsHTCX &() const { return *reinterpret_cast<const XrViveTrackerPathsHTCX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViveTrackerPathsHTCX &() {
            return *reinterpret_cast<XrViveTrackerPathsHTCX*>(this);
        }

        //! Accessor for this as the address of a raw XrViveTrackerPathsHTCX
        XrViveTrackerPathsHTCX const* get() const noexcept { return reinterpret_cast<XrViveTrackerPathsHTCX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViveTrackerPathsHTCX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViveTrackerPathsHTCX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViveTrackerPathsHTCX{};next = oldNext;}
            return reinterpret_cast<XrViveTrackerPathsHTCX*>(this);
        }
        Path persistentPath;
        Path rolePath;
    };
     static_assert(sizeof(XrViveTrackerPathsHTCX) == sizeof(ViveTrackerPathsHTCX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViveTrackerPathsHTCX pointer to const from a ViveTrackerPathsHTCX reference to const.
 * @relates ViveTrackerPathsHTCX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViveTrackerPathsHTCX const* get(ViveTrackerPathsHTCX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViveTrackerPathsHTCX as the address of a raw XrViveTrackerPathsHTCX
 * @relates ViveTrackerPathsHTCX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViveTrackerPathsHTCX * put(ViveTrackerPathsHTCX &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTCX_vive_tracker_interaction































    #ifdef XR_HTCX_vive_tracker_interaction
/*!
 * C++ projection of XrEventDataViveTrackerConnectedHTCX
 * 
 * Provided by the `XR_HTCX_vive_tracker_interaction` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataViveTrackerConnectedHTCX>
 * @xrentity{XrEventDataViveTrackerConnectedHTCX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataViveTrackerConnectedHTCX : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataViveTrackerConnectedHTCX (
            void * next_ = nullptr)

: Parent(StructureType::EventDataViveTrackerConnectedHTCX
             , next_)
            {}

        //! Default copy constructor
        EventDataViveTrackerConnectedHTCX(const EventDataViveTrackerConnectedHTCX& rhs) = default;
        //! Default copy assignment
        EventDataViveTrackerConnectedHTCX& operator=(const EventDataViveTrackerConnectedHTCX& rhs) = default;
        //! Copy construct from raw
        EventDataViveTrackerConnectedHTCX(const XrEventDataViveTrackerConnectedHTCX& rhs) : EventDataViveTrackerConnectedHTCX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataViveTrackerConnectedHTCX& operator=(const XrEventDataViveTrackerConnectedHTCX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataViveTrackerConnectedHTCX &() const { return *reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataViveTrackerConnectedHTCX &() {
            return *reinterpret_cast<XrEventDataViveTrackerConnectedHTCX*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataViveTrackerConnectedHTCX
        XrEventDataViveTrackerConnectedHTCX const* get() const noexcept { return reinterpret_cast<XrEventDataViveTrackerConnectedHTCX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataViveTrackerConnectedHTCX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataViveTrackerConnectedHTCX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataViveTrackerConnectedHTCX{};next = oldNext;}
            return reinterpret_cast<XrEventDataViveTrackerConnectedHTCX*>(this);
        }
        ViveTrackerPathsHTCX* paths;
    };
     static_assert(sizeof(XrEventDataViveTrackerConnectedHTCX) == sizeof(EventDataViveTrackerConnectedHTCX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataViveTrackerConnectedHTCX pointer to const from a EventDataViveTrackerConnectedHTCX reference to const.
 * @relates EventDataViveTrackerConnectedHTCX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataViveTrackerConnectedHTCX const* get(EventDataViveTrackerConnectedHTCX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataViveTrackerConnectedHTCX as the address of a raw XrEventDataViveTrackerConnectedHTCX
 * @relates EventDataViveTrackerConnectedHTCX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataViveTrackerConnectedHTCX * put(EventDataViveTrackerConnectedHTCX &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataViveTrackerConnectedHTCX as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataViveTrackerConnectedHTCX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataViveTrackerConnectedHTCX const& h) {
        return h.get_base();
    }
#endif  // XR_HTCX_vive_tracker_interaction































    #ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrSystemFacialTrackingPropertiesHTC
 * 
 * Provided by the `XR_HTC_facial_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFacialTrackingPropertiesHTC>
 * @xrentity{XrSystemFacialTrackingPropertiesHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemFacialTrackingPropertiesHTC : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemFacialTrackingPropertiesHTC (
            void * next_ = nullptr)

: Parent(StructureType::SystemFacialTrackingPropertiesHTC
             , next_)
            {}

        //! Default copy constructor
        SystemFacialTrackingPropertiesHTC(const SystemFacialTrackingPropertiesHTC& rhs) = default;
        //! Default copy assignment
        SystemFacialTrackingPropertiesHTC& operator=(const SystemFacialTrackingPropertiesHTC& rhs) = default;
        //! Copy construct from raw
        SystemFacialTrackingPropertiesHTC(const XrSystemFacialTrackingPropertiesHTC& rhs) : SystemFacialTrackingPropertiesHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemFacialTrackingPropertiesHTC& operator=(const XrSystemFacialTrackingPropertiesHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemFacialTrackingPropertiesHTC &() const { return *reinterpret_cast<const XrSystemFacialTrackingPropertiesHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemFacialTrackingPropertiesHTC &() {
            return *reinterpret_cast<XrSystemFacialTrackingPropertiesHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemFacialTrackingPropertiesHTC
        XrSystemFacialTrackingPropertiesHTC const* get() const noexcept { return reinterpret_cast<XrSystemFacialTrackingPropertiesHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemFacialTrackingPropertiesHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemFacialTrackingPropertiesHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemFacialTrackingPropertiesHTC{};next = oldNext;}
            return reinterpret_cast<XrSystemFacialTrackingPropertiesHTC*>(this);
        }
        Bool32 supportEyeFacialTracking;
        Bool32 supportLipFacialTracking;
    };
     static_assert(sizeof(XrSystemFacialTrackingPropertiesHTC) == sizeof(SystemFacialTrackingPropertiesHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemFacialTrackingPropertiesHTC pointer to const from a SystemFacialTrackingPropertiesHTC reference to const.
 * @relates SystemFacialTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFacialTrackingPropertiesHTC const* get(SystemFacialTrackingPropertiesHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemFacialTrackingPropertiesHTC as the address of a raw XrSystemFacialTrackingPropertiesHTC
 * @relates SystemFacialTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFacialTrackingPropertiesHTC * put(SystemFacialTrackingPropertiesHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_facial_tracking































    #ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrFacialExpressionsHTC
 * 
 * Provided by the `XR_HTC_facial_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionsHTC>
 * @xrentity{XrFacialExpressionsHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FacialExpressionsHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FacialExpressionsHTC (
 const Bool32& isActive_,  const Time& sampleTime_,  uint32_t expressionCount_,  float* expressionWeightings_,  const void * next_ = nullptr                  )
: Parent(StructureType::FacialExpressionsHTC
, next_)
, isActive {isActive_}
, sampleTime {sampleTime_}
, expressionCount {expressionCount_}
, expressionWeightings {expressionWeightings_}
        {
        }


        //! Default/empty constructor
                 FacialExpressionsHTC (
            const void * next_ = nullptr)

: Parent(StructureType::FacialExpressionsHTC
             , next_)
, isActive{false}
, sampleTime{}
, expressionCount{0}
, expressionWeightings{nullptr}
            {}

        //! Default copy constructor
        FacialExpressionsHTC(const FacialExpressionsHTC& rhs) = default;
        //! Default copy assignment
        FacialExpressionsHTC& operator=(const FacialExpressionsHTC& rhs) = default;
        //! Copy construct from raw
        FacialExpressionsHTC(const XrFacialExpressionsHTC& rhs) : FacialExpressionsHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FacialExpressionsHTC& operator=(const XrFacialExpressionsHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFacialExpressionsHTC &() const { return *reinterpret_cast<const XrFacialExpressionsHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFacialExpressionsHTC &() {
            return *reinterpret_cast<XrFacialExpressionsHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrFacialExpressionsHTC
        XrFacialExpressionsHTC const* get() const noexcept { return reinterpret_cast<XrFacialExpressionsHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFacialExpressionsHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFacialExpressionsHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FacialExpressionsHTC{};next = oldNext;}
            return reinterpret_cast<XrFacialExpressionsHTC*>(this);
        }
        Bool32 isActive;
        Time sampleTime;
        uint32_t expressionCount;
        float* expressionWeightings;
    };
     static_assert(sizeof(XrFacialExpressionsHTC) == sizeof(FacialExpressionsHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFacialExpressionsHTC pointer to const from a FacialExpressionsHTC reference to const.
 * @relates FacialExpressionsHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFacialExpressionsHTC const* get(FacialExpressionsHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FacialExpressionsHTC as the address of a raw XrFacialExpressionsHTC
 * @relates FacialExpressionsHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFacialExpressionsHTC * put(FacialExpressionsHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_facial_tracking































    #ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrFacialTrackerCreateInfoHTC
 * 
 * Provided by the `XR_HTC_facial_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackerCreateInfoHTC>
 * @xrentity{XrFacialTrackerCreateInfoHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FacialTrackerCreateInfoHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FacialTrackerCreateInfoHTC (
 const FacialTrackingTypeHTC& facialTrackingType_,  const void * next_ = nullptr                  )
: Parent(StructureType::FacialTrackerCreateInfoHTC
, next_)
, facialTrackingType {facialTrackingType_}
        {
        }


        //! Default/empty constructor
                 FacialTrackerCreateInfoHTC (
            const void * next_ = nullptr)

: Parent(StructureType::FacialTrackerCreateInfoHTC
             , next_)
, facialTrackingType{}
            {}

        //! Default copy constructor
        FacialTrackerCreateInfoHTC(const FacialTrackerCreateInfoHTC& rhs) = default;
        //! Default copy assignment
        FacialTrackerCreateInfoHTC& operator=(const FacialTrackerCreateInfoHTC& rhs) = default;
        //! Copy construct from raw
        FacialTrackerCreateInfoHTC(const XrFacialTrackerCreateInfoHTC& rhs) : FacialTrackerCreateInfoHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FacialTrackerCreateInfoHTC& operator=(const XrFacialTrackerCreateInfoHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFacialTrackerCreateInfoHTC &() const { return *reinterpret_cast<const XrFacialTrackerCreateInfoHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFacialTrackerCreateInfoHTC &() {
            return *reinterpret_cast<XrFacialTrackerCreateInfoHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrFacialTrackerCreateInfoHTC
        XrFacialTrackerCreateInfoHTC const* get() const noexcept { return reinterpret_cast<XrFacialTrackerCreateInfoHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFacialTrackerCreateInfoHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFacialTrackerCreateInfoHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FacialTrackerCreateInfoHTC{};next = oldNext;}
            return reinterpret_cast<XrFacialTrackerCreateInfoHTC*>(this);
        }
        FacialTrackingTypeHTC facialTrackingType;
    };
     static_assert(sizeof(XrFacialTrackerCreateInfoHTC) == sizeof(FacialTrackerCreateInfoHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFacialTrackerCreateInfoHTC pointer to const from a FacialTrackerCreateInfoHTC reference to const.
 * @relates FacialTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFacialTrackerCreateInfoHTC const* get(FacialTrackerCreateInfoHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FacialTrackerCreateInfoHTC as the address of a raw XrFacialTrackerCreateInfoHTC
 * @relates FacialTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFacialTrackerCreateInfoHTC * put(FacialTrackerCreateInfoHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_facial_tracking































    #ifdef XR_FB_color_space
/*!
 * C++ projection of XrSystemColorSpacePropertiesFB
 * 
 * Provided by the `XR_FB_color_space` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemColorSpacePropertiesFB>
 * @xrentity{XrSystemColorSpacePropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemColorSpacePropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemColorSpacePropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemColorSpacePropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemColorSpacePropertiesFB(const SystemColorSpacePropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemColorSpacePropertiesFB& operator=(const SystemColorSpacePropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemColorSpacePropertiesFB(const XrSystemColorSpacePropertiesFB& rhs) : SystemColorSpacePropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemColorSpacePropertiesFB& operator=(const XrSystemColorSpacePropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemColorSpacePropertiesFB &() const { return *reinterpret_cast<const XrSystemColorSpacePropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemColorSpacePropertiesFB &() {
            return *reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemColorSpacePropertiesFB
        XrSystemColorSpacePropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemColorSpacePropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemColorSpacePropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemColorSpacePropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemColorSpacePropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
        }
        ColorSpaceFB colorSpace;
    };
     static_assert(sizeof(XrSystemColorSpacePropertiesFB) == sizeof(SystemColorSpacePropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemColorSpacePropertiesFB pointer to const from a SystemColorSpacePropertiesFB reference to const.
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB const* get(SystemColorSpacePropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemColorSpacePropertiesFB as the address of a raw XrSystemColorSpacePropertiesFB
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB * put(SystemColorSpacePropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_color_space































    #ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrVector4sFB
 * 
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4sFB>
 * @xrentity{XrVector4sFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Vector4sFB 
    {
    public:
        //! Constructor initializing all members.
                Vector4sFB (
 int16_t x_,  int16_t y_,  int16_t z_,  int16_t w_                  )
: x {x_}
, y {y_}
, z {z_}
, w {w_}
        {
        }


        //! Default/empty constructor
                 Vector4sFB (
            )

: x{0}
, y{0}
, z{0}
, w{0}
            {}

        //! Default copy constructor
        Vector4sFB(const Vector4sFB& rhs) = default;
        //! Default copy assignment
        Vector4sFB& operator=(const Vector4sFB& rhs) = default;
        //! Copy construct from raw
        Vector4sFB(const XrVector4sFB& rhs) : Vector4sFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Vector4sFB& operator=(const XrVector4sFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVector4sFB &() const { return *reinterpret_cast<const XrVector4sFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVector4sFB &() {
            return *reinterpret_cast<XrVector4sFB*>(this);
        }

        //! Accessor for this as the address of a raw XrVector4sFB
        XrVector4sFB const* get() const noexcept { return reinterpret_cast<XrVector4sFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVector4sFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrVector4sFB * put(bool clear = true) noexcept {
            if (clear) {*this = Vector4sFB{};}
            return reinterpret_cast<XrVector4sFB*>(this);
        }
        int16_t x;
        int16_t y;
        int16_t z;
        int16_t w;
    };
     static_assert(sizeof(XrVector4sFB) == sizeof(Vector4sFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVector4sFB pointer to const from a Vector4sFB reference to const.
 * @relates Vector4sFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector4sFB const* get(Vector4sFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4sFB as the address of a raw XrVector4sFB
 * @relates Vector4sFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVector4sFB * put(Vector4sFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_hand_tracking_mesh































    #ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrHandTrackingMeshFB
 * 
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingMeshFB>
 * @xrentity{XrHandTrackingMeshFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackingMeshFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandTrackingMeshFB (
            void * next_ = nullptr)

: Parent(StructureType::HandTrackingMeshFB
             , next_)
            {}

        //! Default copy constructor
        HandTrackingMeshFB(const HandTrackingMeshFB& rhs) = default;
        //! Default copy assignment
        HandTrackingMeshFB& operator=(const HandTrackingMeshFB& rhs) = default;
        //! Copy construct from raw
        HandTrackingMeshFB(const XrHandTrackingMeshFB& rhs) : HandTrackingMeshFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackingMeshFB& operator=(const XrHandTrackingMeshFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackingMeshFB &() const { return *reinterpret_cast<const XrHandTrackingMeshFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackingMeshFB &() {
            return *reinterpret_cast<XrHandTrackingMeshFB*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackingMeshFB
        XrHandTrackingMeshFB const* get() const noexcept { return reinterpret_cast<XrHandTrackingMeshFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingMeshFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackingMeshFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackingMeshFB{};next = oldNext;}
            return reinterpret_cast<XrHandTrackingMeshFB*>(this);
        }
        uint32_t jointCapacityInput;
        uint32_t jointCountOutput;
        Posef* jointBindPoses;
        float* jointRadii;
        HandJointEXT* jointParents;
        uint32_t vertexCapacityInput;
        uint32_t vertexCountOutput;
        Vector3f* vertexPositions;
        Vector3f* vertexNormals;
        Vector2f* vertexUVs;
        Vector4sFB* vertexBlendIndices;
        Vector4f* vertexBlendWeights;
        uint32_t indexCapacityInput;
        uint32_t indexCountOutput;
        int16_t* indices;
    };
     static_assert(sizeof(XrHandTrackingMeshFB) == sizeof(HandTrackingMeshFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackingMeshFB pointer to const from a HandTrackingMeshFB reference to const.
 * @relates HandTrackingMeshFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingMeshFB const* get(HandTrackingMeshFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingMeshFB as the address of a raw XrHandTrackingMeshFB
 * @relates HandTrackingMeshFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingMeshFB * put(HandTrackingMeshFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_hand_tracking_mesh































    #ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrHandTrackingScaleFB
 * 
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingScaleFB>
 * @xrentity{XrHandTrackingScaleFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackingScaleFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandTrackingScaleFB (
            void * next_ = nullptr)

: Parent(StructureType::HandTrackingScaleFB
             , next_)
            {}

        //! Default copy constructor
        HandTrackingScaleFB(const HandTrackingScaleFB& rhs) = default;
        //! Default copy assignment
        HandTrackingScaleFB& operator=(const HandTrackingScaleFB& rhs) = default;
        //! Copy construct from raw
        HandTrackingScaleFB(const XrHandTrackingScaleFB& rhs) : HandTrackingScaleFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackingScaleFB& operator=(const XrHandTrackingScaleFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackingScaleFB &() const { return *reinterpret_cast<const XrHandTrackingScaleFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackingScaleFB &() {
            return *reinterpret_cast<XrHandTrackingScaleFB*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackingScaleFB
        XrHandTrackingScaleFB const* get() const noexcept { return reinterpret_cast<XrHandTrackingScaleFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingScaleFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackingScaleFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackingScaleFB{};next = oldNext;}
            return reinterpret_cast<XrHandTrackingScaleFB*>(this);
        }
        float sensorOutput;
        float currentOutput;
        Bool32 overrideHandScale;
        float overrideValueInput;
    };
     static_assert(sizeof(XrHandTrackingScaleFB) == sizeof(HandTrackingScaleFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackingScaleFB pointer to const from a HandTrackingScaleFB reference to const.
 * @relates HandTrackingScaleFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingScaleFB const* get(HandTrackingScaleFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingScaleFB as the address of a raw XrHandTrackingScaleFB
 * @relates HandTrackingScaleFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingScaleFB * put(HandTrackingScaleFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_hand_tracking_mesh































    #ifdef XR_FB_hand_tracking_aim
/*!
 * C++ projection of XrHandTrackingAimStateFB
 * 
 * Provided by the `XR_FB_hand_tracking_aim` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingAimStateFB>
 * @xrentity{XrHandTrackingAimStateFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackingAimStateFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandTrackingAimStateFB (
            void * next_ = nullptr)

: Parent(StructureType::HandTrackingAimStateFB
             , next_)
            {}

        //! Default copy constructor
        HandTrackingAimStateFB(const HandTrackingAimStateFB& rhs) = default;
        //! Default copy assignment
        HandTrackingAimStateFB& operator=(const HandTrackingAimStateFB& rhs) = default;
        //! Copy construct from raw
        HandTrackingAimStateFB(const XrHandTrackingAimStateFB& rhs) : HandTrackingAimStateFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackingAimStateFB& operator=(const XrHandTrackingAimStateFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackingAimStateFB &() const { return *reinterpret_cast<const XrHandTrackingAimStateFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackingAimStateFB &() {
            return *reinterpret_cast<XrHandTrackingAimStateFB*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackingAimStateFB
        XrHandTrackingAimStateFB const* get() const noexcept { return reinterpret_cast<XrHandTrackingAimStateFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingAimStateFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackingAimStateFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackingAimStateFB{};next = oldNext;}
            return reinterpret_cast<XrHandTrackingAimStateFB*>(this);
        }
        HandTrackingAimFlagsFB status;
        Posef aimPose;
        float pinchStrengthIndex;
        float pinchStrengthMiddle;
        float pinchStrengthRing;
        float pinchStrengthLittle;
    };
     static_assert(sizeof(XrHandTrackingAimStateFB) == sizeof(HandTrackingAimStateFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackingAimStateFB pointer to const from a HandTrackingAimStateFB reference to const.
 * @relates HandTrackingAimStateFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingAimStateFB const* get(HandTrackingAimStateFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingAimStateFB as the address of a raw XrHandTrackingAimStateFB
 * @relates HandTrackingAimStateFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingAimStateFB * put(HandTrackingAimStateFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_hand_tracking_aim































    #ifdef XR_FB_hand_tracking_capsules
/*!
 * C++ projection of XrHandCapsuleFB
 * 
 * Provided by the `XR_FB_hand_tracking_capsules` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandCapsuleFB>
 * @xrentity{XrHandCapsuleFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS HandCapsuleFB 
    {
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandCapsuleFB (
            )

            {}

        //! Default copy constructor
        HandCapsuleFB(const HandCapsuleFB& rhs) = default;
        //! Default copy assignment
        HandCapsuleFB& operator=(const HandCapsuleFB& rhs) = default;
        //! Copy construct from raw
        HandCapsuleFB(const XrHandCapsuleFB& rhs) : HandCapsuleFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandCapsuleFB& operator=(const XrHandCapsuleFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandCapsuleFB &() const { return *reinterpret_cast<const XrHandCapsuleFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandCapsuleFB &() {
            return *reinterpret_cast<XrHandCapsuleFB*>(this);
        }

        //! Accessor for this as the address of a raw XrHandCapsuleFB
        XrHandCapsuleFB const* get() const noexcept { return reinterpret_cast<XrHandCapsuleFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandCapsuleFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrHandCapsuleFB * put(bool clear = true) noexcept {
            if (clear) {*this = HandCapsuleFB{};}
            return reinterpret_cast<XrHandCapsuleFB*>(this);
        }
        Vector3f points[XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB];
        float radius;
        HandJointEXT joint;
    };
     static_assert(sizeof(XrHandCapsuleFB) == sizeof(HandCapsuleFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandCapsuleFB pointer to const from a HandCapsuleFB reference to const.
 * @relates HandCapsuleFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandCapsuleFB const* get(HandCapsuleFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandCapsuleFB as the address of a raw XrHandCapsuleFB
 * @relates HandCapsuleFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandCapsuleFB * put(HandCapsuleFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_hand_tracking_capsules































    #ifdef XR_FB_hand_tracking_capsules
/*!
 * C++ projection of XrHandTrackingCapsulesStateFB
 * 
 * Provided by the `XR_FB_hand_tracking_capsules` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingCapsulesStateFB>
 * @xrentity{XrHandTrackingCapsulesStateFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackingCapsulesStateFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandTrackingCapsulesStateFB (
            void * next_ = nullptr)

: Parent(StructureType::HandTrackingCapsulesStateFB
             , next_)
            {}

        //! Default copy constructor
        HandTrackingCapsulesStateFB(const HandTrackingCapsulesStateFB& rhs) = default;
        //! Default copy assignment
        HandTrackingCapsulesStateFB& operator=(const HandTrackingCapsulesStateFB& rhs) = default;
        //! Copy construct from raw
        HandTrackingCapsulesStateFB(const XrHandTrackingCapsulesStateFB& rhs) : HandTrackingCapsulesStateFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackingCapsulesStateFB& operator=(const XrHandTrackingCapsulesStateFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackingCapsulesStateFB &() const { return *reinterpret_cast<const XrHandTrackingCapsulesStateFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackingCapsulesStateFB &() {
            return *reinterpret_cast<XrHandTrackingCapsulesStateFB*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackingCapsulesStateFB
        XrHandTrackingCapsulesStateFB const* get() const noexcept { return reinterpret_cast<XrHandTrackingCapsulesStateFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingCapsulesStateFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackingCapsulesStateFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackingCapsulesStateFB{};next = oldNext;}
            return reinterpret_cast<XrHandTrackingCapsulesStateFB*>(this);
        }
        HandCapsuleFB capsules[XR_HAND_TRACKING_CAPSULE_COUNT_FB];
    };
     static_assert(sizeof(XrHandTrackingCapsulesStateFB) == sizeof(HandTrackingCapsulesStateFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackingCapsulesStateFB pointer to const from a HandTrackingCapsulesStateFB reference to const.
 * @relates HandTrackingCapsulesStateFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingCapsulesStateFB const* get(HandTrackingCapsulesStateFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingCapsulesStateFB as the address of a raw XrHandTrackingCapsulesStateFB
 * @relates HandTrackingCapsulesStateFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingCapsulesStateFB * put(HandTrackingCapsulesStateFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_hand_tracking_capsules































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSystemSpatialEntityPropertiesFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialEntityPropertiesFB>
 * @xrentity{XrSystemSpatialEntityPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemSpatialEntityPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemSpatialEntityPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemSpatialEntityPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemSpatialEntityPropertiesFB(const SystemSpatialEntityPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemSpatialEntityPropertiesFB& operator=(const SystemSpatialEntityPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemSpatialEntityPropertiesFB(const XrSystemSpatialEntityPropertiesFB& rhs) : SystemSpatialEntityPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemSpatialEntityPropertiesFB& operator=(const XrSystemSpatialEntityPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemSpatialEntityPropertiesFB &() const { return *reinterpret_cast<const XrSystemSpatialEntityPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemSpatialEntityPropertiesFB &() {
            return *reinterpret_cast<XrSystemSpatialEntityPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemSpatialEntityPropertiesFB
        XrSystemSpatialEntityPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemSpatialEntityPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemSpatialEntityPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemSpatialEntityPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemSpatialEntityPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemSpatialEntityPropertiesFB*>(this);
        }
        Bool32 supportsSpatialEntity;
    };
     static_assert(sizeof(XrSystemSpatialEntityPropertiesFB) == sizeof(SystemSpatialEntityPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemSpatialEntityPropertiesFB pointer to const from a SystemSpatialEntityPropertiesFB reference to const.
 * @relates SystemSpatialEntityPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemSpatialEntityPropertiesFB const* get(SystemSpatialEntityPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemSpatialEntityPropertiesFB as the address of a raw XrSystemSpatialEntityPropertiesFB
 * @relates SystemSpatialEntityPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemSpatialEntityPropertiesFB * put(SystemSpatialEntityPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSpatialAnchorCreateInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoFB>
 * @xrentity{XrSpatialAnchorCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpatialAnchorCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpatialAnchorCreateInfoFB (
 const Space& space_,  const Posef& poseInSpace_,  const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpatialAnchorCreateInfoFB
, next_)
, space {space_}
, poseInSpace {poseInSpace_}
, time {time_}
        {
        }


        //! Default/empty constructor
                 SpatialAnchorCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpatialAnchorCreateInfoFB
             , next_)
, space{}
, poseInSpace{}
, time{}
            {}

        //! Default copy constructor
        SpatialAnchorCreateInfoFB(const SpatialAnchorCreateInfoFB& rhs) = default;
        //! Default copy assignment
        SpatialAnchorCreateInfoFB& operator=(const SpatialAnchorCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        SpatialAnchorCreateInfoFB(const XrSpatialAnchorCreateInfoFB& rhs) : SpatialAnchorCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpatialAnchorCreateInfoFB& operator=(const XrSpatialAnchorCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpatialAnchorCreateInfoFB &() const { return *reinterpret_cast<const XrSpatialAnchorCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpatialAnchorCreateInfoFB &() {
            return *reinterpret_cast<XrSpatialAnchorCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoFB
        XrSpatialAnchorCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrSpatialAnchorCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpatialAnchorCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpatialAnchorCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpatialAnchorCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpatialAnchorCreateInfoFB*>(this);
        }
        Space space;
        Posef poseInSpace;
        Time time;
    };
     static_assert(sizeof(XrSpatialAnchorCreateInfoFB) == sizeof(SpatialAnchorCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoFB pointer to const from a SpatialAnchorCreateInfoFB reference to const.
 * @relates SpatialAnchorCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoFB const* get(SpatialAnchorCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoFB as the address of a raw XrSpatialAnchorCreateInfoFB
 * @relates SpatialAnchorCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoFB * put(SpatialAnchorCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSpaceComponentStatusSetInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentStatusSetInfoFB>
 * @xrentity{XrSpaceComponentStatusSetInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceComponentStatusSetInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceComponentStatusSetInfoFB (
 const SpaceComponentTypeFB& componentType_,  const Bool32& enabled_,  const Duration& timeout_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceComponentStatusSetInfoFB
, next_)
, componentType {componentType_}
, enabled {enabled_}
, timeout {timeout_}
        {
        }


        //! Default/empty constructor
                 SpaceComponentStatusSetInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceComponentStatusSetInfoFB
             , next_)
, componentType{}
, enabled{false}
, timeout{}
            {}

        //! Default copy constructor
        SpaceComponentStatusSetInfoFB(const SpaceComponentStatusSetInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceComponentStatusSetInfoFB& operator=(const SpaceComponentStatusSetInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceComponentStatusSetInfoFB(const XrSpaceComponentStatusSetInfoFB& rhs) : SpaceComponentStatusSetInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceComponentStatusSetInfoFB& operator=(const XrSpaceComponentStatusSetInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceComponentStatusSetInfoFB &() const { return *reinterpret_cast<const XrSpaceComponentStatusSetInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceComponentStatusSetInfoFB &() {
            return *reinterpret_cast<XrSpaceComponentStatusSetInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceComponentStatusSetInfoFB
        XrSpaceComponentStatusSetInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceComponentStatusSetInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceComponentStatusSetInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceComponentStatusSetInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceComponentStatusSetInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceComponentStatusSetInfoFB*>(this);
        }
        SpaceComponentTypeFB componentType;
        Bool32 enabled;
        Duration timeout;
    };
     static_assert(sizeof(XrSpaceComponentStatusSetInfoFB) == sizeof(SpaceComponentStatusSetInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceComponentStatusSetInfoFB pointer to const from a SpaceComponentStatusSetInfoFB reference to const.
 * @relates SpaceComponentStatusSetInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceComponentStatusSetInfoFB const* get(SpaceComponentStatusSetInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceComponentStatusSetInfoFB as the address of a raw XrSpaceComponentStatusSetInfoFB
 * @relates SpaceComponentStatusSetInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceComponentStatusSetInfoFB * put(SpaceComponentStatusSetInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSpaceComponentStatusFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentStatusFB>
 * @xrentity{XrSpaceComponentStatusFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceComponentStatusFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SpaceComponentStatusFB (
            void * next_ = nullptr)

: Parent(StructureType::SpaceComponentStatusFB
             , next_)
            {}

        //! Default copy constructor
        SpaceComponentStatusFB(const SpaceComponentStatusFB& rhs) = default;
        //! Default copy assignment
        SpaceComponentStatusFB& operator=(const SpaceComponentStatusFB& rhs) = default;
        //! Copy construct from raw
        SpaceComponentStatusFB(const XrSpaceComponentStatusFB& rhs) : SpaceComponentStatusFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceComponentStatusFB& operator=(const XrSpaceComponentStatusFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceComponentStatusFB &() const { return *reinterpret_cast<const XrSpaceComponentStatusFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceComponentStatusFB &() {
            return *reinterpret_cast<XrSpaceComponentStatusFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceComponentStatusFB
        XrSpaceComponentStatusFB const* get() const noexcept { return reinterpret_cast<XrSpaceComponentStatusFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceComponentStatusFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceComponentStatusFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceComponentStatusFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceComponentStatusFB*>(this);
        }
        Bool32 enabled;
        Bool32 changePending;
    };
     static_assert(sizeof(XrSpaceComponentStatusFB) == sizeof(SpaceComponentStatusFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceComponentStatusFB pointer to const from a SpaceComponentStatusFB reference to const.
 * @relates SpaceComponentStatusFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceComponentStatusFB const* get(SpaceComponentStatusFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceComponentStatusFB as the address of a raw XrSpaceComponentStatusFB
 * @relates SpaceComponentStatusFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceComponentStatusFB * put(SpaceComponentStatusFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrUuidEXT
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUuidEXT>
 * @xrentity{XrUuidEXT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS UuidEXT 
    {
    public:
        //! Constructor initializing all members.
                UuidEXT (
 uint8_t data_[XR_UUID_SIZE_EXT]                  )
        {
            memcpy(data, data_, sizeof(data));

        }


        //! Default/empty constructor
                 UuidEXT (
            )

: data{0}
            {}

        //! Default copy constructor
        UuidEXT(const UuidEXT& rhs) = default;
        //! Default copy assignment
        UuidEXT& operator=(const UuidEXT& rhs) = default;
        //! Copy construct from raw
        UuidEXT(const XrUuidEXT& rhs) : UuidEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        UuidEXT& operator=(const XrUuidEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrUuidEXT &() const { return *reinterpret_cast<const XrUuidEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrUuidEXT &() {
            return *reinterpret_cast<XrUuidEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrUuidEXT
        XrUuidEXT const* get() const noexcept { return reinterpret_cast<XrUuidEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrUuidEXT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrUuidEXT * put(bool clear = true) noexcept {
            if (clear) {*this = UuidEXT{};}
            return reinterpret_cast<XrUuidEXT*>(this);
        }
        uint8_t data[XR_UUID_SIZE_EXT];
    };
     static_assert(sizeof(XrUuidEXT) == sizeof(UuidEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrUuidEXT pointer to const from a UuidEXT reference to const.
 * @relates UuidEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrUuidEXT const* get(UuidEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing UuidEXT as the address of a raw XrUuidEXT
 * @relates UuidEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrUuidEXT * put(UuidEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrEventDataSpatialAnchorCreateCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpatialAnchorCreateCompleteFB>
 * @xrentity{XrEventDataSpatialAnchorCreateCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpatialAnchorCreateCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpatialAnchorCreateCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpatialAnchorCreateCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpatialAnchorCreateCompleteFB(const EventDataSpatialAnchorCreateCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpatialAnchorCreateCompleteFB& operator=(const EventDataSpatialAnchorCreateCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpatialAnchorCreateCompleteFB(const XrEventDataSpatialAnchorCreateCompleteFB& rhs) : EventDataSpatialAnchorCreateCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpatialAnchorCreateCompleteFB& operator=(const XrEventDataSpatialAnchorCreateCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpatialAnchorCreateCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpatialAnchorCreateCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpatialAnchorCreateCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpatialAnchorCreateCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpatialAnchorCreateCompleteFB
        XrEventDataSpatialAnchorCreateCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpatialAnchorCreateCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpatialAnchorCreateCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpatialAnchorCreateCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpatialAnchorCreateCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpatialAnchorCreateCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
        Space space;
        UuidEXT uuid;
    };
     static_assert(sizeof(XrEventDataSpatialAnchorCreateCompleteFB) == sizeof(EventDataSpatialAnchorCreateCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpatialAnchorCreateCompleteFB pointer to const from a EventDataSpatialAnchorCreateCompleteFB reference to const.
 * @relates EventDataSpatialAnchorCreateCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpatialAnchorCreateCompleteFB const* get(EventDataSpatialAnchorCreateCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpatialAnchorCreateCompleteFB as the address of a raw XrEventDataSpatialAnchorCreateCompleteFB
 * @relates EventDataSpatialAnchorCreateCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpatialAnchorCreateCompleteFB * put(EventDataSpatialAnchorCreateCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpatialAnchorCreateCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpatialAnchorCreateCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpatialAnchorCreateCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrEventDataSpaceSetStatusCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceSetStatusCompleteFB>
 * @xrentity{XrEventDataSpaceSetStatusCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceSetStatusCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceSetStatusCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceSetStatusCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceSetStatusCompleteFB(const EventDataSpaceSetStatusCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceSetStatusCompleteFB& operator=(const EventDataSpaceSetStatusCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceSetStatusCompleteFB(const XrEventDataSpaceSetStatusCompleteFB& rhs) : EventDataSpaceSetStatusCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceSetStatusCompleteFB& operator=(const XrEventDataSpaceSetStatusCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceSetStatusCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpaceSetStatusCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceSetStatusCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpaceSetStatusCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceSetStatusCompleteFB
        XrEventDataSpaceSetStatusCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceSetStatusCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceSetStatusCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceSetStatusCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceSetStatusCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceSetStatusCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
        Space space;
        UuidEXT uuid;
        SpaceComponentTypeFB componentType;
        Bool32 enabled;
    };
     static_assert(sizeof(XrEventDataSpaceSetStatusCompleteFB) == sizeof(EventDataSpaceSetStatusCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceSetStatusCompleteFB pointer to const from a EventDataSpaceSetStatusCompleteFB reference to const.
 * @relates EventDataSpaceSetStatusCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceSetStatusCompleteFB const* get(EventDataSpaceSetStatusCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceSetStatusCompleteFB as the address of a raw XrEventDataSpaceSetStatusCompleteFB
 * @relates EventDataSpaceSetStatusCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceSetStatusCompleteFB * put(EventDataSpaceSetStatusCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceSetStatusCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceSetStatusCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceSetStatusCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity































    #ifdef XR_FB_foveation
/*!
 * C++ projection of XrFoveationProfileCreateInfoFB
 * 
 * Provided by the `XR_FB_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationProfileCreateInfoFB>
 * @xrentity{XrFoveationProfileCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationProfileCreateInfoFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 FoveationProfileCreateInfoFB (
            void * next_ = nullptr)

: Parent(StructureType::FoveationProfileCreateInfoFB
             , next_)
            {}

        //! Default copy constructor
        FoveationProfileCreateInfoFB(const FoveationProfileCreateInfoFB& rhs) = default;
        //! Default copy assignment
        FoveationProfileCreateInfoFB& operator=(const FoveationProfileCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        FoveationProfileCreateInfoFB(const XrFoveationProfileCreateInfoFB& rhs) : FoveationProfileCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationProfileCreateInfoFB& operator=(const XrFoveationProfileCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationProfileCreateInfoFB &() const { return *reinterpret_cast<const XrFoveationProfileCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationProfileCreateInfoFB &() {
            return *reinterpret_cast<XrFoveationProfileCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationProfileCreateInfoFB
        XrFoveationProfileCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrFoveationProfileCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationProfileCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationProfileCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationProfileCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrFoveationProfileCreateInfoFB*>(this);
        }
    };
     static_assert(sizeof(XrFoveationProfileCreateInfoFB) == sizeof(FoveationProfileCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationProfileCreateInfoFB pointer to const from a FoveationProfileCreateInfoFB reference to const.
 * @relates FoveationProfileCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationProfileCreateInfoFB const* get(FoveationProfileCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationProfileCreateInfoFB as the address of a raw XrFoveationProfileCreateInfoFB
 * @relates FoveationProfileCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationProfileCreateInfoFB * put(FoveationProfileCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_foveation































    #ifdef XR_FB_foveation
/*!
 * C++ projection of XrSwapchainCreateInfoFoveationFB
 * 
 * Provided by the `XR_FB_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfoFoveationFB>
 * @xrentity{XrSwapchainCreateInfoFoveationFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainCreateInfoFoveationFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainCreateInfoFoveationFB (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainCreateInfoFoveationFB
             , next_)
            {}

        //! Default copy constructor
        SwapchainCreateInfoFoveationFB(const SwapchainCreateInfoFoveationFB& rhs) = default;
        //! Default copy assignment
        SwapchainCreateInfoFoveationFB& operator=(const SwapchainCreateInfoFoveationFB& rhs) = default;
        //! Copy construct from raw
        SwapchainCreateInfoFoveationFB(const XrSwapchainCreateInfoFoveationFB& rhs) : SwapchainCreateInfoFoveationFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainCreateInfoFoveationFB& operator=(const XrSwapchainCreateInfoFoveationFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainCreateInfoFoveationFB &() const { return *reinterpret_cast<const XrSwapchainCreateInfoFoveationFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainCreateInfoFoveationFB &() {
            return *reinterpret_cast<XrSwapchainCreateInfoFoveationFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainCreateInfoFoveationFB
        XrSwapchainCreateInfoFoveationFB const* get() const noexcept { return reinterpret_cast<XrSwapchainCreateInfoFoveationFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainCreateInfoFoveationFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainCreateInfoFoveationFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainCreateInfoFoveationFB{};next = oldNext;}
            return reinterpret_cast<XrSwapchainCreateInfoFoveationFB*>(this);
        }
        SwapchainCreateFoveationFlagsFB flags;
    };
     static_assert(sizeof(XrSwapchainCreateInfoFoveationFB) == sizeof(SwapchainCreateInfoFoveationFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfoFoveationFB pointer to const from a SwapchainCreateInfoFoveationFB reference to const.
 * @relates SwapchainCreateInfoFoveationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainCreateInfoFoveationFB const* get(SwapchainCreateInfoFoveationFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainCreateInfoFoveationFB as the address of a raw XrSwapchainCreateInfoFoveationFB
 * @relates SwapchainCreateInfoFoveationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainCreateInfoFoveationFB * put(SwapchainCreateInfoFoveationFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_foveation































    #ifdef XR_FB_foveation
/*!
 * C++ projection of XrSwapchainStateFoveationFB
 * 
 * Provided by the `XR_FB_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateFoveationFB>
 * @xrentity{XrSwapchainStateFoveationFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainStateFoveationFB : public SwapchainStateBaseHeaderFB
    {
    private:
        using Parent = SwapchainStateBaseHeaderFB;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainStateFoveationFB (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainStateFoveationFB
             , next_)
            {}

        //! Default copy constructor
        SwapchainStateFoveationFB(const SwapchainStateFoveationFB& rhs) = default;
        //! Default copy assignment
        SwapchainStateFoveationFB& operator=(const SwapchainStateFoveationFB& rhs) = default;
        //! Copy construct from raw
        SwapchainStateFoveationFB(const XrSwapchainStateFoveationFB& rhs) : SwapchainStateFoveationFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainStateFoveationFB& operator=(const XrSwapchainStateFoveationFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainStateFoveationFB &() const { return *reinterpret_cast<const XrSwapchainStateFoveationFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainStateFoveationFB &() {
            return *reinterpret_cast<XrSwapchainStateFoveationFB*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
        XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainStateFoveationFB
        XrSwapchainStateFoveationFB const* get() const noexcept { return reinterpret_cast<XrSwapchainStateFoveationFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainStateFoveationFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainStateFoveationFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainStateFoveationFB{};next = oldNext;}
            return reinterpret_cast<XrSwapchainStateFoveationFB*>(this);
        }
        SwapchainStateFoveationFlagsFB flags;
        FoveationProfileFB profile;
    };
     static_assert(sizeof(XrSwapchainStateFoveationFB) == sizeof(SwapchainStateFoveationFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainStateFoveationFB pointer to const from a SwapchainStateFoveationFB reference to const.
 * @relates SwapchainStateFoveationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateFoveationFB const* get(SwapchainStateFoveationFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateFoveationFB as the address of a raw XrSwapchainStateFoveationFB
 * @relates SwapchainStateFoveationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateFoveationFB * put(SwapchainStateFoveationFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainStateFoveationFB as a raw, pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateFoveationFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(SwapchainStateFoveationFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_foveation































    #ifdef XR_FB_foveation_configuration
/*!
 * C++ projection of XrFoveationLevelProfileCreateInfoFB
 * 
 * Provided by the `XR_FB_foveation_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelProfileCreateInfoFB>
 * @xrentity{XrFoveationLevelProfileCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationLevelProfileCreateInfoFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 FoveationLevelProfileCreateInfoFB (
            void * next_ = nullptr)

: Parent(StructureType::FoveationLevelProfileCreateInfoFB
             , next_)
            {}

        //! Default copy constructor
        FoveationLevelProfileCreateInfoFB(const FoveationLevelProfileCreateInfoFB& rhs) = default;
        //! Default copy assignment
        FoveationLevelProfileCreateInfoFB& operator=(const FoveationLevelProfileCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        FoveationLevelProfileCreateInfoFB(const XrFoveationLevelProfileCreateInfoFB& rhs) : FoveationLevelProfileCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationLevelProfileCreateInfoFB& operator=(const XrFoveationLevelProfileCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationLevelProfileCreateInfoFB &() const { return *reinterpret_cast<const XrFoveationLevelProfileCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationLevelProfileCreateInfoFB &() {
            return *reinterpret_cast<XrFoveationLevelProfileCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationLevelProfileCreateInfoFB
        XrFoveationLevelProfileCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrFoveationLevelProfileCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationLevelProfileCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationLevelProfileCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationLevelProfileCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrFoveationLevelProfileCreateInfoFB*>(this);
        }
        FoveationLevelFB level;
        float verticalOffset;
        FoveationDynamicFB dynamic;
    };
     static_assert(sizeof(XrFoveationLevelProfileCreateInfoFB) == sizeof(FoveationLevelProfileCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationLevelProfileCreateInfoFB pointer to const from a FoveationLevelProfileCreateInfoFB reference to const.
 * @relates FoveationLevelProfileCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationLevelProfileCreateInfoFB const* get(FoveationLevelProfileCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationLevelProfileCreateInfoFB as the address of a raw XrFoveationLevelProfileCreateInfoFB
 * @relates FoveationLevelProfileCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationLevelProfileCreateInfoFB * put(FoveationLevelProfileCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_foveation_configuration































    #ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrSystemKeyboardTrackingPropertiesFB
 * 
 * Provided by the `XR_FB_keyboard_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemKeyboardTrackingPropertiesFB>
 * @xrentity{XrSystemKeyboardTrackingPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemKeyboardTrackingPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemKeyboardTrackingPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemKeyboardTrackingPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemKeyboardTrackingPropertiesFB(const SystemKeyboardTrackingPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemKeyboardTrackingPropertiesFB& operator=(const SystemKeyboardTrackingPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemKeyboardTrackingPropertiesFB(const XrSystemKeyboardTrackingPropertiesFB& rhs) : SystemKeyboardTrackingPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemKeyboardTrackingPropertiesFB& operator=(const XrSystemKeyboardTrackingPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemKeyboardTrackingPropertiesFB &() const { return *reinterpret_cast<const XrSystemKeyboardTrackingPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemKeyboardTrackingPropertiesFB &() {
            return *reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemKeyboardTrackingPropertiesFB
        XrSystemKeyboardTrackingPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemKeyboardTrackingPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemKeyboardTrackingPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemKeyboardTrackingPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB*>(this);
        }
        Bool32 supportsKeyboardTracking;
    };
     static_assert(sizeof(XrSystemKeyboardTrackingPropertiesFB) == sizeof(SystemKeyboardTrackingPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemKeyboardTrackingPropertiesFB pointer to const from a SystemKeyboardTrackingPropertiesFB reference to const.
 * @relates SystemKeyboardTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemKeyboardTrackingPropertiesFB const* get(SystemKeyboardTrackingPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemKeyboardTrackingPropertiesFB as the address of a raw XrSystemKeyboardTrackingPropertiesFB
 * @relates SystemKeyboardTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemKeyboardTrackingPropertiesFB * put(SystemKeyboardTrackingPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_keyboard_tracking































    #ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardTrackingDescriptionFB
 * 
 * Provided by the `XR_FB_keyboard_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardTrackingDescriptionFB>
 * @xrentity{XrKeyboardTrackingDescriptionFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS KeyboardTrackingDescriptionFB 
    {
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 KeyboardTrackingDescriptionFB (
            )

            {}

        //! Default copy constructor
        KeyboardTrackingDescriptionFB(const KeyboardTrackingDescriptionFB& rhs) = default;
        //! Default copy assignment
        KeyboardTrackingDescriptionFB& operator=(const KeyboardTrackingDescriptionFB& rhs) = default;
        //! Copy construct from raw
        KeyboardTrackingDescriptionFB(const XrKeyboardTrackingDescriptionFB& rhs) : KeyboardTrackingDescriptionFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        KeyboardTrackingDescriptionFB& operator=(const XrKeyboardTrackingDescriptionFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrKeyboardTrackingDescriptionFB &() const { return *reinterpret_cast<const XrKeyboardTrackingDescriptionFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrKeyboardTrackingDescriptionFB &() {
            return *reinterpret_cast<XrKeyboardTrackingDescriptionFB*>(this);
        }

        //! Accessor for this as the address of a raw XrKeyboardTrackingDescriptionFB
        XrKeyboardTrackingDescriptionFB const* get() const noexcept { return reinterpret_cast<XrKeyboardTrackingDescriptionFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrKeyboardTrackingDescriptionFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrKeyboardTrackingDescriptionFB * put(bool clear = true) noexcept {
            if (clear) {*this = KeyboardTrackingDescriptionFB{};}
            return reinterpret_cast<XrKeyboardTrackingDescriptionFB*>(this);
        }
        uint64_t trackedKeyboardId;
        Vector3f size;
        KeyboardTrackingFlagsFB flags;
        char name[XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB];
    };
     static_assert(sizeof(XrKeyboardTrackingDescriptionFB) == sizeof(KeyboardTrackingDescriptionFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrKeyboardTrackingDescriptionFB pointer to const from a KeyboardTrackingDescriptionFB reference to const.
 * @relates KeyboardTrackingDescriptionFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrKeyboardTrackingDescriptionFB const* get(KeyboardTrackingDescriptionFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardTrackingDescriptionFB as the address of a raw XrKeyboardTrackingDescriptionFB
 * @relates KeyboardTrackingDescriptionFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrKeyboardTrackingDescriptionFB * put(KeyboardTrackingDescriptionFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_keyboard_tracking































    #ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardSpaceCreateInfoFB
 * 
 * Provided by the `XR_FB_keyboard_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardSpaceCreateInfoFB>
 * @xrentity{XrKeyboardSpaceCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS KeyboardSpaceCreateInfoFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 KeyboardSpaceCreateInfoFB (
            void * next_ = nullptr)

: Parent(StructureType::KeyboardSpaceCreateInfoFB
             , next_)
            {}

        //! Default copy constructor
        KeyboardSpaceCreateInfoFB(const KeyboardSpaceCreateInfoFB& rhs) = default;
        //! Default copy assignment
        KeyboardSpaceCreateInfoFB& operator=(const KeyboardSpaceCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        KeyboardSpaceCreateInfoFB(const XrKeyboardSpaceCreateInfoFB& rhs) : KeyboardSpaceCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        KeyboardSpaceCreateInfoFB& operator=(const XrKeyboardSpaceCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrKeyboardSpaceCreateInfoFB &() const { return *reinterpret_cast<const XrKeyboardSpaceCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrKeyboardSpaceCreateInfoFB &() {
            return *reinterpret_cast<XrKeyboardSpaceCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrKeyboardSpaceCreateInfoFB
        XrKeyboardSpaceCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrKeyboardSpaceCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrKeyboardSpaceCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrKeyboardSpaceCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = KeyboardSpaceCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrKeyboardSpaceCreateInfoFB*>(this);
        }
        uint64_t trackedKeyboardId;
    };
     static_assert(sizeof(XrKeyboardSpaceCreateInfoFB) == sizeof(KeyboardSpaceCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrKeyboardSpaceCreateInfoFB pointer to const from a KeyboardSpaceCreateInfoFB reference to const.
 * @relates KeyboardSpaceCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrKeyboardSpaceCreateInfoFB const* get(KeyboardSpaceCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardSpaceCreateInfoFB as the address of a raw XrKeyboardSpaceCreateInfoFB
 * @relates KeyboardSpaceCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrKeyboardSpaceCreateInfoFB * put(KeyboardSpaceCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_keyboard_tracking































    #ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardTrackingQueryFB
 * 
 * Provided by the `XR_FB_keyboard_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardTrackingQueryFB>
 * @xrentity{XrKeyboardTrackingQueryFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS KeyboardTrackingQueryFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 KeyboardTrackingQueryFB (
            void * next_ = nullptr)

: Parent(StructureType::KeyboardTrackingQueryFB
             , next_)
            {}

        //! Default copy constructor
        KeyboardTrackingQueryFB(const KeyboardTrackingQueryFB& rhs) = default;
        //! Default copy assignment
        KeyboardTrackingQueryFB& operator=(const KeyboardTrackingQueryFB& rhs) = default;
        //! Copy construct from raw
        KeyboardTrackingQueryFB(const XrKeyboardTrackingQueryFB& rhs) : KeyboardTrackingQueryFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        KeyboardTrackingQueryFB& operator=(const XrKeyboardTrackingQueryFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrKeyboardTrackingQueryFB &() const { return *reinterpret_cast<const XrKeyboardTrackingQueryFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrKeyboardTrackingQueryFB &() {
            return *reinterpret_cast<XrKeyboardTrackingQueryFB*>(this);
        }

        //! Accessor for this as the address of a raw XrKeyboardTrackingQueryFB
        XrKeyboardTrackingQueryFB const* get() const noexcept { return reinterpret_cast<XrKeyboardTrackingQueryFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrKeyboardTrackingQueryFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrKeyboardTrackingQueryFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = KeyboardTrackingQueryFB{};next = oldNext;}
            return reinterpret_cast<XrKeyboardTrackingQueryFB*>(this);
        }
        KeyboardTrackingQueryFlagsFB flags;
    };
     static_assert(sizeof(XrKeyboardTrackingQueryFB) == sizeof(KeyboardTrackingQueryFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrKeyboardTrackingQueryFB pointer to const from a KeyboardTrackingQueryFB reference to const.
 * @relates KeyboardTrackingQueryFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrKeyboardTrackingQueryFB const* get(KeyboardTrackingQueryFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardTrackingQueryFB as the address of a raw XrKeyboardTrackingQueryFB
 * @relates KeyboardTrackingQueryFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrKeyboardTrackingQueryFB * put(KeyboardTrackingQueryFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_keyboard_tracking































    #ifdef XR_FB_triangle_mesh
/*!
 * C++ projection of XrTriangleMeshCreateInfoFB
 * 
 * Provided by the `XR_FB_triangle_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTriangleMeshCreateInfoFB>
 * @xrentity{XrTriangleMeshCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS TriangleMeshCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                TriangleMeshCreateInfoFB (
 const TriangleMeshFlagsFB& flags_,  const WindingOrderFB& windingOrder_,  uint32_t vertexCount_,  const Vector3f* vertexBuffer_,  uint32_t triangleCount_,  const uint32_t* indexBuffer_,  const void * next_ = nullptr                  )
: Parent(StructureType::TriangleMeshCreateInfoFB
, next_)
, flags {flags_}
, windingOrder {windingOrder_}
, vertexCount {vertexCount_}
, vertexBuffer {vertexBuffer_}
, triangleCount {triangleCount_}
, indexBuffer {indexBuffer_}
        {
        }


        //! Default/empty constructor
                 TriangleMeshCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::TriangleMeshCreateInfoFB
             , next_)
, flags{}
, windingOrder{}
, vertexCount{0}
, vertexBuffer{nullptr}
, triangleCount{0}
, indexBuffer{nullptr}
            {}

        //! Default copy constructor
        TriangleMeshCreateInfoFB(const TriangleMeshCreateInfoFB& rhs) = default;
        //! Default copy assignment
        TriangleMeshCreateInfoFB& operator=(const TriangleMeshCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        TriangleMeshCreateInfoFB(const XrTriangleMeshCreateInfoFB& rhs) : TriangleMeshCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        TriangleMeshCreateInfoFB& operator=(const XrTriangleMeshCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrTriangleMeshCreateInfoFB &() const { return *reinterpret_cast<const XrTriangleMeshCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrTriangleMeshCreateInfoFB &() {
            return *reinterpret_cast<XrTriangleMeshCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrTriangleMeshCreateInfoFB
        XrTriangleMeshCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrTriangleMeshCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrTriangleMeshCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrTriangleMeshCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = TriangleMeshCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrTriangleMeshCreateInfoFB*>(this);
        }
        TriangleMeshFlagsFB flags;
        WindingOrderFB windingOrder;
        uint32_t vertexCount;
        const Vector3f* vertexBuffer;
        uint32_t triangleCount;
        const uint32_t* indexBuffer;
    };
     static_assert(sizeof(XrTriangleMeshCreateInfoFB) == sizeof(TriangleMeshCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrTriangleMeshCreateInfoFB pointer to const from a TriangleMeshCreateInfoFB reference to const.
 * @relates TriangleMeshCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrTriangleMeshCreateInfoFB const* get(TriangleMeshCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing TriangleMeshCreateInfoFB as the address of a raw XrTriangleMeshCreateInfoFB
 * @relates TriangleMeshCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrTriangleMeshCreateInfoFB * put(TriangleMeshCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_triangle_mesh































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrSystemPassthroughPropertiesFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughPropertiesFB>
 * @xrentity{XrSystemPassthroughPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemPassthroughPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemPassthroughPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemPassthroughPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemPassthroughPropertiesFB(const SystemPassthroughPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemPassthroughPropertiesFB& operator=(const SystemPassthroughPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemPassthroughPropertiesFB(const XrSystemPassthroughPropertiesFB& rhs) : SystemPassthroughPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemPassthroughPropertiesFB& operator=(const XrSystemPassthroughPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemPassthroughPropertiesFB &() const { return *reinterpret_cast<const XrSystemPassthroughPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemPassthroughPropertiesFB &() {
            return *reinterpret_cast<XrSystemPassthroughPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemPassthroughPropertiesFB
        XrSystemPassthroughPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemPassthroughPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemPassthroughPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemPassthroughPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemPassthroughPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemPassthroughPropertiesFB*>(this);
        }
        Bool32 supportsPassthrough;
    };
     static_assert(sizeof(XrSystemPassthroughPropertiesFB) == sizeof(SystemPassthroughPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemPassthroughPropertiesFB pointer to const from a SystemPassthroughPropertiesFB reference to const.
 * @relates SystemPassthroughPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPassthroughPropertiesFB const* get(SystemPassthroughPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemPassthroughPropertiesFB as the address of a raw XrSystemPassthroughPropertiesFB
 * @relates SystemPassthroughPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPassthroughPropertiesFB * put(SystemPassthroughPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrSystemPassthroughProperties2FB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughProperties2FB>
 * @xrentity{XrSystemPassthroughProperties2FB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemPassthroughProperties2FB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemPassthroughProperties2FB (
            void * next_ = nullptr)

: Parent(StructureType::SystemPassthroughProperties2FB
             , next_)
            {}

        //! Default copy constructor
        SystemPassthroughProperties2FB(const SystemPassthroughProperties2FB& rhs) = default;
        //! Default copy assignment
        SystemPassthroughProperties2FB& operator=(const SystemPassthroughProperties2FB& rhs) = default;
        //! Copy construct from raw
        SystemPassthroughProperties2FB(const XrSystemPassthroughProperties2FB& rhs) : SystemPassthroughProperties2FB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemPassthroughProperties2FB& operator=(const XrSystemPassthroughProperties2FB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemPassthroughProperties2FB &() const { return *reinterpret_cast<const XrSystemPassthroughProperties2FB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemPassthroughProperties2FB &() {
            return *reinterpret_cast<XrSystemPassthroughProperties2FB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemPassthroughProperties2FB
        XrSystemPassthroughProperties2FB const* get() const noexcept { return reinterpret_cast<XrSystemPassthroughProperties2FB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemPassthroughProperties2FB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemPassthroughProperties2FB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemPassthroughProperties2FB{};next = oldNext;}
            return reinterpret_cast<XrSystemPassthroughProperties2FB*>(this);
        }
        PassthroughCapabilityFlagsFB capabilities;
    };
     static_assert(sizeof(XrSystemPassthroughProperties2FB) == sizeof(SystemPassthroughProperties2FB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemPassthroughProperties2FB pointer to const from a SystemPassthroughProperties2FB reference to const.
 * @relates SystemPassthroughProperties2FB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPassthroughProperties2FB const* get(SystemPassthroughProperties2FB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemPassthroughProperties2FB as the address of a raw XrSystemPassthroughProperties2FB
 * @relates SystemPassthroughProperties2FB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPassthroughProperties2FB * put(SystemPassthroughProperties2FB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughCreateInfoFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughCreateInfoFB>
 * @xrentity{XrPassthroughCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughCreateInfoFB (
 const PassthroughFlagsFB& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughCreateInfoFB
, next_)
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 PassthroughCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughCreateInfoFB
             , next_)
, flags{}
            {}

        //! Default copy constructor
        PassthroughCreateInfoFB(const PassthroughCreateInfoFB& rhs) = default;
        //! Default copy assignment
        PassthroughCreateInfoFB& operator=(const PassthroughCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        PassthroughCreateInfoFB(const XrPassthroughCreateInfoFB& rhs) : PassthroughCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughCreateInfoFB& operator=(const XrPassthroughCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughCreateInfoFB &() const { return *reinterpret_cast<const XrPassthroughCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughCreateInfoFB &() {
            return *reinterpret_cast<XrPassthroughCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughCreateInfoFB
        XrPassthroughCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrPassthroughCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrPassthroughCreateInfoFB*>(this);
        }
        PassthroughFlagsFB flags;
    };
     static_assert(sizeof(XrPassthroughCreateInfoFB) == sizeof(PassthroughCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughCreateInfoFB pointer to const from a PassthroughCreateInfoFB reference to const.
 * @relates PassthroughCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughCreateInfoFB const* get(PassthroughCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughCreateInfoFB as the address of a raw XrPassthroughCreateInfoFB
 * @relates PassthroughCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughCreateInfoFB * put(PassthroughCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughLayerCreateInfoFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerCreateInfoFB>
 * @xrentity{XrPassthroughLayerCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughLayerCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughLayerCreateInfoFB (
 const PassthroughFB& passthrough_,  const PassthroughFlagsFB& flags_,  const PassthroughLayerPurposeFB& purpose_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughLayerCreateInfoFB
, next_)
, passthrough {passthrough_}
, flags {flags_}
, purpose {purpose_}
        {
        }


        //! Default/empty constructor
                 PassthroughLayerCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughLayerCreateInfoFB
             , next_)
, passthrough{}
, flags{}
, purpose{}
            {}

        //! Default copy constructor
        PassthroughLayerCreateInfoFB(const PassthroughLayerCreateInfoFB& rhs) = default;
        //! Default copy assignment
        PassthroughLayerCreateInfoFB& operator=(const PassthroughLayerCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        PassthroughLayerCreateInfoFB(const XrPassthroughLayerCreateInfoFB& rhs) : PassthroughLayerCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughLayerCreateInfoFB& operator=(const XrPassthroughLayerCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughLayerCreateInfoFB &() const { return *reinterpret_cast<const XrPassthroughLayerCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughLayerCreateInfoFB &() {
            return *reinterpret_cast<XrPassthroughLayerCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughLayerCreateInfoFB
        XrPassthroughLayerCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrPassthroughLayerCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughLayerCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughLayerCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughLayerCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrPassthroughLayerCreateInfoFB*>(this);
        }
        PassthroughFB passthrough;
        PassthroughFlagsFB flags;
        PassthroughLayerPurposeFB purpose;
    };
     static_assert(sizeof(XrPassthroughLayerCreateInfoFB) == sizeof(PassthroughLayerCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughLayerCreateInfoFB pointer to const from a PassthroughLayerCreateInfoFB reference to const.
 * @relates PassthroughLayerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughLayerCreateInfoFB const* get(PassthroughLayerCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughLayerCreateInfoFB as the address of a raw XrPassthroughLayerCreateInfoFB
 * @relates PassthroughLayerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughLayerCreateInfoFB * put(PassthroughLayerCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrCompositionLayerPassthroughFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerPassthroughFB>
 * @xrentity{XrCompositionLayerPassthroughFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerPassthroughFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerPassthroughFB (
 const CompositionLayerFlags& flags_,  const Space& space_,  const PassthroughLayerFB& layerHandle_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerPassthroughFB
, next_)
, flags {flags_}
, space {space_}
, layerHandle {layerHandle_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerPassthroughFB (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerPassthroughFB
             , next_)
, flags{}
, space{}
, layerHandle{}
            {}

        //! Default copy constructor
        CompositionLayerPassthroughFB(const CompositionLayerPassthroughFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerPassthroughFB& operator=(const CompositionLayerPassthroughFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerPassthroughFB(const XrCompositionLayerPassthroughFB& rhs) : CompositionLayerPassthroughFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerPassthroughFB& operator=(const XrCompositionLayerPassthroughFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerPassthroughFB &() const { return *reinterpret_cast<const XrCompositionLayerPassthroughFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerPassthroughFB &() {
            return *reinterpret_cast<XrCompositionLayerPassthroughFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerPassthroughFB
        XrCompositionLayerPassthroughFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerPassthroughFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerPassthroughFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerPassthroughFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerPassthroughFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerPassthroughFB*>(this);
        }
        CompositionLayerFlags flags;
        Space space;
        PassthroughLayerFB layerHandle;
    };
     static_assert(sizeof(XrCompositionLayerPassthroughFB) == sizeof(CompositionLayerPassthroughFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerPassthroughFB pointer to const from a CompositionLayerPassthroughFB reference to const.
 * @relates CompositionLayerPassthroughFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerPassthroughFB const* get(CompositionLayerPassthroughFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerPassthroughFB as the address of a raw XrCompositionLayerPassthroughFB
 * @relates CompositionLayerPassthroughFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerPassthroughFB * put(CompositionLayerPassthroughFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrGeometryInstanceCreateInfoFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceCreateInfoFB>
 * @xrentity{XrGeometryInstanceCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GeometryInstanceCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GeometryInstanceCreateInfoFB (
 const PassthroughLayerFB& layer_,  const TriangleMeshFB& mesh_,  const Space& baseSpace_,  const Posef& pose_,  const Vector3f& scale_,  const void * next_ = nullptr                  )
: Parent(StructureType::GeometryInstanceCreateInfoFB
, next_)
, layer {layer_}
, mesh {mesh_}
, baseSpace {baseSpace_}
, pose {pose_}
, scale {scale_}
        {
        }


        //! Default/empty constructor
                 GeometryInstanceCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::GeometryInstanceCreateInfoFB
             , next_)
, layer{}
, mesh{}
, baseSpace{}
, pose{}
, scale{}
            {}

        //! Default copy constructor
        GeometryInstanceCreateInfoFB(const GeometryInstanceCreateInfoFB& rhs) = default;
        //! Default copy assignment
        GeometryInstanceCreateInfoFB& operator=(const GeometryInstanceCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        GeometryInstanceCreateInfoFB(const XrGeometryInstanceCreateInfoFB& rhs) : GeometryInstanceCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GeometryInstanceCreateInfoFB& operator=(const XrGeometryInstanceCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGeometryInstanceCreateInfoFB &() const { return *reinterpret_cast<const XrGeometryInstanceCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGeometryInstanceCreateInfoFB &() {
            return *reinterpret_cast<XrGeometryInstanceCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrGeometryInstanceCreateInfoFB
        XrGeometryInstanceCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrGeometryInstanceCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGeometryInstanceCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGeometryInstanceCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GeometryInstanceCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrGeometryInstanceCreateInfoFB*>(this);
        }
        PassthroughLayerFB layer;
        TriangleMeshFB mesh;
        Space baseSpace;
        Posef pose;
        Vector3f scale;
    };
     static_assert(sizeof(XrGeometryInstanceCreateInfoFB) == sizeof(GeometryInstanceCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGeometryInstanceCreateInfoFB pointer to const from a GeometryInstanceCreateInfoFB reference to const.
 * @relates GeometryInstanceCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGeometryInstanceCreateInfoFB const* get(GeometryInstanceCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GeometryInstanceCreateInfoFB as the address of a raw XrGeometryInstanceCreateInfoFB
 * @relates GeometryInstanceCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGeometryInstanceCreateInfoFB * put(GeometryInstanceCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrGeometryInstanceTransformFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceTransformFB>
 * @xrentity{XrGeometryInstanceTransformFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GeometryInstanceTransformFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GeometryInstanceTransformFB (
 const Space& baseSpace_,  const Time& time_,  const Posef& pose_,  const Vector3f& scale_,  const void * next_ = nullptr                  )
: Parent(StructureType::GeometryInstanceTransformFB
, next_)
, baseSpace {baseSpace_}
, time {time_}
, pose {pose_}
, scale {scale_}
        {
        }


        //! Default/empty constructor
                 GeometryInstanceTransformFB (
            const void * next_ = nullptr)

: Parent(StructureType::GeometryInstanceTransformFB
             , next_)
, baseSpace{}
, time{}
, pose{}
, scale{}
            {}

        //! Default copy constructor
        GeometryInstanceTransformFB(const GeometryInstanceTransformFB& rhs) = default;
        //! Default copy assignment
        GeometryInstanceTransformFB& operator=(const GeometryInstanceTransformFB& rhs) = default;
        //! Copy construct from raw
        GeometryInstanceTransformFB(const XrGeometryInstanceTransformFB& rhs) : GeometryInstanceTransformFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GeometryInstanceTransformFB& operator=(const XrGeometryInstanceTransformFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGeometryInstanceTransformFB &() const { return *reinterpret_cast<const XrGeometryInstanceTransformFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGeometryInstanceTransformFB &() {
            return *reinterpret_cast<XrGeometryInstanceTransformFB*>(this);
        }

        //! Accessor for this as the address of a raw XrGeometryInstanceTransformFB
        XrGeometryInstanceTransformFB const* get() const noexcept { return reinterpret_cast<XrGeometryInstanceTransformFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGeometryInstanceTransformFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGeometryInstanceTransformFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GeometryInstanceTransformFB{};next = oldNext;}
            return reinterpret_cast<XrGeometryInstanceTransformFB*>(this);
        }
        Space baseSpace;
        Time time;
        Posef pose;
        Vector3f scale;
    };
     static_assert(sizeof(XrGeometryInstanceTransformFB) == sizeof(GeometryInstanceTransformFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGeometryInstanceTransformFB pointer to const from a GeometryInstanceTransformFB reference to const.
 * @relates GeometryInstanceTransformFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGeometryInstanceTransformFB const* get(GeometryInstanceTransformFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GeometryInstanceTransformFB as the address of a raw XrGeometryInstanceTransformFB
 * @relates GeometryInstanceTransformFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGeometryInstanceTransformFB * put(GeometryInstanceTransformFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughStyleFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughStyleFB>
 * @xrentity{XrPassthroughStyleFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughStyleFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughStyleFB (
 float textureOpacityFactor_,  const Color4f& edgeColor_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughStyleFB
, next_)
, textureOpacityFactor {textureOpacityFactor_}
, edgeColor {edgeColor_}
        {
        }


        //! Default/empty constructor
                 PassthroughStyleFB (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughStyleFB
             , next_)
, textureOpacityFactor{0.0f}
, edgeColor{}
            {}

        //! Default copy constructor
        PassthroughStyleFB(const PassthroughStyleFB& rhs) = default;
        //! Default copy assignment
        PassthroughStyleFB& operator=(const PassthroughStyleFB& rhs) = default;
        //! Copy construct from raw
        PassthroughStyleFB(const XrPassthroughStyleFB& rhs) : PassthroughStyleFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughStyleFB& operator=(const XrPassthroughStyleFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughStyleFB &() const { return *reinterpret_cast<const XrPassthroughStyleFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughStyleFB &() {
            return *reinterpret_cast<XrPassthroughStyleFB*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughStyleFB
        XrPassthroughStyleFB const* get() const noexcept { return reinterpret_cast<XrPassthroughStyleFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughStyleFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughStyleFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughStyleFB{};next = oldNext;}
            return reinterpret_cast<XrPassthroughStyleFB*>(this);
        }
        float textureOpacityFactor;
        Color4f edgeColor;
    };
     static_assert(sizeof(XrPassthroughStyleFB) == sizeof(PassthroughStyleFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughStyleFB pointer to const from a PassthroughStyleFB reference to const.
 * @relates PassthroughStyleFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughStyleFB const* get(PassthroughStyleFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughStyleFB as the address of a raw XrPassthroughStyleFB
 * @relates PassthroughStyleFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughStyleFB * put(PassthroughStyleFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughColorMapMonoToMonoFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapMonoToMonoFB>
 * @xrentity{XrPassthroughColorMapMonoToMonoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughColorMapMonoToMonoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughColorMapMonoToMonoFB (
 uint8_t textureColorMap_[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB],  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughColorMapMonoToMonoFB
, next_)
        {
            memcpy(textureColorMap, textureColorMap_, sizeof(textureColorMap));

        }


        //! Default/empty constructor
                 PassthroughColorMapMonoToMonoFB (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughColorMapMonoToMonoFB
             , next_)
, textureColorMap{0}
            {}

        //! Default copy constructor
        PassthroughColorMapMonoToMonoFB(const PassthroughColorMapMonoToMonoFB& rhs) = default;
        //! Default copy assignment
        PassthroughColorMapMonoToMonoFB& operator=(const PassthroughColorMapMonoToMonoFB& rhs) = default;
        //! Copy construct from raw
        PassthroughColorMapMonoToMonoFB(const XrPassthroughColorMapMonoToMonoFB& rhs) : PassthroughColorMapMonoToMonoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorMapMonoToMonoFB& operator=(const XrPassthroughColorMapMonoToMonoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorMapMonoToMonoFB &() const { return *reinterpret_cast<const XrPassthroughColorMapMonoToMonoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorMapMonoToMonoFB &() {
            return *reinterpret_cast<XrPassthroughColorMapMonoToMonoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorMapMonoToMonoFB
        XrPassthroughColorMapMonoToMonoFB const* get() const noexcept { return reinterpret_cast<XrPassthroughColorMapMonoToMonoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorMapMonoToMonoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorMapMonoToMonoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughColorMapMonoToMonoFB{};next = oldNext;}
            return reinterpret_cast<XrPassthroughColorMapMonoToMonoFB*>(this);
        }
        uint8_t textureColorMap[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB];
    };
     static_assert(sizeof(XrPassthroughColorMapMonoToMonoFB) == sizeof(PassthroughColorMapMonoToMonoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapMonoToMonoFB pointer to const from a PassthroughColorMapMonoToMonoFB reference to const.
 * @relates PassthroughColorMapMonoToMonoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToMonoFB const* get(PassthroughColorMapMonoToMonoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorMapMonoToMonoFB as the address of a raw XrPassthroughColorMapMonoToMonoFB
 * @relates PassthroughColorMapMonoToMonoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToMonoFB * put(PassthroughColorMapMonoToMonoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughBrightnessContrastSaturationFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughBrightnessContrastSaturationFB>
 * @xrentity{XrPassthroughBrightnessContrastSaturationFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughBrightnessContrastSaturationFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughBrightnessContrastSaturationFB (
 float brightness_,  float contrast_,  float saturation_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughBrightnessContrastSaturationFB
, next_)
, brightness {brightness_}
, contrast {contrast_}
, saturation {saturation_}
        {
        }


        //! Default/empty constructor
                 PassthroughBrightnessContrastSaturationFB (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughBrightnessContrastSaturationFB
             , next_)
, brightness{0.0f}
, contrast{0.0f}
, saturation{0.0f}
            {}

        //! Default copy constructor
        PassthroughBrightnessContrastSaturationFB(const PassthroughBrightnessContrastSaturationFB& rhs) = default;
        //! Default copy assignment
        PassthroughBrightnessContrastSaturationFB& operator=(const PassthroughBrightnessContrastSaturationFB& rhs) = default;
        //! Copy construct from raw
        PassthroughBrightnessContrastSaturationFB(const XrPassthroughBrightnessContrastSaturationFB& rhs) : PassthroughBrightnessContrastSaturationFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughBrightnessContrastSaturationFB& operator=(const XrPassthroughBrightnessContrastSaturationFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughBrightnessContrastSaturationFB &() const { return *reinterpret_cast<const XrPassthroughBrightnessContrastSaturationFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughBrightnessContrastSaturationFB &() {
            return *reinterpret_cast<XrPassthroughBrightnessContrastSaturationFB*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughBrightnessContrastSaturationFB
        XrPassthroughBrightnessContrastSaturationFB const* get() const noexcept { return reinterpret_cast<XrPassthroughBrightnessContrastSaturationFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughBrightnessContrastSaturationFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughBrightnessContrastSaturationFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughBrightnessContrastSaturationFB{};next = oldNext;}
            return reinterpret_cast<XrPassthroughBrightnessContrastSaturationFB*>(this);
        }
        float brightness;
        float contrast;
        float saturation;
    };
     static_assert(sizeof(XrPassthroughBrightnessContrastSaturationFB) == sizeof(PassthroughBrightnessContrastSaturationFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughBrightnessContrastSaturationFB pointer to const from a PassthroughBrightnessContrastSaturationFB reference to const.
 * @relates PassthroughBrightnessContrastSaturationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughBrightnessContrastSaturationFB const* get(PassthroughBrightnessContrastSaturationFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughBrightnessContrastSaturationFB as the address of a raw XrPassthroughBrightnessContrastSaturationFB
 * @relates PassthroughBrightnessContrastSaturationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughBrightnessContrastSaturationFB * put(PassthroughBrightnessContrastSaturationFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_passthrough
/*!
 * C++ projection of XrEventDataPassthroughStateChangedFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPassthroughStateChangedFB>
 * @xrentity{XrEventDataPassthroughStateChangedFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataPassthroughStateChangedFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataPassthroughStateChangedFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataPassthroughStateChangedFB
             , next_)
            {}

        //! Default copy constructor
        EventDataPassthroughStateChangedFB(const EventDataPassthroughStateChangedFB& rhs) = default;
        //! Default copy assignment
        EventDataPassthroughStateChangedFB& operator=(const EventDataPassthroughStateChangedFB& rhs) = default;
        //! Copy construct from raw
        EventDataPassthroughStateChangedFB(const XrEventDataPassthroughStateChangedFB& rhs) : EventDataPassthroughStateChangedFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataPassthroughStateChangedFB& operator=(const XrEventDataPassthroughStateChangedFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataPassthroughStateChangedFB &() const { return *reinterpret_cast<const XrEventDataPassthroughStateChangedFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataPassthroughStateChangedFB &() {
            return *reinterpret_cast<XrEventDataPassthroughStateChangedFB*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataPassthroughStateChangedFB
        XrEventDataPassthroughStateChangedFB const* get() const noexcept { return reinterpret_cast<XrEventDataPassthroughStateChangedFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataPassthroughStateChangedFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataPassthroughStateChangedFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataPassthroughStateChangedFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataPassthroughStateChangedFB*>(this);
        }
        PassthroughStateChangedFlagsFB flags;
    };
     static_assert(sizeof(XrEventDataPassthroughStateChangedFB) == sizeof(EventDataPassthroughStateChangedFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataPassthroughStateChangedFB pointer to const from a EventDataPassthroughStateChangedFB reference to const.
 * @relates EventDataPassthroughStateChangedFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataPassthroughStateChangedFB const* get(EventDataPassthroughStateChangedFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataPassthroughStateChangedFB as the address of a raw XrEventDataPassthroughStateChangedFB
 * @relates EventDataPassthroughStateChangedFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataPassthroughStateChangedFB * put(EventDataPassthroughStateChangedFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough































    #ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelPathInfoFB
 * 
 * Provided by the `XR_FB_render_model` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPathInfoFB>
 * @xrentity{XrRenderModelPathInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS RenderModelPathInfoFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 RenderModelPathInfoFB (
            void * next_ = nullptr)

: Parent(StructureType::RenderModelPathInfoFB
             , next_)
            {}

        //! Default copy constructor
        RenderModelPathInfoFB(const RenderModelPathInfoFB& rhs) = default;
        //! Default copy assignment
        RenderModelPathInfoFB& operator=(const RenderModelPathInfoFB& rhs) = default;
        //! Copy construct from raw
        RenderModelPathInfoFB(const XrRenderModelPathInfoFB& rhs) : RenderModelPathInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        RenderModelPathInfoFB& operator=(const XrRenderModelPathInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRenderModelPathInfoFB &() const { return *reinterpret_cast<const XrRenderModelPathInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRenderModelPathInfoFB &() {
            return *reinterpret_cast<XrRenderModelPathInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRenderModelPathInfoFB
        XrRenderModelPathInfoFB const* get() const noexcept { return reinterpret_cast<XrRenderModelPathInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelPathInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrRenderModelPathInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = RenderModelPathInfoFB{};next = oldNext;}
            return reinterpret_cast<XrRenderModelPathInfoFB*>(this);
        }
        Path path;
    };
     static_assert(sizeof(XrRenderModelPathInfoFB) == sizeof(RenderModelPathInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRenderModelPathInfoFB pointer to const from a RenderModelPathInfoFB reference to const.
 * @relates RenderModelPathInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelPathInfoFB const* get(RenderModelPathInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPathInfoFB as the address of a raw XrRenderModelPathInfoFB
 * @relates RenderModelPathInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelPathInfoFB * put(RenderModelPathInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_render_model































    #ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelPropertiesFB
 * 
 * Provided by the `XR_FB_render_model` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPropertiesFB>
 * @xrentity{XrRenderModelPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS RenderModelPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 RenderModelPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::RenderModelPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        RenderModelPropertiesFB(const RenderModelPropertiesFB& rhs) = default;
        //! Default copy assignment
        RenderModelPropertiesFB& operator=(const RenderModelPropertiesFB& rhs) = default;
        //! Copy construct from raw
        RenderModelPropertiesFB(const XrRenderModelPropertiesFB& rhs) : RenderModelPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        RenderModelPropertiesFB& operator=(const XrRenderModelPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRenderModelPropertiesFB &() const { return *reinterpret_cast<const XrRenderModelPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRenderModelPropertiesFB &() {
            return *reinterpret_cast<XrRenderModelPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRenderModelPropertiesFB
        XrRenderModelPropertiesFB const* get() const noexcept { return reinterpret_cast<XrRenderModelPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrRenderModelPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = RenderModelPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrRenderModelPropertiesFB*>(this);
        }
        uint32_t vendorId;
        char modelName[XR_MAX_RENDER_MODEL_NAME_SIZE_FB];
        RenderModelKeyFB modelKey;
        uint32_t modelVersion;
        RenderModelFlagsFB flags;
    };
     static_assert(sizeof(XrRenderModelPropertiesFB) == sizeof(RenderModelPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRenderModelPropertiesFB pointer to const from a RenderModelPropertiesFB reference to const.
 * @relates RenderModelPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelPropertiesFB const* get(RenderModelPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPropertiesFB as the address of a raw XrRenderModelPropertiesFB
 * @relates RenderModelPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelPropertiesFB * put(RenderModelPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_render_model































    #ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelBufferFB
 * 
 * Provided by the `XR_FB_render_model` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelBufferFB>
 * @xrentity{XrRenderModelBufferFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS RenderModelBufferFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 RenderModelBufferFB (
            void * next_ = nullptr)

: Parent(StructureType::RenderModelBufferFB
             , next_)
            {}

        //! Default copy constructor
        RenderModelBufferFB(const RenderModelBufferFB& rhs) = default;
        //! Default copy assignment
        RenderModelBufferFB& operator=(const RenderModelBufferFB& rhs) = default;
        //! Copy construct from raw
        RenderModelBufferFB(const XrRenderModelBufferFB& rhs) : RenderModelBufferFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        RenderModelBufferFB& operator=(const XrRenderModelBufferFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRenderModelBufferFB &() const { return *reinterpret_cast<const XrRenderModelBufferFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRenderModelBufferFB &() {
            return *reinterpret_cast<XrRenderModelBufferFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRenderModelBufferFB
        XrRenderModelBufferFB const* get() const noexcept { return reinterpret_cast<XrRenderModelBufferFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelBufferFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrRenderModelBufferFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = RenderModelBufferFB{};next = oldNext;}
            return reinterpret_cast<XrRenderModelBufferFB*>(this);
        }
        uint32_t bufferCapacityInput;
        uint32_t bufferCountOutput;
        uint8_t* buffer;
    };
     static_assert(sizeof(XrRenderModelBufferFB) == sizeof(RenderModelBufferFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRenderModelBufferFB pointer to const from a RenderModelBufferFB reference to const.
 * @relates RenderModelBufferFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelBufferFB const* get(RenderModelBufferFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelBufferFB as the address of a raw XrRenderModelBufferFB
 * @relates RenderModelBufferFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelBufferFB * put(RenderModelBufferFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_render_model































    #ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelLoadInfoFB
 * 
 * Provided by the `XR_FB_render_model` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelLoadInfoFB>
 * @xrentity{XrRenderModelLoadInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS RenderModelLoadInfoFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 RenderModelLoadInfoFB (
            void * next_ = nullptr)

: Parent(StructureType::RenderModelLoadInfoFB
             , next_)
            {}

        //! Default copy constructor
        RenderModelLoadInfoFB(const RenderModelLoadInfoFB& rhs) = default;
        //! Default copy assignment
        RenderModelLoadInfoFB& operator=(const RenderModelLoadInfoFB& rhs) = default;
        //! Copy construct from raw
        RenderModelLoadInfoFB(const XrRenderModelLoadInfoFB& rhs) : RenderModelLoadInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        RenderModelLoadInfoFB& operator=(const XrRenderModelLoadInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRenderModelLoadInfoFB &() const { return *reinterpret_cast<const XrRenderModelLoadInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRenderModelLoadInfoFB &() {
            return *reinterpret_cast<XrRenderModelLoadInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRenderModelLoadInfoFB
        XrRenderModelLoadInfoFB const* get() const noexcept { return reinterpret_cast<XrRenderModelLoadInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelLoadInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrRenderModelLoadInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = RenderModelLoadInfoFB{};next = oldNext;}
            return reinterpret_cast<XrRenderModelLoadInfoFB*>(this);
        }
        RenderModelKeyFB modelKey;
    };
     static_assert(sizeof(XrRenderModelLoadInfoFB) == sizeof(RenderModelLoadInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRenderModelLoadInfoFB pointer to const from a RenderModelLoadInfoFB reference to const.
 * @relates RenderModelLoadInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelLoadInfoFB const* get(RenderModelLoadInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelLoadInfoFB as the address of a raw XrRenderModelLoadInfoFB
 * @relates RenderModelLoadInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelLoadInfoFB * put(RenderModelLoadInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_render_model































    #ifdef XR_FB_render_model
/*!
 * C++ projection of XrSystemRenderModelPropertiesFB
 * 
 * Provided by the `XR_FB_render_model` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemRenderModelPropertiesFB>
 * @xrentity{XrSystemRenderModelPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemRenderModelPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemRenderModelPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemRenderModelPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemRenderModelPropertiesFB(const SystemRenderModelPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemRenderModelPropertiesFB& operator=(const SystemRenderModelPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemRenderModelPropertiesFB(const XrSystemRenderModelPropertiesFB& rhs) : SystemRenderModelPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemRenderModelPropertiesFB& operator=(const XrSystemRenderModelPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemRenderModelPropertiesFB &() const { return *reinterpret_cast<const XrSystemRenderModelPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemRenderModelPropertiesFB &() {
            return *reinterpret_cast<XrSystemRenderModelPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemRenderModelPropertiesFB
        XrSystemRenderModelPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemRenderModelPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemRenderModelPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemRenderModelPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemRenderModelPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemRenderModelPropertiesFB*>(this);
        }
        Bool32 supportsRenderModelLoading;
    };
     static_assert(sizeof(XrSystemRenderModelPropertiesFB) == sizeof(SystemRenderModelPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemRenderModelPropertiesFB pointer to const from a SystemRenderModelPropertiesFB reference to const.
 * @relates SystemRenderModelPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemRenderModelPropertiesFB const* get(SystemRenderModelPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemRenderModelPropertiesFB as the address of a raw XrSystemRenderModelPropertiesFB
 * @relates SystemRenderModelPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemRenderModelPropertiesFB * put(SystemRenderModelPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_render_model































    #ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelCapabilitiesRequestFB
 * 
 * Provided by the `XR_FB_render_model` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelCapabilitiesRequestFB>
 * @xrentity{XrRenderModelCapabilitiesRequestFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS RenderModelCapabilitiesRequestFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 RenderModelCapabilitiesRequestFB (
            void * next_ = nullptr)

: Parent(StructureType::RenderModelCapabilitiesRequestFB
             , next_)
            {}

        //! Default copy constructor
        RenderModelCapabilitiesRequestFB(const RenderModelCapabilitiesRequestFB& rhs) = default;
        //! Default copy assignment
        RenderModelCapabilitiesRequestFB& operator=(const RenderModelCapabilitiesRequestFB& rhs) = default;
        //! Copy construct from raw
        RenderModelCapabilitiesRequestFB(const XrRenderModelCapabilitiesRequestFB& rhs) : RenderModelCapabilitiesRequestFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        RenderModelCapabilitiesRequestFB& operator=(const XrRenderModelCapabilitiesRequestFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRenderModelCapabilitiesRequestFB &() const { return *reinterpret_cast<const XrRenderModelCapabilitiesRequestFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRenderModelCapabilitiesRequestFB &() {
            return *reinterpret_cast<XrRenderModelCapabilitiesRequestFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRenderModelCapabilitiesRequestFB
        XrRenderModelCapabilitiesRequestFB const* get() const noexcept { return reinterpret_cast<XrRenderModelCapabilitiesRequestFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelCapabilitiesRequestFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrRenderModelCapabilitiesRequestFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = RenderModelCapabilitiesRequestFB{};next = oldNext;}
            return reinterpret_cast<XrRenderModelCapabilitiesRequestFB*>(this);
        }
        RenderModelFlagsFB flags;
    };
     static_assert(sizeof(XrRenderModelCapabilitiesRequestFB) == sizeof(RenderModelCapabilitiesRequestFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRenderModelCapabilitiesRequestFB pointer to const from a RenderModelCapabilitiesRequestFB reference to const.
 * @relates RenderModelCapabilitiesRequestFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelCapabilitiesRequestFB const* get(RenderModelCapabilitiesRequestFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelCapabilitiesRequestFB as the address of a raw XrRenderModelCapabilitiesRequestFB
 * @relates RenderModelCapabilitiesRequestFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRenderModelCapabilitiesRequestFB * put(RenderModelCapabilitiesRequestFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_render_model































    #ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrViewLocateFoveatedRenderingVARJO
 * 
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateFoveatedRenderingVARJO>
 * @xrentity{XrViewLocateFoveatedRenderingVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ViewLocateFoveatedRenderingVARJO : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ViewLocateFoveatedRenderingVARJO (
 const Bool32& foveatedRenderingActive_,  const void * next_ = nullptr                  )
: Parent(StructureType::ViewLocateFoveatedRenderingVARJO
, next_)
, foveatedRenderingActive {foveatedRenderingActive_}
        {
        }


        //! Default/empty constructor
                 ViewLocateFoveatedRenderingVARJO (
            const void * next_ = nullptr)

: Parent(StructureType::ViewLocateFoveatedRenderingVARJO
             , next_)
, foveatedRenderingActive{false}
            {}

        //! Default copy constructor
        ViewLocateFoveatedRenderingVARJO(const ViewLocateFoveatedRenderingVARJO& rhs) = default;
        //! Default copy assignment
        ViewLocateFoveatedRenderingVARJO& operator=(const ViewLocateFoveatedRenderingVARJO& rhs) = default;
        //! Copy construct from raw
        ViewLocateFoveatedRenderingVARJO(const XrViewLocateFoveatedRenderingVARJO& rhs) : ViewLocateFoveatedRenderingVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ViewLocateFoveatedRenderingVARJO& operator=(const XrViewLocateFoveatedRenderingVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrViewLocateFoveatedRenderingVARJO &() const { return *reinterpret_cast<const XrViewLocateFoveatedRenderingVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrViewLocateFoveatedRenderingVARJO &() {
            return *reinterpret_cast<XrViewLocateFoveatedRenderingVARJO*>(this);
        }

        //! Accessor for this as the address of a raw XrViewLocateFoveatedRenderingVARJO
        XrViewLocateFoveatedRenderingVARJO const* get() const noexcept { return reinterpret_cast<XrViewLocateFoveatedRenderingVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrViewLocateFoveatedRenderingVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrViewLocateFoveatedRenderingVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ViewLocateFoveatedRenderingVARJO{};next = oldNext;}
            return reinterpret_cast<XrViewLocateFoveatedRenderingVARJO*>(this);
        }
        Bool32 foveatedRenderingActive;
    };
     static_assert(sizeof(XrViewLocateFoveatedRenderingVARJO) == sizeof(ViewLocateFoveatedRenderingVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrViewLocateFoveatedRenderingVARJO pointer to const from a ViewLocateFoveatedRenderingVARJO reference to const.
 * @relates ViewLocateFoveatedRenderingVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewLocateFoveatedRenderingVARJO const* get(ViewLocateFoveatedRenderingVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewLocateFoveatedRenderingVARJO as the address of a raw XrViewLocateFoveatedRenderingVARJO
 * @relates ViewLocateFoveatedRenderingVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrViewLocateFoveatedRenderingVARJO * put(ViewLocateFoveatedRenderingVARJO &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_VARJO_foveated_rendering































    #ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrFoveatedViewConfigurationViewVARJO
 * 
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveatedViewConfigurationViewVARJO>
 * @xrentity{XrFoveatedViewConfigurationViewVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveatedViewConfigurationViewVARJO : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 FoveatedViewConfigurationViewVARJO (
            void * next_ = nullptr)

: Parent(StructureType::FoveatedViewConfigurationViewVARJO
             , next_)
            {}

        //! Default copy constructor
        FoveatedViewConfigurationViewVARJO(const FoveatedViewConfigurationViewVARJO& rhs) = default;
        //! Default copy assignment
        FoveatedViewConfigurationViewVARJO& operator=(const FoveatedViewConfigurationViewVARJO& rhs) = default;
        //! Copy construct from raw
        FoveatedViewConfigurationViewVARJO(const XrFoveatedViewConfigurationViewVARJO& rhs) : FoveatedViewConfigurationViewVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveatedViewConfigurationViewVARJO& operator=(const XrFoveatedViewConfigurationViewVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveatedViewConfigurationViewVARJO &() const { return *reinterpret_cast<const XrFoveatedViewConfigurationViewVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveatedViewConfigurationViewVARJO &() {
            return *reinterpret_cast<XrFoveatedViewConfigurationViewVARJO*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveatedViewConfigurationViewVARJO
        XrFoveatedViewConfigurationViewVARJO const* get() const noexcept { return reinterpret_cast<XrFoveatedViewConfigurationViewVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveatedViewConfigurationViewVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveatedViewConfigurationViewVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveatedViewConfigurationViewVARJO{};next = oldNext;}
            return reinterpret_cast<XrFoveatedViewConfigurationViewVARJO*>(this);
        }
        Bool32 foveatedRenderingActive;
    };
     static_assert(sizeof(XrFoveatedViewConfigurationViewVARJO) == sizeof(FoveatedViewConfigurationViewVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveatedViewConfigurationViewVARJO pointer to const from a FoveatedViewConfigurationViewVARJO reference to const.
 * @relates FoveatedViewConfigurationViewVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveatedViewConfigurationViewVARJO const* get(FoveatedViewConfigurationViewVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveatedViewConfigurationViewVARJO as the address of a raw XrFoveatedViewConfigurationViewVARJO
 * @relates FoveatedViewConfigurationViewVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveatedViewConfigurationViewVARJO * put(FoveatedViewConfigurationViewVARJO &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_VARJO_foveated_rendering































    #ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrSystemFoveatedRenderingPropertiesVARJO
 * 
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFoveatedRenderingPropertiesVARJO>
 * @xrentity{XrSystemFoveatedRenderingPropertiesVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemFoveatedRenderingPropertiesVARJO : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemFoveatedRenderingPropertiesVARJO (
            void * next_ = nullptr)

: Parent(StructureType::SystemFoveatedRenderingPropertiesVARJO
             , next_)
            {}

        //! Default copy constructor
        SystemFoveatedRenderingPropertiesVARJO(const SystemFoveatedRenderingPropertiesVARJO& rhs) = default;
        //! Default copy assignment
        SystemFoveatedRenderingPropertiesVARJO& operator=(const SystemFoveatedRenderingPropertiesVARJO& rhs) = default;
        //! Copy construct from raw
        SystemFoveatedRenderingPropertiesVARJO(const XrSystemFoveatedRenderingPropertiesVARJO& rhs) : SystemFoveatedRenderingPropertiesVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemFoveatedRenderingPropertiesVARJO& operator=(const XrSystemFoveatedRenderingPropertiesVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemFoveatedRenderingPropertiesVARJO &() const { return *reinterpret_cast<const XrSystemFoveatedRenderingPropertiesVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemFoveatedRenderingPropertiesVARJO &() {
            return *reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemFoveatedRenderingPropertiesVARJO
        XrSystemFoveatedRenderingPropertiesVARJO const* get() const noexcept { return reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemFoveatedRenderingPropertiesVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemFoveatedRenderingPropertiesVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemFoveatedRenderingPropertiesVARJO{};next = oldNext;}
            return reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO*>(this);
        }
        Bool32 supportsFoveatedRendering;
    };
     static_assert(sizeof(XrSystemFoveatedRenderingPropertiesVARJO) == sizeof(SystemFoveatedRenderingPropertiesVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemFoveatedRenderingPropertiesVARJO pointer to const from a SystemFoveatedRenderingPropertiesVARJO reference to const.
 * @relates SystemFoveatedRenderingPropertiesVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFoveatedRenderingPropertiesVARJO const* get(SystemFoveatedRenderingPropertiesVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemFoveatedRenderingPropertiesVARJO as the address of a raw XrSystemFoveatedRenderingPropertiesVARJO
 * @relates SystemFoveatedRenderingPropertiesVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFoveatedRenderingPropertiesVARJO * put(SystemFoveatedRenderingPropertiesVARJO &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_VARJO_foveated_rendering































    #ifdef XR_VARJO_composition_layer_depth_test
/*!
 * C++ projection of XrCompositionLayerDepthTestVARJO
 * 
 * Provided by the `XR_VARJO_composition_layer_depth_test` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthTestVARJO>
 * @xrentity{XrCompositionLayerDepthTestVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerDepthTestVARJO : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerDepthTestVARJO (
 float depthTestRangeNearZ_,  float depthTestRangeFarZ_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerDepthTestVARJO
, next_)
, depthTestRangeNearZ {depthTestRangeNearZ_}
, depthTestRangeFarZ {depthTestRangeFarZ_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerDepthTestVARJO (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerDepthTestVARJO
             , next_)
, depthTestRangeNearZ{0.0f}
, depthTestRangeFarZ{0.0f}
            {}

        //! Default copy constructor
        CompositionLayerDepthTestVARJO(const CompositionLayerDepthTestVARJO& rhs) = default;
        //! Default copy assignment
        CompositionLayerDepthTestVARJO& operator=(const CompositionLayerDepthTestVARJO& rhs) = default;
        //! Copy construct from raw
        CompositionLayerDepthTestVARJO(const XrCompositionLayerDepthTestVARJO& rhs) : CompositionLayerDepthTestVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerDepthTestVARJO& operator=(const XrCompositionLayerDepthTestVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerDepthTestVARJO &() const { return *reinterpret_cast<const XrCompositionLayerDepthTestVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerDepthTestVARJO &() {
            return *reinterpret_cast<XrCompositionLayerDepthTestVARJO*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerDepthTestVARJO
        XrCompositionLayerDepthTestVARJO const* get() const noexcept { return reinterpret_cast<XrCompositionLayerDepthTestVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerDepthTestVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerDepthTestVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerDepthTestVARJO{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerDepthTestVARJO*>(this);
        }
        float depthTestRangeNearZ;
        float depthTestRangeFarZ;
    };
     static_assert(sizeof(XrCompositionLayerDepthTestVARJO) == sizeof(CompositionLayerDepthTestVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthTestVARJO pointer to const from a CompositionLayerDepthTestVARJO reference to const.
 * @relates CompositionLayerDepthTestVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerDepthTestVARJO const* get(CompositionLayerDepthTestVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthTestVARJO as the address of a raw XrCompositionLayerDepthTestVARJO
 * @relates CompositionLayerDepthTestVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerDepthTestVARJO * put(CompositionLayerDepthTestVARJO &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_VARJO_composition_layer_depth_test































    #ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrSystemMarkerTrackingPropertiesVARJO
 * 
 * Provided by the `XR_VARJO_marker_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemMarkerTrackingPropertiesVARJO>
 * @xrentity{XrSystemMarkerTrackingPropertiesVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemMarkerTrackingPropertiesVARJO : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemMarkerTrackingPropertiesVARJO (
            void * next_ = nullptr)

: Parent(StructureType::SystemMarkerTrackingPropertiesVARJO
             , next_)
            {}

        //! Default copy constructor
        SystemMarkerTrackingPropertiesVARJO(const SystemMarkerTrackingPropertiesVARJO& rhs) = default;
        //! Default copy assignment
        SystemMarkerTrackingPropertiesVARJO& operator=(const SystemMarkerTrackingPropertiesVARJO& rhs) = default;
        //! Copy construct from raw
        SystemMarkerTrackingPropertiesVARJO(const XrSystemMarkerTrackingPropertiesVARJO& rhs) : SystemMarkerTrackingPropertiesVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemMarkerTrackingPropertiesVARJO& operator=(const XrSystemMarkerTrackingPropertiesVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemMarkerTrackingPropertiesVARJO &() const { return *reinterpret_cast<const XrSystemMarkerTrackingPropertiesVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemMarkerTrackingPropertiesVARJO &() {
            return *reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemMarkerTrackingPropertiesVARJO
        XrSystemMarkerTrackingPropertiesVARJO const* get() const noexcept { return reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemMarkerTrackingPropertiesVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemMarkerTrackingPropertiesVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemMarkerTrackingPropertiesVARJO{};next = oldNext;}
            return reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO*>(this);
        }
        Bool32 supportsMarkerTracking;
    };
     static_assert(sizeof(XrSystemMarkerTrackingPropertiesVARJO) == sizeof(SystemMarkerTrackingPropertiesVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemMarkerTrackingPropertiesVARJO pointer to const from a SystemMarkerTrackingPropertiesVARJO reference to const.
 * @relates SystemMarkerTrackingPropertiesVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemMarkerTrackingPropertiesVARJO const* get(SystemMarkerTrackingPropertiesVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemMarkerTrackingPropertiesVARJO as the address of a raw XrSystemMarkerTrackingPropertiesVARJO
 * @relates SystemMarkerTrackingPropertiesVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemMarkerTrackingPropertiesVARJO * put(SystemMarkerTrackingPropertiesVARJO &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_VARJO_marker_tracking































    #ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrEventDataMarkerTrackingUpdateVARJO
 * 
 * Provided by the `XR_VARJO_marker_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMarkerTrackingUpdateVARJO>
 * @xrentity{XrEventDataMarkerTrackingUpdateVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataMarkerTrackingUpdateVARJO : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataMarkerTrackingUpdateVARJO (
            void * next_ = nullptr)

: Parent(StructureType::EventDataMarkerTrackingUpdateVARJO
             , next_)
            {}

        //! Default copy constructor
        EventDataMarkerTrackingUpdateVARJO(const EventDataMarkerTrackingUpdateVARJO& rhs) = default;
        //! Default copy assignment
        EventDataMarkerTrackingUpdateVARJO& operator=(const EventDataMarkerTrackingUpdateVARJO& rhs) = default;
        //! Copy construct from raw
        EventDataMarkerTrackingUpdateVARJO(const XrEventDataMarkerTrackingUpdateVARJO& rhs) : EventDataMarkerTrackingUpdateVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataMarkerTrackingUpdateVARJO& operator=(const XrEventDataMarkerTrackingUpdateVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataMarkerTrackingUpdateVARJO &() const { return *reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataMarkerTrackingUpdateVARJO &() {
            return *reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataMarkerTrackingUpdateVARJO
        XrEventDataMarkerTrackingUpdateVARJO const* get() const noexcept { return reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataMarkerTrackingUpdateVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataMarkerTrackingUpdateVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataMarkerTrackingUpdateVARJO{};next = oldNext;}
            return reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO*>(this);
        }
        uint64_t markerId;
        Bool32 isActive;
        Bool32 isPredicted;
        Time time;
    };
     static_assert(sizeof(XrEventDataMarkerTrackingUpdateVARJO) == sizeof(EventDataMarkerTrackingUpdateVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataMarkerTrackingUpdateVARJO pointer to const from a EventDataMarkerTrackingUpdateVARJO reference to const.
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataMarkerTrackingUpdateVARJO const* get(EventDataMarkerTrackingUpdateVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataMarkerTrackingUpdateVARJO as the address of a raw XrEventDataMarkerTrackingUpdateVARJO
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataMarkerTrackingUpdateVARJO * put(EventDataMarkerTrackingUpdateVARJO &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataMarkerTrackingUpdateVARJO as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataMarkerTrackingUpdateVARJO const& h) {
        return h.get_base();
    }
#endif  // XR_VARJO_marker_tracking































    #ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrMarkerSpaceCreateInfoVARJO
 * 
 * Provided by the `XR_VARJO_marker_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerSpaceCreateInfoVARJO>
 * @xrentity{XrMarkerSpaceCreateInfoVARJO}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS MarkerSpaceCreateInfoVARJO : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                MarkerSpaceCreateInfoVARJO (
 uint64_t markerId_,  const Posef& poseInMarkerSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::MarkerSpaceCreateInfoVARJO
, next_)
, markerId {markerId_}
, poseInMarkerSpace {poseInMarkerSpace_}
        {
        }


        //! Default/empty constructor
                 MarkerSpaceCreateInfoVARJO (
            const void * next_ = nullptr)

: Parent(StructureType::MarkerSpaceCreateInfoVARJO
             , next_)
, markerId{0}
, poseInMarkerSpace{}
            {}

        //! Default copy constructor
        MarkerSpaceCreateInfoVARJO(const MarkerSpaceCreateInfoVARJO& rhs) = default;
        //! Default copy assignment
        MarkerSpaceCreateInfoVARJO& operator=(const MarkerSpaceCreateInfoVARJO& rhs) = default;
        //! Copy construct from raw
        MarkerSpaceCreateInfoVARJO(const XrMarkerSpaceCreateInfoVARJO& rhs) : MarkerSpaceCreateInfoVARJO() {
            *put() = rhs;
        }
        //! Copy assign from raw
        MarkerSpaceCreateInfoVARJO& operator=(const XrMarkerSpaceCreateInfoVARJO& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrMarkerSpaceCreateInfoVARJO &() const { return *reinterpret_cast<const XrMarkerSpaceCreateInfoVARJO*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrMarkerSpaceCreateInfoVARJO &() {
            return *reinterpret_cast<XrMarkerSpaceCreateInfoVARJO*>(this);
        }

        //! Accessor for this as the address of a raw XrMarkerSpaceCreateInfoVARJO
        XrMarkerSpaceCreateInfoVARJO const* get() const noexcept { return reinterpret_cast<XrMarkerSpaceCreateInfoVARJO const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrMarkerSpaceCreateInfoVARJO.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrMarkerSpaceCreateInfoVARJO * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = MarkerSpaceCreateInfoVARJO{};next = oldNext;}
            return reinterpret_cast<XrMarkerSpaceCreateInfoVARJO*>(this);
        }
        uint64_t markerId;
        Posef poseInMarkerSpace;
    };
     static_assert(sizeof(XrMarkerSpaceCreateInfoVARJO) == sizeof(MarkerSpaceCreateInfoVARJO), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrMarkerSpaceCreateInfoVARJO pointer to const from a MarkerSpaceCreateInfoVARJO reference to const.
 * @relates MarkerSpaceCreateInfoVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoVARJO const* get(MarkerSpaceCreateInfoVARJO const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerSpaceCreateInfoVARJO as the address of a raw XrMarkerSpaceCreateInfoVARJO
 * @relates MarkerSpaceCreateInfoVARJO
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoVARJO * put(MarkerSpaceCreateInfoVARJO &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_VARJO_marker_tracking































    #ifdef XR_ML_frame_end_info
/*!
 * C++ projection of XrFrameEndInfoML
 * 
 * Provided by the `XR_ML_frame_end_info` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameEndInfoML>
 * @xrentity{XrFrameEndInfoML}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FrameEndInfoML : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FrameEndInfoML (
 float focusDistance_,  const FrameEndInfoFlagsML& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::FrameEndInfoML
, next_)
, focusDistance {focusDistance_}
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 FrameEndInfoML (
            const void * next_ = nullptr)

: Parent(StructureType::FrameEndInfoML
             , next_)
, focusDistance{0.0f}
, flags{}
            {}

        //! Default copy constructor
        FrameEndInfoML(const FrameEndInfoML& rhs) = default;
        //! Default copy assignment
        FrameEndInfoML& operator=(const FrameEndInfoML& rhs) = default;
        //! Copy construct from raw
        FrameEndInfoML(const XrFrameEndInfoML& rhs) : FrameEndInfoML() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FrameEndInfoML& operator=(const XrFrameEndInfoML& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFrameEndInfoML &() const { return *reinterpret_cast<const XrFrameEndInfoML*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFrameEndInfoML &() {
            return *reinterpret_cast<XrFrameEndInfoML*>(this);
        }

        //! Accessor for this as the address of a raw XrFrameEndInfoML
        XrFrameEndInfoML const* get() const noexcept { return reinterpret_cast<XrFrameEndInfoML const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFrameEndInfoML.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFrameEndInfoML * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FrameEndInfoML{};next = oldNext;}
            return reinterpret_cast<XrFrameEndInfoML*>(this);
        }
        float focusDistance;
        FrameEndInfoFlagsML flags;
    };
     static_assert(sizeof(XrFrameEndInfoML) == sizeof(FrameEndInfoML), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFrameEndInfoML pointer to const from a FrameEndInfoML reference to const.
 * @relates FrameEndInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameEndInfoML const* get(FrameEndInfoML const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameEndInfoML as the address of a raw XrFrameEndInfoML
 * @relates FrameEndInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFrameEndInfoML * put(FrameEndInfoML &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_ML_frame_end_info































    #ifdef XR_ML_global_dimmer
/*!
 * C++ projection of XrGlobalDimmerFrameEndInfoML
 * 
 * Provided by the `XR_ML_global_dimmer` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGlobalDimmerFrameEndInfoML>
 * @xrentity{XrGlobalDimmerFrameEndInfoML}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS GlobalDimmerFrameEndInfoML : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                GlobalDimmerFrameEndInfoML (
 float dimmerValue_,  const GlobalDimmerFrameEndInfoFlagsML& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::GlobalDimmerFrameEndInfoML
, next_)
, dimmerValue {dimmerValue_}
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 GlobalDimmerFrameEndInfoML (
            const void * next_ = nullptr)

: Parent(StructureType::GlobalDimmerFrameEndInfoML
             , next_)
, dimmerValue{0.0f}
, flags{}
            {}

        //! Default copy constructor
        GlobalDimmerFrameEndInfoML(const GlobalDimmerFrameEndInfoML& rhs) = default;
        //! Default copy assignment
        GlobalDimmerFrameEndInfoML& operator=(const GlobalDimmerFrameEndInfoML& rhs) = default;
        //! Copy construct from raw
        GlobalDimmerFrameEndInfoML(const XrGlobalDimmerFrameEndInfoML& rhs) : GlobalDimmerFrameEndInfoML() {
            *put() = rhs;
        }
        //! Copy assign from raw
        GlobalDimmerFrameEndInfoML& operator=(const XrGlobalDimmerFrameEndInfoML& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrGlobalDimmerFrameEndInfoML &() const { return *reinterpret_cast<const XrGlobalDimmerFrameEndInfoML*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrGlobalDimmerFrameEndInfoML &() {
            return *reinterpret_cast<XrGlobalDimmerFrameEndInfoML*>(this);
        }

        //! Accessor for this as the address of a raw XrGlobalDimmerFrameEndInfoML
        XrGlobalDimmerFrameEndInfoML const* get() const noexcept { return reinterpret_cast<XrGlobalDimmerFrameEndInfoML const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrGlobalDimmerFrameEndInfoML.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrGlobalDimmerFrameEndInfoML * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = GlobalDimmerFrameEndInfoML{};next = oldNext;}
            return reinterpret_cast<XrGlobalDimmerFrameEndInfoML*>(this);
        }
        float dimmerValue;
        GlobalDimmerFrameEndInfoFlagsML flags;
    };
     static_assert(sizeof(XrGlobalDimmerFrameEndInfoML) == sizeof(GlobalDimmerFrameEndInfoML), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrGlobalDimmerFrameEndInfoML pointer to const from a GlobalDimmerFrameEndInfoML reference to const.
 * @relates GlobalDimmerFrameEndInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGlobalDimmerFrameEndInfoML const* get(GlobalDimmerFrameEndInfoML const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing GlobalDimmerFrameEndInfoML as the address of a raw XrGlobalDimmerFrameEndInfoML
 * @relates GlobalDimmerFrameEndInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrGlobalDimmerFrameEndInfoML * put(GlobalDimmerFrameEndInfoML &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_ML_global_dimmer































    #ifdef XR_ML_compat
#if defined(XR_USE_PLATFORM_ML)
/*!
 * C++ projection of XrCoordinateSpaceCreateInfoML
 * 
 * Provided by the `XR_ML_compat` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCoordinateSpaceCreateInfoML>
 * @xrentity{XrCoordinateSpaceCreateInfoML}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CoordinateSpaceCreateInfoML : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CoordinateSpaceCreateInfoML (
 MLCoordinateFrameUID cfuid_,  const Posef& poseInCoordinateSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::CoordinateSpaceCreateInfoML
, next_)
, cfuid {cfuid_}
, poseInCoordinateSpace {poseInCoordinateSpace_}
        {
        }


        //! Default/empty constructor
                 CoordinateSpaceCreateInfoML (
            const void * next_ = nullptr)

: Parent(StructureType::CoordinateSpaceCreateInfoML
             , next_)
, cfuid{}
, poseInCoordinateSpace{}
            {}

        //! Default copy constructor
        CoordinateSpaceCreateInfoML(const CoordinateSpaceCreateInfoML& rhs) = default;
        //! Default copy assignment
        CoordinateSpaceCreateInfoML& operator=(const CoordinateSpaceCreateInfoML& rhs) = default;
        //! Copy construct from raw
        CoordinateSpaceCreateInfoML(const XrCoordinateSpaceCreateInfoML& rhs) : CoordinateSpaceCreateInfoML() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CoordinateSpaceCreateInfoML& operator=(const XrCoordinateSpaceCreateInfoML& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCoordinateSpaceCreateInfoML &() const { return *reinterpret_cast<const XrCoordinateSpaceCreateInfoML*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCoordinateSpaceCreateInfoML &() {
            return *reinterpret_cast<XrCoordinateSpaceCreateInfoML*>(this);
        }

        //! Accessor for this as the address of a raw XrCoordinateSpaceCreateInfoML
        XrCoordinateSpaceCreateInfoML const* get() const noexcept { return reinterpret_cast<XrCoordinateSpaceCreateInfoML const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCoordinateSpaceCreateInfoML.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCoordinateSpaceCreateInfoML * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CoordinateSpaceCreateInfoML{};next = oldNext;}
            return reinterpret_cast<XrCoordinateSpaceCreateInfoML*>(this);
        }
        MLCoordinateFrameUID cfuid;
        Posef poseInCoordinateSpace;
    };
     static_assert(sizeof(XrCoordinateSpaceCreateInfoML) == sizeof(CoordinateSpaceCreateInfoML), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCoordinateSpaceCreateInfoML pointer to const from a CoordinateSpaceCreateInfoML reference to const.
 * @relates CoordinateSpaceCreateInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCoordinateSpaceCreateInfoML const* get(CoordinateSpaceCreateInfoML const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CoordinateSpaceCreateInfoML as the address of a raw XrCoordinateSpaceCreateInfoML
 * @relates CoordinateSpaceCreateInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCoordinateSpaceCreateInfoML * put(CoordinateSpaceCreateInfoML &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_PLATFORM_ML)
#endif  // XR_ML_compat































    #ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerMSFT>
 * @xrentity{XrSceneMarkerMSFT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS SceneMarkerMSFT 
    {
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SceneMarkerMSFT (
            )

            {}

        //! Default copy constructor
        SceneMarkerMSFT(const SceneMarkerMSFT& rhs) = default;
        //! Default copy assignment
        SceneMarkerMSFT& operator=(const SceneMarkerMSFT& rhs) = default;
        //! Copy construct from raw
        SceneMarkerMSFT(const XrSceneMarkerMSFT& rhs) : SceneMarkerMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SceneMarkerMSFT& operator=(const XrSceneMarkerMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSceneMarkerMSFT &() const { return *reinterpret_cast<const XrSceneMarkerMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSceneMarkerMSFT &() {
            return *reinterpret_cast<XrSceneMarkerMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSceneMarkerMSFT
        XrSceneMarkerMSFT const* get() const noexcept { return reinterpret_cast<XrSceneMarkerMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerMSFT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrSceneMarkerMSFT * put(bool clear = true) noexcept {
            if (clear) {*this = SceneMarkerMSFT{};}
            return reinterpret_cast<XrSceneMarkerMSFT*>(this);
        }
        SceneMarkerTypeMSFT markerType;
        Time lastSeenTime;
        Offset2Df center;
        Extent2Df size;
    };
     static_assert(sizeof(XrSceneMarkerMSFT) == sizeof(SceneMarkerMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSceneMarkerMSFT pointer to const from a SceneMarkerMSFT reference to const.
 * @relates SceneMarkerMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerMSFT const* get(SceneMarkerMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerMSFT as the address of a raw XrSceneMarkerMSFT
 * @relates SceneMarkerMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerMSFT * put(SceneMarkerMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_scene_marker































    #ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkersMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkersMSFT>
 * @xrentity{XrSceneMarkersMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SceneMarkersMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SceneMarkersMSFT (
 uint32_t sceneMarkerCapacityInput_,  SceneMarkerMSFT* sceneMarkers_,  const void * next_ = nullptr                  )
: Parent(StructureType::SceneMarkersMSFT
, next_)
, sceneMarkerCapacityInput {sceneMarkerCapacityInput_}
, sceneMarkers {sceneMarkers_}
        {
        }


        //! Default/empty constructor
                 SceneMarkersMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SceneMarkersMSFT
             , next_)
, sceneMarkerCapacityInput{0}
, sceneMarkers{nullptr}
            {}

        //! Default copy constructor
        SceneMarkersMSFT(const SceneMarkersMSFT& rhs) = default;
        //! Default copy assignment
        SceneMarkersMSFT& operator=(const SceneMarkersMSFT& rhs) = default;
        //! Copy construct from raw
        SceneMarkersMSFT(const XrSceneMarkersMSFT& rhs) : SceneMarkersMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SceneMarkersMSFT& operator=(const XrSceneMarkersMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSceneMarkersMSFT &() const { return *reinterpret_cast<const XrSceneMarkersMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSceneMarkersMSFT &() {
            return *reinterpret_cast<XrSceneMarkersMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSceneMarkersMSFT
        XrSceneMarkersMSFT const* get() const noexcept { return reinterpret_cast<XrSceneMarkersMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkersMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSceneMarkersMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SceneMarkersMSFT{};next = oldNext;}
            return reinterpret_cast<XrSceneMarkersMSFT*>(this);
        }
        uint32_t sceneMarkerCapacityInput;
        SceneMarkerMSFT* sceneMarkers;
    };
     static_assert(sizeof(XrSceneMarkersMSFT) == sizeof(SceneMarkersMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSceneMarkersMSFT pointer to const from a SceneMarkersMSFT reference to const.
 * @relates SceneMarkersMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkersMSFT const* get(SceneMarkersMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkersMSFT as the address of a raw XrSceneMarkersMSFT
 * @relates SceneMarkersMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkersMSFT * put(SceneMarkersMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_scene_marker































    #ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerTypeFilterMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerTypeFilterMSFT>
 * @xrentity{XrSceneMarkerTypeFilterMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SceneMarkerTypeFilterMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SceneMarkerTypeFilterMSFT (
 uint32_t markerTypeCount_,  SceneMarkerTypeMSFT* markerTypes_,  const void * next_ = nullptr                  )
: Parent(StructureType::SceneMarkerTypeFilterMSFT
, next_)
, markerTypeCount {markerTypeCount_}
, markerTypes {markerTypes_}
        {
        }


        //! Default/empty constructor
                 SceneMarkerTypeFilterMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SceneMarkerTypeFilterMSFT
             , next_)
, markerTypeCount{0}
, markerTypes{nullptr}
            {}

        //! Default copy constructor
        SceneMarkerTypeFilterMSFT(const SceneMarkerTypeFilterMSFT& rhs) = default;
        //! Default copy assignment
        SceneMarkerTypeFilterMSFT& operator=(const SceneMarkerTypeFilterMSFT& rhs) = default;
        //! Copy construct from raw
        SceneMarkerTypeFilterMSFT(const XrSceneMarkerTypeFilterMSFT& rhs) : SceneMarkerTypeFilterMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SceneMarkerTypeFilterMSFT& operator=(const XrSceneMarkerTypeFilterMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSceneMarkerTypeFilterMSFT &() const { return *reinterpret_cast<const XrSceneMarkerTypeFilterMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSceneMarkerTypeFilterMSFT &() {
            return *reinterpret_cast<XrSceneMarkerTypeFilterMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSceneMarkerTypeFilterMSFT
        XrSceneMarkerTypeFilterMSFT const* get() const noexcept { return reinterpret_cast<XrSceneMarkerTypeFilterMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerTypeFilterMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSceneMarkerTypeFilterMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SceneMarkerTypeFilterMSFT{};next = oldNext;}
            return reinterpret_cast<XrSceneMarkerTypeFilterMSFT*>(this);
        }
        uint32_t markerTypeCount;
        SceneMarkerTypeMSFT* markerTypes;
    };
     static_assert(sizeof(XrSceneMarkerTypeFilterMSFT) == sizeof(SceneMarkerTypeFilterMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSceneMarkerTypeFilterMSFT pointer to const from a SceneMarkerTypeFilterMSFT reference to const.
 * @relates SceneMarkerTypeFilterMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerTypeFilterMSFT const* get(SceneMarkerTypeFilterMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerTypeFilterMSFT as the address of a raw XrSceneMarkerTypeFilterMSFT
 * @relates SceneMarkerTypeFilterMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerTypeFilterMSFT * put(SceneMarkerTypeFilterMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_scene_marker































    #ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerQRCodeMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerQRCodeMSFT>
 * @xrentity{XrSceneMarkerQRCodeMSFT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS SceneMarkerQRCodeMSFT 
    {
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SceneMarkerQRCodeMSFT (
            )

            {}

        //! Default copy constructor
        SceneMarkerQRCodeMSFT(const SceneMarkerQRCodeMSFT& rhs) = default;
        //! Default copy assignment
        SceneMarkerQRCodeMSFT& operator=(const SceneMarkerQRCodeMSFT& rhs) = default;
        //! Copy construct from raw
        SceneMarkerQRCodeMSFT(const XrSceneMarkerQRCodeMSFT& rhs) : SceneMarkerQRCodeMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SceneMarkerQRCodeMSFT& operator=(const XrSceneMarkerQRCodeMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSceneMarkerQRCodeMSFT &() const { return *reinterpret_cast<const XrSceneMarkerQRCodeMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSceneMarkerQRCodeMSFT &() {
            return *reinterpret_cast<XrSceneMarkerQRCodeMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSceneMarkerQRCodeMSFT
        XrSceneMarkerQRCodeMSFT const* get() const noexcept { return reinterpret_cast<XrSceneMarkerQRCodeMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerQRCodeMSFT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrSceneMarkerQRCodeMSFT * put(bool clear = true) noexcept {
            if (clear) {*this = SceneMarkerQRCodeMSFT{};}
            return reinterpret_cast<XrSceneMarkerQRCodeMSFT*>(this);
        }
        SceneMarkerQRCodeSymbolTypeMSFT symbolType;
        uint8_t version;
    };
     static_assert(sizeof(XrSceneMarkerQRCodeMSFT) == sizeof(SceneMarkerQRCodeMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSceneMarkerQRCodeMSFT pointer to const from a SceneMarkerQRCodeMSFT reference to const.
 * @relates SceneMarkerQRCodeMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerQRCodeMSFT const* get(SceneMarkerQRCodeMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerQRCodeMSFT as the address of a raw XrSceneMarkerQRCodeMSFT
 * @relates SceneMarkerQRCodeMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerQRCodeMSFT * put(SceneMarkerQRCodeMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_scene_marker































    #ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerQRCodesMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerQRCodesMSFT>
 * @xrentity{XrSceneMarkerQRCodesMSFT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SceneMarkerQRCodesMSFT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SceneMarkerQRCodesMSFT (
 uint32_t qrCodeCapacityInput_,  SceneMarkerQRCodeMSFT* qrCodes_,  const void * next_ = nullptr                  )
: Parent(StructureType::SceneMarkerQrCodesMSFT
, next_)
, qrCodeCapacityInput {qrCodeCapacityInput_}
, qrCodes {qrCodes_}
        {
        }


        //! Default/empty constructor
                 SceneMarkerQRCodesMSFT (
            const void * next_ = nullptr)

: Parent(StructureType::SceneMarkerQrCodesMSFT
             , next_)
, qrCodeCapacityInput{0}
, qrCodes{nullptr}
            {}

        //! Default copy constructor
        SceneMarkerQRCodesMSFT(const SceneMarkerQRCodesMSFT& rhs) = default;
        //! Default copy assignment
        SceneMarkerQRCodesMSFT& operator=(const SceneMarkerQRCodesMSFT& rhs) = default;
        //! Copy construct from raw
        SceneMarkerQRCodesMSFT(const XrSceneMarkerQRCodesMSFT& rhs) : SceneMarkerQRCodesMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SceneMarkerQRCodesMSFT& operator=(const XrSceneMarkerQRCodesMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSceneMarkerQRCodesMSFT &() const { return *reinterpret_cast<const XrSceneMarkerQRCodesMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSceneMarkerQRCodesMSFT &() {
            return *reinterpret_cast<XrSceneMarkerQRCodesMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrSceneMarkerQRCodesMSFT
        XrSceneMarkerQRCodesMSFT const* get() const noexcept { return reinterpret_cast<XrSceneMarkerQRCodesMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerQRCodesMSFT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSceneMarkerQRCodesMSFT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SceneMarkerQRCodesMSFT{};next = oldNext;}
            return reinterpret_cast<XrSceneMarkerQRCodesMSFT*>(this);
        }
        uint32_t qrCodeCapacityInput;
        SceneMarkerQRCodeMSFT* qrCodes;
    };
     static_assert(sizeof(XrSceneMarkerQRCodesMSFT) == sizeof(SceneMarkerQRCodesMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSceneMarkerQRCodesMSFT pointer to const from a SceneMarkerQRCodesMSFT reference to const.
 * @relates SceneMarkerQRCodesMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerQRCodesMSFT const* get(SceneMarkerQRCodesMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerQRCodesMSFT as the address of a raw XrSceneMarkerQRCodesMSFT
 * @relates SceneMarkerQRCodesMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneMarkerQRCodesMSFT * put(SceneMarkerQRCodesMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_scene_marker































    #ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrUuidMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUuidMSFT>
 * @xrentity{XrUuidMSFT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS UuidMSFT 
    {
    public:
        //! Constructor initializing all members.
                UuidMSFT (
 uint8_t bytes_[16]                  )
        {
            memcpy(bytes, bytes_, sizeof(bytes));

        }


        //! Default/empty constructor
                 UuidMSFT (
            )

: bytes{0}
            {}

        //! Default copy constructor
        UuidMSFT(const UuidMSFT& rhs) = default;
        //! Default copy assignment
        UuidMSFT& operator=(const UuidMSFT& rhs) = default;
        //! Copy construct from raw
        UuidMSFT(const XrUuidMSFT& rhs) : UuidMSFT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        UuidMSFT& operator=(const XrUuidMSFT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrUuidMSFT &() const { return *reinterpret_cast<const XrUuidMSFT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrUuidMSFT &() {
            return *reinterpret_cast<XrUuidMSFT*>(this);
        }

        //! Accessor for this as the address of a raw XrUuidMSFT
        XrUuidMSFT const* get() const noexcept { return reinterpret_cast<XrUuidMSFT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrUuidMSFT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrUuidMSFT * put(bool clear = true) noexcept {
            if (clear) {*this = UuidMSFT{};}
            return reinterpret_cast<XrUuidMSFT*>(this);
        }
        uint8_t bytes[16];
    };
     static_assert(sizeof(XrUuidMSFT) == sizeof(UuidMSFT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrUuidMSFT pointer to const from a UuidMSFT reference to const.
 * @relates UuidMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrUuidMSFT const* get(UuidMSFT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing UuidMSFT as the address of a raw XrUuidMSFT
 * @relates UuidMSFT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrUuidMSFT * put(UuidMSFT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MSFT_scene_marker































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryInfoBaseHeaderFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryInfoBaseHeaderFB>
 * @xrentity{XrSpaceQueryInfoBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS SpaceQueryInfoBaseHeaderFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                SpaceQueryInfoBaseHeaderFB (
  StructureType type_ ,  const void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceQueryInfoBaseHeaderFB &() const { return *reinterpret_cast<const XrSpaceQueryInfoBaseHeaderFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceQueryInfoBaseHeaderFB &() {
            return *reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceQueryInfoBaseHeaderFB
        XrSpaceQueryInfoBaseHeaderFB const* get() const noexcept { return reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB const *>(this); }

    };
     static_assert(sizeof(XrSpaceQueryInfoBaseHeaderFB) == sizeof(SpaceQueryInfoBaseHeaderFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceQueryInfoBaseHeaderFB pointer to const from a SpaceQueryInfoBaseHeaderFB reference to const.
 * @relates SpaceQueryInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryInfoBaseHeaderFB const* get(SpaceQueryInfoBaseHeaderFB const& s) {
        return s.get();
    }

#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceFilterInfoBaseHeaderFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceFilterInfoBaseHeaderFB>
 * @xrentity{XrSpaceFilterInfoBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
    struct XR_MAY_ALIAS SpaceFilterInfoBaseHeaderFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    protected:
        //! Protected constructor: this type is abstract.
                SpaceFilterInfoBaseHeaderFB (
  StructureType type_ ,  const void * next_ = nullptr                  )
: Parent(type_ 
, next_)
        {
        }


    public:
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceFilterInfoBaseHeaderFB &() const { return *reinterpret_cast<const XrSpaceFilterInfoBaseHeaderFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceFilterInfoBaseHeaderFB &() {
            return *reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceFilterInfoBaseHeaderFB
        XrSpaceFilterInfoBaseHeaderFB const* get() const noexcept { return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB const *>(this); }

    };
     static_assert(sizeof(XrSpaceFilterInfoBaseHeaderFB) == sizeof(SpaceFilterInfoBaseHeaderFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceFilterInfoBaseHeaderFB pointer to const from a SpaceFilterInfoBaseHeaderFB reference to const.
 * @relates SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB const* get(SpaceFilterInfoBaseHeaderFB const& s) {
        return s.get();
    }

#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryInfoFB>
 * @xrentity{XrSpaceQueryInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceQueryInfoFB : public SpaceQueryInfoBaseHeaderFB
    {
    private:
        using Parent = SpaceQueryInfoBaseHeaderFB;
    public:
        //! Constructor initializing all members.
                SpaceQueryInfoFB (
 const SpaceQueryActionFB& queryAction_,  uint32_t maxResultCount_,  const Duration& timeout_,  const SpaceFilterInfoBaseHeaderFB* filter_,  const SpaceFilterInfoBaseHeaderFB* excludeFilter_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceQueryInfoFB
, next_)
, queryAction {queryAction_}
, maxResultCount {maxResultCount_}
, timeout {timeout_}
, filter {filter_}
, excludeFilter {excludeFilter_}
        {
        }


        //! Default/empty constructor
                 SpaceQueryInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceQueryInfoFB
             , next_)
, queryAction{}
, maxResultCount{0}
, timeout{}
, filter{nullptr}
, excludeFilter{nullptr}
            {}

        //! Default copy constructor
        SpaceQueryInfoFB(const SpaceQueryInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceQueryInfoFB& operator=(const SpaceQueryInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceQueryInfoFB(const XrSpaceQueryInfoFB& rhs) : SpaceQueryInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceQueryInfoFB& operator=(const XrSpaceQueryInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceQueryInfoFB &() const { return *reinterpret_cast<const XrSpaceQueryInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceQueryInfoFB &() {
            return *reinterpret_cast<XrSpaceQueryInfoFB*>(this);
        }

        //! Accessor for this as a raw, base XrSpaceQueryInfoBaseHeaderFB const pointer
        XrSpaceQueryInfoBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSpaceQueryInfoFB
        XrSpaceQueryInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceQueryInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceQueryInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceQueryInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceQueryInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceQueryInfoFB*>(this);
        }
        SpaceQueryActionFB queryAction;
        uint32_t maxResultCount;
        Duration timeout;
        const SpaceFilterInfoBaseHeaderFB* filter;
        const SpaceFilterInfoBaseHeaderFB* excludeFilter;
    };
     static_assert(sizeof(XrSpaceQueryInfoFB) == sizeof(SpaceQueryInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceQueryInfoFB pointer to const from a SpaceQueryInfoFB reference to const.
 * @relates SpaceQueryInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryInfoFB const* get(SpaceQueryInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryInfoFB as the address of a raw XrSpaceQueryInfoFB
 * @relates SpaceQueryInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryInfoFB * put(SpaceQueryInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SpaceQueryInfoFB as a raw, pointer to const XrSpaceQueryInfoBaseHeaderFB (the base type)
 * @relates SpaceQueryInfoFB
 * @relatesalso SpaceQueryInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryInfoBaseHeaderFB const* get_base(SpaceQueryInfoFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceStorageLocationFilterInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceStorageLocationFilterInfoFB>
 * @xrentity{XrSpaceStorageLocationFilterInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceStorageLocationFilterInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceStorageLocationFilterInfoFB (
 const SpaceStorageLocationFB& location_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceStorageLocationFilterInfoFB
, next_)
, location {location_}
        {
        }


        //! Default/empty constructor
                 SpaceStorageLocationFilterInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceStorageLocationFilterInfoFB
             , next_)
, location{}
            {}

        //! Default copy constructor
        SpaceStorageLocationFilterInfoFB(const SpaceStorageLocationFilterInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceStorageLocationFilterInfoFB& operator=(const SpaceStorageLocationFilterInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceStorageLocationFilterInfoFB(const XrSpaceStorageLocationFilterInfoFB& rhs) : SpaceStorageLocationFilterInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceStorageLocationFilterInfoFB& operator=(const XrSpaceStorageLocationFilterInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceStorageLocationFilterInfoFB &() const { return *reinterpret_cast<const XrSpaceStorageLocationFilterInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceStorageLocationFilterInfoFB &() {
            return *reinterpret_cast<XrSpaceStorageLocationFilterInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceStorageLocationFilterInfoFB
        XrSpaceStorageLocationFilterInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceStorageLocationFilterInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceStorageLocationFilterInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceStorageLocationFilterInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceStorageLocationFilterInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceStorageLocationFilterInfoFB*>(this);
        }
        SpaceStorageLocationFB location;
    };
     static_assert(sizeof(XrSpaceStorageLocationFilterInfoFB) == sizeof(SpaceStorageLocationFilterInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceStorageLocationFilterInfoFB pointer to const from a SpaceStorageLocationFilterInfoFB reference to const.
 * @relates SpaceStorageLocationFilterInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceStorageLocationFilterInfoFB const* get(SpaceStorageLocationFilterInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceStorageLocationFilterInfoFB as the address of a raw XrSpaceStorageLocationFilterInfoFB
 * @relates SpaceStorageLocationFilterInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceStorageLocationFilterInfoFB * put(SpaceStorageLocationFilterInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceUuidFilterInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceUuidFilterInfoFB>
 * @xrentity{XrSpaceUuidFilterInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceUuidFilterInfoFB : public SpaceFilterInfoBaseHeaderFB
    {
    private:
        using Parent = SpaceFilterInfoBaseHeaderFB;
    public:
        //! Constructor initializing all members.
                SpaceUuidFilterInfoFB (
 uint32_t uuidCount_,  UuidEXT* uuids_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceUuidFilterInfoFB
, next_)
, uuidCount {uuidCount_}
, uuids {uuids_}
        {
        }


        //! Default/empty constructor
                 SpaceUuidFilterInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceUuidFilterInfoFB
             , next_)
, uuidCount{0}
, uuids{nullptr}
            {}

        //! Default copy constructor
        SpaceUuidFilterInfoFB(const SpaceUuidFilterInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceUuidFilterInfoFB& operator=(const SpaceUuidFilterInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceUuidFilterInfoFB(const XrSpaceUuidFilterInfoFB& rhs) : SpaceUuidFilterInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceUuidFilterInfoFB& operator=(const XrSpaceUuidFilterInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceUuidFilterInfoFB &() const { return *reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceUuidFilterInfoFB &() {
            return *reinterpret_cast<XrSpaceUuidFilterInfoFB*>(this);
        }

        //! Accessor for this as a raw, base XrSpaceFilterInfoBaseHeaderFB const pointer
        XrSpaceFilterInfoBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSpaceUuidFilterInfoFB
        XrSpaceUuidFilterInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceUuidFilterInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceUuidFilterInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceUuidFilterInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceUuidFilterInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceUuidFilterInfoFB*>(this);
        }
        uint32_t uuidCount;
        UuidEXT* uuids;
    };
     static_assert(sizeof(XrSpaceUuidFilterInfoFB) == sizeof(SpaceUuidFilterInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceUuidFilterInfoFB pointer to const from a SpaceUuidFilterInfoFB reference to const.
 * @relates SpaceUuidFilterInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceUuidFilterInfoFB const* get(SpaceUuidFilterInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceUuidFilterInfoFB as the address of a raw XrSpaceUuidFilterInfoFB
 * @relates SpaceUuidFilterInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceUuidFilterInfoFB * put(SpaceUuidFilterInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SpaceUuidFilterInfoFB as a raw, pointer to const XrSpaceFilterInfoBaseHeaderFB (the base type)
 * @relates SpaceUuidFilterInfoFB
 * @relatesalso SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB const* get_base(SpaceUuidFilterInfoFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceComponentFilterInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentFilterInfoFB>
 * @xrentity{XrSpaceComponentFilterInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceComponentFilterInfoFB : public SpaceFilterInfoBaseHeaderFB
    {
    private:
        using Parent = SpaceFilterInfoBaseHeaderFB;
    public:
        //! Constructor initializing all members.
                SpaceComponentFilterInfoFB (
 const SpaceComponentTypeFB& componentType_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceComponentFilterInfoFB
, next_)
, componentType {componentType_}
        {
        }


        //! Default/empty constructor
                 SpaceComponentFilterInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceComponentFilterInfoFB
             , next_)
, componentType{}
            {}

        //! Default copy constructor
        SpaceComponentFilterInfoFB(const SpaceComponentFilterInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceComponentFilterInfoFB& operator=(const SpaceComponentFilterInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceComponentFilterInfoFB(const XrSpaceComponentFilterInfoFB& rhs) : SpaceComponentFilterInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceComponentFilterInfoFB& operator=(const XrSpaceComponentFilterInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceComponentFilterInfoFB &() const { return *reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceComponentFilterInfoFB &() {
            return *reinterpret_cast<XrSpaceComponentFilterInfoFB*>(this);
        }

        //! Accessor for this as a raw, base XrSpaceFilterInfoBaseHeaderFB const pointer
        XrSpaceFilterInfoBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSpaceComponentFilterInfoFB
        XrSpaceComponentFilterInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceComponentFilterInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceComponentFilterInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceComponentFilterInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceComponentFilterInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceComponentFilterInfoFB*>(this);
        }
        SpaceComponentTypeFB componentType;
    };
     static_assert(sizeof(XrSpaceComponentFilterInfoFB) == sizeof(SpaceComponentFilterInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceComponentFilterInfoFB pointer to const from a SpaceComponentFilterInfoFB reference to const.
 * @relates SpaceComponentFilterInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceComponentFilterInfoFB const* get(SpaceComponentFilterInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceComponentFilterInfoFB as the address of a raw XrSpaceComponentFilterInfoFB
 * @relates SpaceComponentFilterInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceComponentFilterInfoFB * put(SpaceComponentFilterInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SpaceComponentFilterInfoFB as a raw, pointer to const XrSpaceFilterInfoBaseHeaderFB (the base type)
 * @relates SpaceComponentFilterInfoFB
 * @relatesalso SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB const* get_base(SpaceComponentFilterInfoFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryResultFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryResultFB>
 * @xrentity{XrSpaceQueryResultFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS SpaceQueryResultFB 
    {
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SpaceQueryResultFB (
            )

            {}

        //! Default copy constructor
        SpaceQueryResultFB(const SpaceQueryResultFB& rhs) = default;
        //! Default copy assignment
        SpaceQueryResultFB& operator=(const SpaceQueryResultFB& rhs) = default;
        //! Copy construct from raw
        SpaceQueryResultFB(const XrSpaceQueryResultFB& rhs) : SpaceQueryResultFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceQueryResultFB& operator=(const XrSpaceQueryResultFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceQueryResultFB &() const { return *reinterpret_cast<const XrSpaceQueryResultFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceQueryResultFB &() {
            return *reinterpret_cast<XrSpaceQueryResultFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceQueryResultFB
        XrSpaceQueryResultFB const* get() const noexcept { return reinterpret_cast<XrSpaceQueryResultFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceQueryResultFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrSpaceQueryResultFB * put(bool clear = true) noexcept {
            if (clear) {*this = SpaceQueryResultFB{};}
            return reinterpret_cast<XrSpaceQueryResultFB*>(this);
        }
        Space space;
        UuidEXT uuid;
    };
     static_assert(sizeof(XrSpaceQueryResultFB) == sizeof(SpaceQueryResultFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceQueryResultFB pointer to const from a SpaceQueryResultFB reference to const.
 * @relates SpaceQueryResultFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryResultFB const* get(SpaceQueryResultFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryResultFB as the address of a raw XrSpaceQueryResultFB
 * @relates SpaceQueryResultFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryResultFB * put(SpaceQueryResultFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryResultsFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryResultsFB>
 * @xrentity{XrSpaceQueryResultsFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceQueryResultsFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SpaceQueryResultsFB (
            void * next_ = nullptr)

: Parent(StructureType::SpaceQueryResultsFB
             , next_)
            {}

        //! Default copy constructor
        SpaceQueryResultsFB(const SpaceQueryResultsFB& rhs) = default;
        //! Default copy assignment
        SpaceQueryResultsFB& operator=(const SpaceQueryResultsFB& rhs) = default;
        //! Copy construct from raw
        SpaceQueryResultsFB(const XrSpaceQueryResultsFB& rhs) : SpaceQueryResultsFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceQueryResultsFB& operator=(const XrSpaceQueryResultsFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceQueryResultsFB &() const { return *reinterpret_cast<const XrSpaceQueryResultsFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceQueryResultsFB &() {
            return *reinterpret_cast<XrSpaceQueryResultsFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceQueryResultsFB
        XrSpaceQueryResultsFB const* get() const noexcept { return reinterpret_cast<XrSpaceQueryResultsFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceQueryResultsFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceQueryResultsFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceQueryResultsFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceQueryResultsFB*>(this);
        }
        uint32_t resultCapacityInput;
        uint32_t resultCountOutput;
        SpaceQueryResultFB* results;
    };
     static_assert(sizeof(XrSpaceQueryResultsFB) == sizeof(SpaceQueryResultsFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceQueryResultsFB pointer to const from a SpaceQueryResultsFB reference to const.
 * @relates SpaceQueryResultsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryResultsFB const* get(SpaceQueryResultsFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryResultsFB as the address of a raw XrSpaceQueryResultsFB
 * @relates SpaceQueryResultsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceQueryResultsFB * put(SpaceQueryResultsFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrEventDataSpaceQueryResultsAvailableFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceQueryResultsAvailableFB>
 * @xrentity{XrEventDataSpaceQueryResultsAvailableFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceQueryResultsAvailableFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceQueryResultsAvailableFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceQueryResultsAvailableFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceQueryResultsAvailableFB(const EventDataSpaceQueryResultsAvailableFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceQueryResultsAvailableFB& operator=(const EventDataSpaceQueryResultsAvailableFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceQueryResultsAvailableFB(const XrEventDataSpaceQueryResultsAvailableFB& rhs) : EventDataSpaceQueryResultsAvailableFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceQueryResultsAvailableFB& operator=(const XrEventDataSpaceQueryResultsAvailableFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceQueryResultsAvailableFB &() const { return *reinterpret_cast<const XrEventDataSpaceQueryResultsAvailableFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceQueryResultsAvailableFB &() {
            return *reinterpret_cast<XrEventDataSpaceQueryResultsAvailableFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceQueryResultsAvailableFB
        XrEventDataSpaceQueryResultsAvailableFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceQueryResultsAvailableFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceQueryResultsAvailableFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceQueryResultsAvailableFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceQueryResultsAvailableFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceQueryResultsAvailableFB*>(this);
        }
        AsyncRequestIdFB requestId;
    };
     static_assert(sizeof(XrEventDataSpaceQueryResultsAvailableFB) == sizeof(EventDataSpaceQueryResultsAvailableFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceQueryResultsAvailableFB pointer to const from a EventDataSpaceQueryResultsAvailableFB reference to const.
 * @relates EventDataSpaceQueryResultsAvailableFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceQueryResultsAvailableFB const* get(EventDataSpaceQueryResultsAvailableFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceQueryResultsAvailableFB as the address of a raw XrEventDataSpaceQueryResultsAvailableFB
 * @relates EventDataSpaceQueryResultsAvailableFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceQueryResultsAvailableFB * put(EventDataSpaceQueryResultsAvailableFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceQueryResultsAvailableFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceQueryResultsAvailableFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceQueryResultsAvailableFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrEventDataSpaceQueryCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceQueryCompleteFB>
 * @xrentity{XrEventDataSpaceQueryCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceQueryCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceQueryCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceQueryCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceQueryCompleteFB(const EventDataSpaceQueryCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceQueryCompleteFB& operator=(const EventDataSpaceQueryCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceQueryCompleteFB(const XrEventDataSpaceQueryCompleteFB& rhs) : EventDataSpaceQueryCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceQueryCompleteFB& operator=(const XrEventDataSpaceQueryCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceQueryCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpaceQueryCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceQueryCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpaceQueryCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceQueryCompleteFB
        XrEventDataSpaceQueryCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceQueryCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceQueryCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceQueryCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceQueryCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceQueryCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
    };
     static_assert(sizeof(XrEventDataSpaceQueryCompleteFB) == sizeof(EventDataSpaceQueryCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceQueryCompleteFB pointer to const from a EventDataSpaceQueryCompleteFB reference to const.
 * @relates EventDataSpaceQueryCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceQueryCompleteFB const* get(EventDataSpaceQueryCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceQueryCompleteFB as the address of a raw XrEventDataSpaceQueryCompleteFB
 * @relates EventDataSpaceQueryCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceQueryCompleteFB * put(EventDataSpaceQueryCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceQueryCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceQueryCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceQueryCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_query































    #ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrSpaceSaveInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceSaveInfoFB>
 * @xrentity{XrSpaceSaveInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceSaveInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceSaveInfoFB (
 const Space& space_,  const SpaceStorageLocationFB& location_,  const SpacePersistenceModeFB& persistenceMode_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceSaveInfoFB
, next_)
, space {space_}
, location {location_}
, persistenceMode {persistenceMode_}
        {
        }


        //! Default/empty constructor
                 SpaceSaveInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceSaveInfoFB
             , next_)
, space{}
, location{}
, persistenceMode{}
            {}

        //! Default copy constructor
        SpaceSaveInfoFB(const SpaceSaveInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceSaveInfoFB& operator=(const SpaceSaveInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceSaveInfoFB(const XrSpaceSaveInfoFB& rhs) : SpaceSaveInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceSaveInfoFB& operator=(const XrSpaceSaveInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceSaveInfoFB &() const { return *reinterpret_cast<const XrSpaceSaveInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceSaveInfoFB &() {
            return *reinterpret_cast<XrSpaceSaveInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceSaveInfoFB
        XrSpaceSaveInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceSaveInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceSaveInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceSaveInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceSaveInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceSaveInfoFB*>(this);
        }
        Space space;
        SpaceStorageLocationFB location;
        SpacePersistenceModeFB persistenceMode;
    };
     static_assert(sizeof(XrSpaceSaveInfoFB) == sizeof(SpaceSaveInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceSaveInfoFB pointer to const from a SpaceSaveInfoFB reference to const.
 * @relates SpaceSaveInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceSaveInfoFB const* get(SpaceSaveInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceSaveInfoFB as the address of a raw XrSpaceSaveInfoFB
 * @relates SpaceSaveInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceSaveInfoFB * put(SpaceSaveInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_storage































    #ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrSpaceEraseInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceEraseInfoFB>
 * @xrentity{XrSpaceEraseInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceEraseInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceEraseInfoFB (
 const Space& space_,  const SpaceStorageLocationFB& location_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceEraseInfoFB
, next_)
, space {space_}
, location {location_}
        {
        }


        //! Default/empty constructor
                 SpaceEraseInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceEraseInfoFB
             , next_)
, space{}
, location{}
            {}

        //! Default copy constructor
        SpaceEraseInfoFB(const SpaceEraseInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceEraseInfoFB& operator=(const SpaceEraseInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceEraseInfoFB(const XrSpaceEraseInfoFB& rhs) : SpaceEraseInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceEraseInfoFB& operator=(const XrSpaceEraseInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceEraseInfoFB &() const { return *reinterpret_cast<const XrSpaceEraseInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceEraseInfoFB &() {
            return *reinterpret_cast<XrSpaceEraseInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceEraseInfoFB
        XrSpaceEraseInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceEraseInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceEraseInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceEraseInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceEraseInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceEraseInfoFB*>(this);
        }
        Space space;
        SpaceStorageLocationFB location;
    };
     static_assert(sizeof(XrSpaceEraseInfoFB) == sizeof(SpaceEraseInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceEraseInfoFB pointer to const from a SpaceEraseInfoFB reference to const.
 * @relates SpaceEraseInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceEraseInfoFB const* get(SpaceEraseInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceEraseInfoFB as the address of a raw XrSpaceEraseInfoFB
 * @relates SpaceEraseInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceEraseInfoFB * put(SpaceEraseInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_storage































    #ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrEventDataSpaceSaveCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceSaveCompleteFB>
 * @xrentity{XrEventDataSpaceSaveCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceSaveCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceSaveCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceSaveCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceSaveCompleteFB(const EventDataSpaceSaveCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceSaveCompleteFB& operator=(const EventDataSpaceSaveCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceSaveCompleteFB(const XrEventDataSpaceSaveCompleteFB& rhs) : EventDataSpaceSaveCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceSaveCompleteFB& operator=(const XrEventDataSpaceSaveCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceSaveCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpaceSaveCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceSaveCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpaceSaveCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceSaveCompleteFB
        XrEventDataSpaceSaveCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceSaveCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceSaveCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceSaveCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceSaveCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceSaveCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
        Space space;
        UuidEXT uuid;
        SpaceStorageLocationFB location;
    };
     static_assert(sizeof(XrEventDataSpaceSaveCompleteFB) == sizeof(EventDataSpaceSaveCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceSaveCompleteFB pointer to const from a EventDataSpaceSaveCompleteFB reference to const.
 * @relates EventDataSpaceSaveCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceSaveCompleteFB const* get(EventDataSpaceSaveCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceSaveCompleteFB as the address of a raw XrEventDataSpaceSaveCompleteFB
 * @relates EventDataSpaceSaveCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceSaveCompleteFB * put(EventDataSpaceSaveCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceSaveCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceSaveCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceSaveCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_storage































    #ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrEventDataSpaceEraseCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceEraseCompleteFB>
 * @xrentity{XrEventDataSpaceEraseCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceEraseCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceEraseCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceEraseCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceEraseCompleteFB(const EventDataSpaceEraseCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceEraseCompleteFB& operator=(const EventDataSpaceEraseCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceEraseCompleteFB(const XrEventDataSpaceEraseCompleteFB& rhs) : EventDataSpaceEraseCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceEraseCompleteFB& operator=(const XrEventDataSpaceEraseCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceEraseCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpaceEraseCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceEraseCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpaceEraseCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceEraseCompleteFB
        XrEventDataSpaceEraseCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceEraseCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceEraseCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceEraseCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceEraseCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceEraseCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
        Space space;
        UuidEXT uuid;
        SpaceStorageLocationFB location;
    };
     static_assert(sizeof(XrEventDataSpaceEraseCompleteFB) == sizeof(EventDataSpaceEraseCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceEraseCompleteFB pointer to const from a EventDataSpaceEraseCompleteFB reference to const.
 * @relates EventDataSpaceEraseCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceEraseCompleteFB const* get(EventDataSpaceEraseCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceEraseCompleteFB as the address of a raw XrEventDataSpaceEraseCompleteFB
 * @relates EventDataSpaceEraseCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceEraseCompleteFB * put(EventDataSpaceEraseCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceEraseCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceEraseCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceEraseCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_storage































    #ifdef XR_FB_foveation_vulkan
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageFoveationVulkanFB
 * 
 * Provided by the `XR_FB_foveation_vulkan` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageFoveationVulkanFB>
 * @xrentity{XrSwapchainImageFoveationVulkanFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainImageFoveationVulkanFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainImageFoveationVulkanFB (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainImageFoveationVulkanFB
             , next_)
            {}

        //! Default copy constructor
        SwapchainImageFoveationVulkanFB(const SwapchainImageFoveationVulkanFB& rhs) = default;
        //! Default copy assignment
        SwapchainImageFoveationVulkanFB& operator=(const SwapchainImageFoveationVulkanFB& rhs) = default;
        //! Copy construct from raw
        SwapchainImageFoveationVulkanFB(const XrSwapchainImageFoveationVulkanFB& rhs) : SwapchainImageFoveationVulkanFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainImageFoveationVulkanFB& operator=(const XrSwapchainImageFoveationVulkanFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainImageFoveationVulkanFB &() const { return *reinterpret_cast<const XrSwapchainImageFoveationVulkanFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainImageFoveationVulkanFB &() {
            return *reinterpret_cast<XrSwapchainImageFoveationVulkanFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSwapchainImageFoveationVulkanFB
        XrSwapchainImageFoveationVulkanFB const* get() const noexcept { return reinterpret_cast<XrSwapchainImageFoveationVulkanFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageFoveationVulkanFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainImageFoveationVulkanFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainImageFoveationVulkanFB{};next = oldNext;}
            return reinterpret_cast<XrSwapchainImageFoveationVulkanFB*>(this);
        }
        VkImage image;
        uint32_t width;
        uint32_t height;
    };
     static_assert(sizeof(XrSwapchainImageFoveationVulkanFB) == sizeof(SwapchainImageFoveationVulkanFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainImageFoveationVulkanFB pointer to const from a SwapchainImageFoveationVulkanFB reference to const.
 * @relates SwapchainImageFoveationVulkanFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageFoveationVulkanFB const* get(SwapchainImageFoveationVulkanFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageFoveationVulkanFB as the address of a raw XrSwapchainImageFoveationVulkanFB
 * @relates SwapchainImageFoveationVulkanFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainImageFoveationVulkanFB * put(SwapchainImageFoveationVulkanFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_FB_foveation_vulkan































    #ifdef XR_FB_swapchain_update_state_android_surface
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrSwapchainStateAndroidSurfaceDimensionsFB
 * 
 * Provided by the `XR_FB_swapchain_update_state_android_surface` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateAndroidSurfaceDimensionsFB>
 * @xrentity{XrSwapchainStateAndroidSurfaceDimensionsFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainStateAndroidSurfaceDimensionsFB : public SwapchainStateBaseHeaderFB
    {
    private:
        using Parent = SwapchainStateBaseHeaderFB;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainStateAndroidSurfaceDimensionsFB (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainStateAndroidSurfaceDimensionsFB
             , next_)
            {}

        //! Default copy constructor
        SwapchainStateAndroidSurfaceDimensionsFB(const SwapchainStateAndroidSurfaceDimensionsFB& rhs) = default;
        //! Default copy assignment
        SwapchainStateAndroidSurfaceDimensionsFB& operator=(const SwapchainStateAndroidSurfaceDimensionsFB& rhs) = default;
        //! Copy construct from raw
        SwapchainStateAndroidSurfaceDimensionsFB(const XrSwapchainStateAndroidSurfaceDimensionsFB& rhs) : SwapchainStateAndroidSurfaceDimensionsFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainStateAndroidSurfaceDimensionsFB& operator=(const XrSwapchainStateAndroidSurfaceDimensionsFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainStateAndroidSurfaceDimensionsFB &() const { return *reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainStateAndroidSurfaceDimensionsFB &() {
            return *reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
        XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainStateAndroidSurfaceDimensionsFB
        XrSwapchainStateAndroidSurfaceDimensionsFB const* get() const noexcept { return reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainStateAndroidSurfaceDimensionsFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainStateAndroidSurfaceDimensionsFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainStateAndroidSurfaceDimensionsFB{};next = oldNext;}
            return reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
        }
        uint32_t width;
        uint32_t height;
    };
     static_assert(sizeof(XrSwapchainStateAndroidSurfaceDimensionsFB) == sizeof(SwapchainStateAndroidSurfaceDimensionsFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainStateAndroidSurfaceDimensionsFB pointer to const from a SwapchainStateAndroidSurfaceDimensionsFB reference to const.
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateAndroidSurfaceDimensionsFB const* get(SwapchainStateAndroidSurfaceDimensionsFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateAndroidSurfaceDimensionsFB as the address of a raw XrSwapchainStateAndroidSurfaceDimensionsFB
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateAndroidSurfaceDimensionsFB * put(SwapchainStateAndroidSurfaceDimensionsFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainStateAndroidSurfaceDimensionsFB as a raw, pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(SwapchainStateAndroidSurfaceDimensionsFB const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_FB_swapchain_update_state_android_surface































    #ifdef XR_FB_swapchain_update_state_opengl_es
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainStateSamplerOpenGLESFB
 * 
 * Provided by the `XR_FB_swapchain_update_state_opengl_es` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateSamplerOpenGLESFB>
 * @xrentity{XrSwapchainStateSamplerOpenGLESFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainStateSamplerOpenGLESFB : public SwapchainStateBaseHeaderFB
    {
    private:
        using Parent = SwapchainStateBaseHeaderFB;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainStateSamplerOpenGLESFB (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainStateSamplerOpenGLESFB
             , next_)
            {}

        //! Default copy constructor
        SwapchainStateSamplerOpenGLESFB(const SwapchainStateSamplerOpenGLESFB& rhs) = default;
        //! Default copy assignment
        SwapchainStateSamplerOpenGLESFB& operator=(const SwapchainStateSamplerOpenGLESFB& rhs) = default;
        //! Copy construct from raw
        SwapchainStateSamplerOpenGLESFB(const XrSwapchainStateSamplerOpenGLESFB& rhs) : SwapchainStateSamplerOpenGLESFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainStateSamplerOpenGLESFB& operator=(const XrSwapchainStateSamplerOpenGLESFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainStateSamplerOpenGLESFB &() const { return *reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainStateSamplerOpenGLESFB &() {
            return *reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
        XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainStateSamplerOpenGLESFB
        XrSwapchainStateSamplerOpenGLESFB const* get() const noexcept { return reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainStateSamplerOpenGLESFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainStateSamplerOpenGLESFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainStateSamplerOpenGLESFB{};next = oldNext;}
            return reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(this);
        }
        EGLenum minFilter;
        EGLenum magFilter;
        EGLenum wrapModeS;
        EGLenum wrapModeT;
        EGLenum swizzleRed;
        EGLenum swizzleGreen;
        EGLenum swizzleBlue;
        EGLenum swizzleAlpha;
        float maxAnisotropy;
        Color4f borderColor;
    };
     static_assert(sizeof(XrSwapchainStateSamplerOpenGLESFB) == sizeof(SwapchainStateSamplerOpenGLESFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainStateSamplerOpenGLESFB pointer to const from a SwapchainStateSamplerOpenGLESFB reference to const.
 * @relates SwapchainStateSamplerOpenGLESFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateSamplerOpenGLESFB const* get(SwapchainStateSamplerOpenGLESFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateSamplerOpenGLESFB as the address of a raw XrSwapchainStateSamplerOpenGLESFB
 * @relates SwapchainStateSamplerOpenGLESFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateSamplerOpenGLESFB * put(SwapchainStateSamplerOpenGLESFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainStateSamplerOpenGLESFB as a raw, pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateSamplerOpenGLESFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(SwapchainStateSamplerOpenGLESFB const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_FB_swapchain_update_state_opengl_es































    #ifdef XR_FB_swapchain_update_state_vulkan
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainStateSamplerVulkanFB
 * 
 * Provided by the `XR_FB_swapchain_update_state_vulkan` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateSamplerVulkanFB>
 * @xrentity{XrSwapchainStateSamplerVulkanFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SwapchainStateSamplerVulkanFB : public SwapchainStateBaseHeaderFB
    {
    private:
        using Parent = SwapchainStateBaseHeaderFB;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SwapchainStateSamplerVulkanFB (
            void * next_ = nullptr)

: Parent(StructureType::SwapchainStateSamplerVulkanFB
             , next_)
            {}

        //! Default copy constructor
        SwapchainStateSamplerVulkanFB(const SwapchainStateSamplerVulkanFB& rhs) = default;
        //! Default copy assignment
        SwapchainStateSamplerVulkanFB& operator=(const SwapchainStateSamplerVulkanFB& rhs) = default;
        //! Copy construct from raw
        SwapchainStateSamplerVulkanFB(const XrSwapchainStateSamplerVulkanFB& rhs) : SwapchainStateSamplerVulkanFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SwapchainStateSamplerVulkanFB& operator=(const XrSwapchainStateSamplerVulkanFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSwapchainStateSamplerVulkanFB &() const { return *reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSwapchainStateSamplerVulkanFB &() {
            return *reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(this);
        }

        //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
        XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
            return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
        }
        //! Accessor for this as the address of a raw XrSwapchainStateSamplerVulkanFB
        XrSwapchainStateSamplerVulkanFB const* get() const noexcept { return reinterpret_cast<XrSwapchainStateSamplerVulkanFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainStateSamplerVulkanFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSwapchainStateSamplerVulkanFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SwapchainStateSamplerVulkanFB{};next = oldNext;}
            return reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(this);
        }
        VkFilter minFilter;
        VkFilter magFilter;
        VkSamplerMipmapMode mipmapMode;
        VkSamplerAddressMode wrapModeS;
        VkSamplerAddressMode wrapModeT;
        VkComponentSwizzle swizzleRed;
        VkComponentSwizzle swizzleGreen;
        VkComponentSwizzle swizzleBlue;
        VkComponentSwizzle swizzleAlpha;
        float maxAnisotropy;
        Color4f borderColor;
    };
     static_assert(sizeof(XrSwapchainStateSamplerVulkanFB) == sizeof(SwapchainStateSamplerVulkanFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSwapchainStateSamplerVulkanFB pointer to const from a SwapchainStateSamplerVulkanFB reference to const.
 * @relates SwapchainStateSamplerVulkanFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateSamplerVulkanFB const* get(SwapchainStateSamplerVulkanFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateSamplerVulkanFB as the address of a raw XrSwapchainStateSamplerVulkanFB
 * @relates SwapchainStateSamplerVulkanFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateSamplerVulkanFB * put(SwapchainStateSamplerVulkanFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const SwapchainStateSamplerVulkanFB as a raw, pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateSamplerVulkanFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(SwapchainStateSamplerVulkanFB const& h) {
        return h.get_base();
    }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_FB_swapchain_update_state_vulkan































    #ifdef XR_FB_spatial_entity_sharing
/*!
 * C++ projection of XrSpaceShareInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_sharing` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceShareInfoFB>
 * @xrentity{XrSpaceShareInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceShareInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceShareInfoFB (
 uint32_t spaceCount_,  Space* spaces_,  uint32_t userCount_,  SpaceUserFB* users_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceShareInfoFB
, next_)
, spaceCount {spaceCount_}
, spaces {spaces_}
, userCount {userCount_}
, users {users_}
        {
        }


        //! Default/empty constructor
                 SpaceShareInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceShareInfoFB
             , next_)
, spaceCount{0}
, spaces{nullptr}
, userCount{0}
, users{nullptr}
            {}

        //! Default copy constructor
        SpaceShareInfoFB(const SpaceShareInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceShareInfoFB& operator=(const SpaceShareInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceShareInfoFB(const XrSpaceShareInfoFB& rhs) : SpaceShareInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceShareInfoFB& operator=(const XrSpaceShareInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceShareInfoFB &() const { return *reinterpret_cast<const XrSpaceShareInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceShareInfoFB &() {
            return *reinterpret_cast<XrSpaceShareInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceShareInfoFB
        XrSpaceShareInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceShareInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceShareInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceShareInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceShareInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceShareInfoFB*>(this);
        }
        uint32_t spaceCount;
        Space* spaces;
        uint32_t userCount;
        SpaceUserFB* users;
    };
     static_assert(sizeof(XrSpaceShareInfoFB) == sizeof(SpaceShareInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceShareInfoFB pointer to const from a SpaceShareInfoFB reference to const.
 * @relates SpaceShareInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceShareInfoFB const* get(SpaceShareInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceShareInfoFB as the address of a raw XrSpaceShareInfoFB
 * @relates SpaceShareInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceShareInfoFB * put(SpaceShareInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_sharing































    #ifdef XR_FB_spatial_entity_sharing
/*!
 * C++ projection of XrEventDataSpaceShareCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity_sharing` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceShareCompleteFB>
 * @xrentity{XrEventDataSpaceShareCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceShareCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceShareCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceShareCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceShareCompleteFB(const EventDataSpaceShareCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceShareCompleteFB& operator=(const EventDataSpaceShareCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceShareCompleteFB(const XrEventDataSpaceShareCompleteFB& rhs) : EventDataSpaceShareCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceShareCompleteFB& operator=(const XrEventDataSpaceShareCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceShareCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpaceShareCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceShareCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpaceShareCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceShareCompleteFB
        XrEventDataSpaceShareCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceShareCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceShareCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceShareCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceShareCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceShareCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
    };
     static_assert(sizeof(XrEventDataSpaceShareCompleteFB) == sizeof(EventDataSpaceShareCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceShareCompleteFB pointer to const from a EventDataSpaceShareCompleteFB reference to const.
 * @relates EventDataSpaceShareCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceShareCompleteFB const* get(EventDataSpaceShareCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceShareCompleteFB as the address of a raw XrEventDataSpaceShareCompleteFB
 * @relates EventDataSpaceShareCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceShareCompleteFB * put(EventDataSpaceShareCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceShareCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceShareCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceShareCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_sharing































    #ifdef XR_FB_space_warp
/*!
 * C++ projection of XrCompositionLayerSpaceWarpInfoFB
 * 
 * Provided by the `XR_FB_space_warp` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSpaceWarpInfoFB>
 * @xrentity{XrCompositionLayerSpaceWarpInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerSpaceWarpInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerSpaceWarpInfoFB (
 const CompositionLayerSpaceWarpInfoFlagsFB& layerFlags_,  const SwapchainSubImage& motionVectorSubImage_,  const Posef& appSpaceDeltaPose_,  const SwapchainSubImage& depthSubImage_,  float minDepth_,  float maxDepth_,  float nearZ_,  float farZ_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerSpaceWarpInfoFB
, next_)
, layerFlags {layerFlags_}
, motionVectorSubImage {motionVectorSubImage_}
, appSpaceDeltaPose {appSpaceDeltaPose_}
, depthSubImage {depthSubImage_}
, minDepth {minDepth_}
, maxDepth {maxDepth_}
, nearZ {nearZ_}
, farZ {farZ_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerSpaceWarpInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerSpaceWarpInfoFB
             , next_)
, layerFlags{}
, motionVectorSubImage{}
, appSpaceDeltaPose{}
, depthSubImage{}
, minDepth{0.0f}
, maxDepth{0.0f}
, nearZ{0.0f}
, farZ{0.0f}
            {}

        //! Default copy constructor
        CompositionLayerSpaceWarpInfoFB(const CompositionLayerSpaceWarpInfoFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerSpaceWarpInfoFB& operator=(const CompositionLayerSpaceWarpInfoFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerSpaceWarpInfoFB(const XrCompositionLayerSpaceWarpInfoFB& rhs) : CompositionLayerSpaceWarpInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerSpaceWarpInfoFB& operator=(const XrCompositionLayerSpaceWarpInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerSpaceWarpInfoFB &() const { return *reinterpret_cast<const XrCompositionLayerSpaceWarpInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerSpaceWarpInfoFB &() {
            return *reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerSpaceWarpInfoFB
        XrCompositionLayerSpaceWarpInfoFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerSpaceWarpInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerSpaceWarpInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerSpaceWarpInfoFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB*>(this);
        }
        CompositionLayerSpaceWarpInfoFlagsFB layerFlags;
        SwapchainSubImage motionVectorSubImage;
        Posef appSpaceDeltaPose;
        SwapchainSubImage depthSubImage;
        float minDepth;
        float maxDepth;
        float nearZ;
        float farZ;
    };
     static_assert(sizeof(XrCompositionLayerSpaceWarpInfoFB) == sizeof(CompositionLayerSpaceWarpInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerSpaceWarpInfoFB pointer to const from a CompositionLayerSpaceWarpInfoFB reference to const.
 * @relates CompositionLayerSpaceWarpInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerSpaceWarpInfoFB const* get(CompositionLayerSpaceWarpInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerSpaceWarpInfoFB as the address of a raw XrCompositionLayerSpaceWarpInfoFB
 * @relates CompositionLayerSpaceWarpInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerSpaceWarpInfoFB * put(CompositionLayerSpaceWarpInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_space_warp































    #ifdef XR_FB_space_warp
/*!
 * C++ projection of XrSystemSpaceWarpPropertiesFB
 * 
 * Provided by the `XR_FB_space_warp` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpaceWarpPropertiesFB>
 * @xrentity{XrSystemSpaceWarpPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemSpaceWarpPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemSpaceWarpPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemSpaceWarpPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemSpaceWarpPropertiesFB(const SystemSpaceWarpPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemSpaceWarpPropertiesFB& operator=(const SystemSpaceWarpPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemSpaceWarpPropertiesFB(const XrSystemSpaceWarpPropertiesFB& rhs) : SystemSpaceWarpPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemSpaceWarpPropertiesFB& operator=(const XrSystemSpaceWarpPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemSpaceWarpPropertiesFB &() const { return *reinterpret_cast<const XrSystemSpaceWarpPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemSpaceWarpPropertiesFB &() {
            return *reinterpret_cast<XrSystemSpaceWarpPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemSpaceWarpPropertiesFB
        XrSystemSpaceWarpPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemSpaceWarpPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemSpaceWarpPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemSpaceWarpPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemSpaceWarpPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemSpaceWarpPropertiesFB*>(this);
        }
        uint32_t recommendedMotionVectorImageRectWidth;
        uint32_t recommendedMotionVectorImageRectHeight;
    };
     static_assert(sizeof(XrSystemSpaceWarpPropertiesFB) == sizeof(SystemSpaceWarpPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemSpaceWarpPropertiesFB pointer to const from a SystemSpaceWarpPropertiesFB reference to const.
 * @relates SystemSpaceWarpPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemSpaceWarpPropertiesFB const* get(SystemSpaceWarpPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemSpaceWarpPropertiesFB as the address of a raw XrSystemSpaceWarpPropertiesFB
 * @relates SystemSpaceWarpPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemSpaceWarpPropertiesFB * put(SystemSpaceWarpPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_space_warp































    #ifdef XR_FB_haptic_amplitude_envelope
/*!
 * C++ projection of XrHapticAmplitudeEnvelopeVibrationFB
 * 
 * Provided by the `XR_FB_haptic_amplitude_envelope` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticAmplitudeEnvelopeVibrationFB>
 * @xrentity{XrHapticAmplitudeEnvelopeVibrationFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HapticAmplitudeEnvelopeVibrationFB : public HapticBaseHeader
    {
    private:
        using Parent = HapticBaseHeader;
    public:
        //! Constructor initializing all members.
                HapticAmplitudeEnvelopeVibrationFB (
 const Duration& duration_,  uint32_t amplitudeCount_,  const float* amplitudes_,  const void * next_ = nullptr                  )
: Parent(StructureType::HapticAmplitudeEnvelopeVibrationFB
, next_)
, duration {duration_}
, amplitudeCount {amplitudeCount_}
, amplitudes {amplitudes_}
        {
        }


        //! Default/empty constructor
                 HapticAmplitudeEnvelopeVibrationFB (
            const void * next_ = nullptr)

: Parent(StructureType::HapticAmplitudeEnvelopeVibrationFB
             , next_)
, duration{}
, amplitudeCount{0}
, amplitudes{nullptr}
            {}

        //! Default copy constructor
        HapticAmplitudeEnvelopeVibrationFB(const HapticAmplitudeEnvelopeVibrationFB& rhs) = default;
        //! Default copy assignment
        HapticAmplitudeEnvelopeVibrationFB& operator=(const HapticAmplitudeEnvelopeVibrationFB& rhs) = default;
        //! Copy construct from raw
        HapticAmplitudeEnvelopeVibrationFB(const XrHapticAmplitudeEnvelopeVibrationFB& rhs) : HapticAmplitudeEnvelopeVibrationFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HapticAmplitudeEnvelopeVibrationFB& operator=(const XrHapticAmplitudeEnvelopeVibrationFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHapticAmplitudeEnvelopeVibrationFB &() const { return *reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHapticAmplitudeEnvelopeVibrationFB &() {
            return *reinterpret_cast<XrHapticAmplitudeEnvelopeVibrationFB*>(this);
        }

        //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
        XrHapticBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrHapticBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrHapticAmplitudeEnvelopeVibrationFB
        XrHapticAmplitudeEnvelopeVibrationFB const* get() const noexcept { return reinterpret_cast<XrHapticAmplitudeEnvelopeVibrationFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHapticAmplitudeEnvelopeVibrationFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHapticAmplitudeEnvelopeVibrationFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HapticAmplitudeEnvelopeVibrationFB{};next = oldNext;}
            return reinterpret_cast<XrHapticAmplitudeEnvelopeVibrationFB*>(this);
        }
        Duration duration;
        uint32_t amplitudeCount;
        const float* amplitudes;
    };
     static_assert(sizeof(XrHapticAmplitudeEnvelopeVibrationFB) == sizeof(HapticAmplitudeEnvelopeVibrationFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHapticAmplitudeEnvelopeVibrationFB pointer to const from a HapticAmplitudeEnvelopeVibrationFB reference to const.
 * @relates HapticAmplitudeEnvelopeVibrationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticAmplitudeEnvelopeVibrationFB const* get(HapticAmplitudeEnvelopeVibrationFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticAmplitudeEnvelopeVibrationFB as the address of a raw XrHapticAmplitudeEnvelopeVibrationFB
 * @relates HapticAmplitudeEnvelopeVibrationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticAmplitudeEnvelopeVibrationFB * put(HapticAmplitudeEnvelopeVibrationFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const HapticAmplitudeEnvelopeVibrationFB as a raw, pointer to const XrHapticBaseHeader (the base type)
 * @relates HapticAmplitudeEnvelopeVibrationFB
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticAmplitudeEnvelopeVibrationFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_haptic_amplitude_envelope































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrExtent3DfFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent3DfFB>
 * @xrentity{XrExtent3DfFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Extent3DfFB 
    {
    public:
        //! Constructor initializing all members.
                Extent3DfFB (
 float width_,  float height_,  float depth_                  )
: width {width_}
, height {height_}
, depth {depth_}
        {
        }


        //! Default/empty constructor
                 Extent3DfFB (
            )

: width{0.0f}
, height{0.0f}
, depth{0.0f}
            {}

        //! Default copy constructor
        Extent3DfFB(const Extent3DfFB& rhs) = default;
        //! Default copy assignment
        Extent3DfFB& operator=(const Extent3DfFB& rhs) = default;
        //! Copy construct from raw
        Extent3DfFB(const XrExtent3DfFB& rhs) : Extent3DfFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Extent3DfFB& operator=(const XrExtent3DfFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExtent3DfFB &() const { return *reinterpret_cast<const XrExtent3DfFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExtent3DfFB &() {
            return *reinterpret_cast<XrExtent3DfFB*>(this);
        }

        //! Accessor for this as the address of a raw XrExtent3DfFB
        XrExtent3DfFB const* get() const noexcept { return reinterpret_cast<XrExtent3DfFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExtent3DfFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrExtent3DfFB * put(bool clear = true) noexcept {
            if (clear) {*this = Extent3DfFB{};}
            return reinterpret_cast<XrExtent3DfFB*>(this);
        }
        float width;
        float height;
        float depth;
    };
     static_assert(sizeof(XrExtent3DfFB) == sizeof(Extent3DfFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExtent3DfFB pointer to const from a Extent3DfFB reference to const.
 * @relates Extent3DfFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent3DfFB const* get(Extent3DfFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent3DfFB as the address of a raw XrExtent3DfFB
 * @relates Extent3DfFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent3DfFB * put(Extent3DfFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrOffset3DfFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset3DfFB>
 * @xrentity{XrOffset3DfFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Offset3DfFB 
    {
    public:
        //! Constructor initializing all members.
                Offset3DfFB (
 float x_,  float y_,  float z_                  )
: x {x_}
, y {y_}
, z {z_}
        {
        }


        //! Default/empty constructor
                 Offset3DfFB (
            )

: x{0.0f}
, y{0.0f}
, z{0.0f}
            {}

        //! Default copy constructor
        Offset3DfFB(const Offset3DfFB& rhs) = default;
        //! Default copy assignment
        Offset3DfFB& operator=(const Offset3DfFB& rhs) = default;
        //! Copy construct from raw
        Offset3DfFB(const XrOffset3DfFB& rhs) : Offset3DfFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Offset3DfFB& operator=(const XrOffset3DfFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrOffset3DfFB &() const { return *reinterpret_cast<const XrOffset3DfFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrOffset3DfFB &() {
            return *reinterpret_cast<XrOffset3DfFB*>(this);
        }

        //! Accessor for this as the address of a raw XrOffset3DfFB
        XrOffset3DfFB const* get() const noexcept { return reinterpret_cast<XrOffset3DfFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrOffset3DfFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrOffset3DfFB * put(bool clear = true) noexcept {
            if (clear) {*this = Offset3DfFB{};}
            return reinterpret_cast<XrOffset3DfFB*>(this);
        }
        float x;
        float y;
        float z;
    };
     static_assert(sizeof(XrOffset3DfFB) == sizeof(Offset3DfFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrOffset3DfFB pointer to const from a Offset3DfFB reference to const.
 * @relates Offset3DfFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrOffset3DfFB const* get(Offset3DfFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset3DfFB as the address of a raw XrOffset3DfFB
 * @relates Offset3DfFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrOffset3DfFB * put(Offset3DfFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrRect3DfFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect3DfFB>
 * @xrentity{XrRect3DfFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Rect3DfFB 
    {
    public:
        //! Constructor initializing all members.
                Rect3DfFB (
 const Offset3DfFB& offset_,  const Extent3DfFB& extent_                  )
: offset {offset_}
, extent {extent_}
        {
        }


        //! Default/empty constructor
                 Rect3DfFB (
            )

: offset{}
, extent{}
            {}

        //! Default copy constructor
        Rect3DfFB(const Rect3DfFB& rhs) = default;
        //! Default copy assignment
        Rect3DfFB& operator=(const Rect3DfFB& rhs) = default;
        //! Copy construct from raw
        Rect3DfFB(const XrRect3DfFB& rhs) : Rect3DfFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Rect3DfFB& operator=(const XrRect3DfFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRect3DfFB &() const { return *reinterpret_cast<const XrRect3DfFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRect3DfFB &() {
            return *reinterpret_cast<XrRect3DfFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRect3DfFB
        XrRect3DfFB const* get() const noexcept { return reinterpret_cast<XrRect3DfFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRect3DfFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrRect3DfFB * put(bool clear = true) noexcept {
            if (clear) {*this = Rect3DfFB{};}
            return reinterpret_cast<XrRect3DfFB*>(this);
        }
        Offset3DfFB offset;
        Extent3DfFB extent;
    };
     static_assert(sizeof(XrRect3DfFB) == sizeof(Rect3DfFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRect3DfFB pointer to const from a Rect3DfFB reference to const.
 * @relates Rect3DfFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRect3DfFB const* get(Rect3DfFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect3DfFB as the address of a raw XrRect3DfFB
 * @relates Rect3DfFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRect3DfFB * put(Rect3DfFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrSemanticLabelsFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSemanticLabelsFB>
 * @xrentity{XrSemanticLabelsFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SemanticLabelsFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SemanticLabelsFB (
 uint32_t bufferCapacityInput_,  uint32_t bufferCountOutput_,  char* buffer_,  const void * next_ = nullptr                  )
: Parent(StructureType::SemanticLabelsFB
, next_)
, bufferCapacityInput {bufferCapacityInput_}
, bufferCountOutput {bufferCountOutput_}
, buffer {buffer_}
        {
        }


        //! Default/empty constructor
                 SemanticLabelsFB (
            const void * next_ = nullptr)

: Parent(StructureType::SemanticLabelsFB
             , next_)
, bufferCapacityInput{0}
, bufferCountOutput{0}
, buffer{nullptr}
            {}

        //! Default copy constructor
        SemanticLabelsFB(const SemanticLabelsFB& rhs) = default;
        //! Default copy assignment
        SemanticLabelsFB& operator=(const SemanticLabelsFB& rhs) = default;
        //! Copy construct from raw
        SemanticLabelsFB(const XrSemanticLabelsFB& rhs) : SemanticLabelsFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SemanticLabelsFB& operator=(const XrSemanticLabelsFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSemanticLabelsFB &() const { return *reinterpret_cast<const XrSemanticLabelsFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSemanticLabelsFB &() {
            return *reinterpret_cast<XrSemanticLabelsFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSemanticLabelsFB
        XrSemanticLabelsFB const* get() const noexcept { return reinterpret_cast<XrSemanticLabelsFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSemanticLabelsFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSemanticLabelsFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SemanticLabelsFB{};next = oldNext;}
            return reinterpret_cast<XrSemanticLabelsFB*>(this);
        }
        uint32_t bufferCapacityInput;
        uint32_t bufferCountOutput;
        char* buffer;
    };
     static_assert(sizeof(XrSemanticLabelsFB) == sizeof(SemanticLabelsFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSemanticLabelsFB pointer to const from a SemanticLabelsFB reference to const.
 * @relates SemanticLabelsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSemanticLabelsFB const* get(SemanticLabelsFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SemanticLabelsFB as the address of a raw XrSemanticLabelsFB
 * @relates SemanticLabelsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSemanticLabelsFB * put(SemanticLabelsFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrRoomLayoutFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRoomLayoutFB>
 * @xrentity{XrRoomLayoutFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS RoomLayoutFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                RoomLayoutFB (
 const UuidEXT& floorUuid_,  const UuidEXT& ceilingUuid_,  uint32_t wallUuidCapacityInput_,  uint32_t wallUuidCountOutput_,  UuidEXT* wallUuids_,  const void * next_ = nullptr                  )
: Parent(StructureType::RoomLayoutFB
, next_)
, floorUuid {floorUuid_}
, ceilingUuid {ceilingUuid_}
, wallUuidCapacityInput {wallUuidCapacityInput_}
, wallUuidCountOutput {wallUuidCountOutput_}
, wallUuids {wallUuids_}
        {
        }


        //! Default/empty constructor
                 RoomLayoutFB (
            const void * next_ = nullptr)

: Parent(StructureType::RoomLayoutFB
             , next_)
, floorUuid{}
, ceilingUuid{}
, wallUuidCapacityInput{0}
, wallUuidCountOutput{0}
, wallUuids{nullptr}
            {}

        //! Default copy constructor
        RoomLayoutFB(const RoomLayoutFB& rhs) = default;
        //! Default copy assignment
        RoomLayoutFB& operator=(const RoomLayoutFB& rhs) = default;
        //! Copy construct from raw
        RoomLayoutFB(const XrRoomLayoutFB& rhs) : RoomLayoutFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        RoomLayoutFB& operator=(const XrRoomLayoutFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrRoomLayoutFB &() const { return *reinterpret_cast<const XrRoomLayoutFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrRoomLayoutFB &() {
            return *reinterpret_cast<XrRoomLayoutFB*>(this);
        }

        //! Accessor for this as the address of a raw XrRoomLayoutFB
        XrRoomLayoutFB const* get() const noexcept { return reinterpret_cast<XrRoomLayoutFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrRoomLayoutFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrRoomLayoutFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = RoomLayoutFB{};next = oldNext;}
            return reinterpret_cast<XrRoomLayoutFB*>(this);
        }
        UuidEXT floorUuid;
        UuidEXT ceilingUuid;
        uint32_t wallUuidCapacityInput;
        uint32_t wallUuidCountOutput;
        UuidEXT* wallUuids;
    };
     static_assert(sizeof(XrRoomLayoutFB) == sizeof(RoomLayoutFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrRoomLayoutFB pointer to const from a RoomLayoutFB reference to const.
 * @relates RoomLayoutFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRoomLayoutFB const* get(RoomLayoutFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing RoomLayoutFB as the address of a raw XrRoomLayoutFB
 * @relates RoomLayoutFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrRoomLayoutFB * put(RoomLayoutFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrBoundary2DFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoundary2DFB>
 * @xrentity{XrBoundary2DFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS Boundary2DFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                Boundary2DFB (
 uint32_t vertexCapacityInput_,  uint32_t vertexCountOutput_,  Vector2f* vertices_,  const void * next_ = nullptr                  )
: Parent(StructureType::Boundary2DFB
, next_)
, vertexCapacityInput {vertexCapacityInput_}
, vertexCountOutput {vertexCountOutput_}
, vertices {vertices_}
        {
        }


        //! Default/empty constructor
                 Boundary2DFB (
            const void * next_ = nullptr)

: Parent(StructureType::Boundary2DFB
             , next_)
, vertexCapacityInput{0}
, vertexCountOutput{0}
, vertices{nullptr}
            {}

        //! Default copy constructor
        Boundary2DFB(const Boundary2DFB& rhs) = default;
        //! Default copy assignment
        Boundary2DFB& operator=(const Boundary2DFB& rhs) = default;
        //! Copy construct from raw
        Boundary2DFB(const XrBoundary2DFB& rhs) : Boundary2DFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Boundary2DFB& operator=(const XrBoundary2DFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrBoundary2DFB &() const { return *reinterpret_cast<const XrBoundary2DFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrBoundary2DFB &() {
            return *reinterpret_cast<XrBoundary2DFB*>(this);
        }

        //! Accessor for this as the address of a raw XrBoundary2DFB
        XrBoundary2DFB const* get() const noexcept { return reinterpret_cast<XrBoundary2DFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrBoundary2DFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrBoundary2DFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = Boundary2DFB{};next = oldNext;}
            return reinterpret_cast<XrBoundary2DFB*>(this);
        }
        uint32_t vertexCapacityInput;
        uint32_t vertexCountOutput;
        Vector2f* vertices;
    };
     static_assert(sizeof(XrBoundary2DFB) == sizeof(Boundary2DFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrBoundary2DFB pointer to const from a Boundary2DFB reference to const.
 * @relates Boundary2DFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBoundary2DFB const* get(Boundary2DFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Boundary2DFB as the address of a raw XrBoundary2DFB
 * @relates Boundary2DFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrBoundary2DFB * put(Boundary2DFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_FB_scene
/*!
 * C++ projection of XrSemanticLabelsSupportInfoFB
 * 
 * Provided by the `XR_FB_scene` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSemanticLabelsSupportInfoFB>
 * @xrentity{XrSemanticLabelsSupportInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SemanticLabelsSupportInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SemanticLabelsSupportInfoFB (
 const SemanticLabelsSupportFlagsFB& flags_,  const char* recognizedLabels_,  const void * next_ = nullptr                  )
: Parent(StructureType::SemanticLabelsSupportInfoFB
, next_)
, flags {flags_}
, recognizedLabels {recognizedLabels_}
        {
        }


        //! Default/empty constructor
                 SemanticLabelsSupportInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SemanticLabelsSupportInfoFB
             , next_)
, flags{}
, recognizedLabels{nullptr}
            {}

        //! Default copy constructor
        SemanticLabelsSupportInfoFB(const SemanticLabelsSupportInfoFB& rhs) = default;
        //! Default copy assignment
        SemanticLabelsSupportInfoFB& operator=(const SemanticLabelsSupportInfoFB& rhs) = default;
        //! Copy construct from raw
        SemanticLabelsSupportInfoFB(const XrSemanticLabelsSupportInfoFB& rhs) : SemanticLabelsSupportInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SemanticLabelsSupportInfoFB& operator=(const XrSemanticLabelsSupportInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSemanticLabelsSupportInfoFB &() const { return *reinterpret_cast<const XrSemanticLabelsSupportInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSemanticLabelsSupportInfoFB &() {
            return *reinterpret_cast<XrSemanticLabelsSupportInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSemanticLabelsSupportInfoFB
        XrSemanticLabelsSupportInfoFB const* get() const noexcept { return reinterpret_cast<XrSemanticLabelsSupportInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSemanticLabelsSupportInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSemanticLabelsSupportInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SemanticLabelsSupportInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSemanticLabelsSupportInfoFB*>(this);
        }
        SemanticLabelsSupportFlagsFB flags;
        const char* recognizedLabels;
    };
     static_assert(sizeof(XrSemanticLabelsSupportInfoFB) == sizeof(SemanticLabelsSupportInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSemanticLabelsSupportInfoFB pointer to const from a SemanticLabelsSupportInfoFB reference to const.
 * @relates SemanticLabelsSupportInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSemanticLabelsSupportInfoFB const* get(SemanticLabelsSupportInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SemanticLabelsSupportInfoFB as the address of a raw XrSemanticLabelsSupportInfoFB
 * @relates SemanticLabelsSupportInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSemanticLabelsSupportInfoFB * put(SemanticLabelsSupportInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene































    #ifdef XR_ALMALENCE_digital_lens_control
/*!
 * C++ projection of XrDigitalLensControlALMALENCE
 * 
 * Provided by the `XR_ALMALENCE_digital_lens_control` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDigitalLensControlALMALENCE>
 * @xrentity{XrDigitalLensControlALMALENCE}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS DigitalLensControlALMALENCE : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                DigitalLensControlALMALENCE (
 const DigitalLensControlFlagsALMALENCE& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::DigitalLensControlALMALENCE
, next_)
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 DigitalLensControlALMALENCE (
            const void * next_ = nullptr)

: Parent(StructureType::DigitalLensControlALMALENCE
             , next_)
, flags{}
            {}

        //! Default copy constructor
        DigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& rhs) = default;
        //! Default copy assignment
        DigitalLensControlALMALENCE& operator=(const DigitalLensControlALMALENCE& rhs) = default;
        //! Copy construct from raw
        DigitalLensControlALMALENCE(const XrDigitalLensControlALMALENCE& rhs) : DigitalLensControlALMALENCE() {
            *put() = rhs;
        }
        //! Copy assign from raw
        DigitalLensControlALMALENCE& operator=(const XrDigitalLensControlALMALENCE& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrDigitalLensControlALMALENCE &() const { return *reinterpret_cast<const XrDigitalLensControlALMALENCE*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrDigitalLensControlALMALENCE &() {
            return *reinterpret_cast<XrDigitalLensControlALMALENCE*>(this);
        }

        //! Accessor for this as the address of a raw XrDigitalLensControlALMALENCE
        XrDigitalLensControlALMALENCE const* get() const noexcept { return reinterpret_cast<XrDigitalLensControlALMALENCE const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrDigitalLensControlALMALENCE.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrDigitalLensControlALMALENCE * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = DigitalLensControlALMALENCE{};next = oldNext;}
            return reinterpret_cast<XrDigitalLensControlALMALENCE*>(this);
        }
        DigitalLensControlFlagsALMALENCE flags;
    };
     static_assert(sizeof(XrDigitalLensControlALMALENCE) == sizeof(DigitalLensControlALMALENCE), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrDigitalLensControlALMALENCE pointer to const from a DigitalLensControlALMALENCE reference to const.
 * @relates DigitalLensControlALMALENCE
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDigitalLensControlALMALENCE const* get(DigitalLensControlALMALENCE const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing DigitalLensControlALMALENCE as the address of a raw XrDigitalLensControlALMALENCE
 * @relates DigitalLensControlALMALENCE
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDigitalLensControlALMALENCE * put(DigitalLensControlALMALENCE &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_ALMALENCE_digital_lens_control































    #ifdef XR_FB_scene_capture
/*!
 * C++ projection of XrEventDataSceneCaptureCompleteFB
 * 
 * Provided by the `XR_FB_scene_capture` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSceneCaptureCompleteFB>
 * @xrentity{XrEventDataSceneCaptureCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSceneCaptureCompleteFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSceneCaptureCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSceneCaptureCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSceneCaptureCompleteFB(const EventDataSceneCaptureCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSceneCaptureCompleteFB& operator=(const EventDataSceneCaptureCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSceneCaptureCompleteFB(const XrEventDataSceneCaptureCompleteFB& rhs) : EventDataSceneCaptureCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSceneCaptureCompleteFB& operator=(const XrEventDataSceneCaptureCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSceneCaptureCompleteFB &() const { return *reinterpret_cast<const XrEventDataSceneCaptureCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSceneCaptureCompleteFB &() {
            return *reinterpret_cast<XrEventDataSceneCaptureCompleteFB*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataSceneCaptureCompleteFB
        XrEventDataSceneCaptureCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSceneCaptureCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSceneCaptureCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSceneCaptureCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSceneCaptureCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSceneCaptureCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
    };
     static_assert(sizeof(XrEventDataSceneCaptureCompleteFB) == sizeof(EventDataSceneCaptureCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSceneCaptureCompleteFB pointer to const from a EventDataSceneCaptureCompleteFB reference to const.
 * @relates EventDataSceneCaptureCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSceneCaptureCompleteFB const* get(EventDataSceneCaptureCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSceneCaptureCompleteFB as the address of a raw XrEventDataSceneCaptureCompleteFB
 * @relates EventDataSceneCaptureCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSceneCaptureCompleteFB * put(EventDataSceneCaptureCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene_capture































    #ifdef XR_FB_scene_capture
/*!
 * C++ projection of XrSceneCaptureRequestInfoFB
 * 
 * Provided by the `XR_FB_scene_capture` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneCaptureRequestInfoFB>
 * @xrentity{XrSceneCaptureRequestInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SceneCaptureRequestInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SceneCaptureRequestInfoFB (
 uint32_t requestByteCount_,  const char* request_,  const void * next_ = nullptr                  )
: Parent(StructureType::SceneCaptureRequestInfoFB
, next_)
, requestByteCount {requestByteCount_}
, request {request_}
        {
        }


        //! Default/empty constructor
                 SceneCaptureRequestInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SceneCaptureRequestInfoFB
             , next_)
, requestByteCount{0}
, request{nullptr}
            {}

        //! Default copy constructor
        SceneCaptureRequestInfoFB(const SceneCaptureRequestInfoFB& rhs) = default;
        //! Default copy assignment
        SceneCaptureRequestInfoFB& operator=(const SceneCaptureRequestInfoFB& rhs) = default;
        //! Copy construct from raw
        SceneCaptureRequestInfoFB(const XrSceneCaptureRequestInfoFB& rhs) : SceneCaptureRequestInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SceneCaptureRequestInfoFB& operator=(const XrSceneCaptureRequestInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSceneCaptureRequestInfoFB &() const { return *reinterpret_cast<const XrSceneCaptureRequestInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSceneCaptureRequestInfoFB &() {
            return *reinterpret_cast<XrSceneCaptureRequestInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSceneCaptureRequestInfoFB
        XrSceneCaptureRequestInfoFB const* get() const noexcept { return reinterpret_cast<XrSceneCaptureRequestInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSceneCaptureRequestInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSceneCaptureRequestInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SceneCaptureRequestInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSceneCaptureRequestInfoFB*>(this);
        }
        uint32_t requestByteCount;
        const char* request;
    };
     static_assert(sizeof(XrSceneCaptureRequestInfoFB) == sizeof(SceneCaptureRequestInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSceneCaptureRequestInfoFB pointer to const from a SceneCaptureRequestInfoFB reference to const.
 * @relates SceneCaptureRequestInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneCaptureRequestInfoFB const* get(SceneCaptureRequestInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneCaptureRequestInfoFB as the address of a raw XrSceneCaptureRequestInfoFB
 * @relates SceneCaptureRequestInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSceneCaptureRequestInfoFB * put(SceneCaptureRequestInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_scene_capture































    #ifdef XR_FB_spatial_entity_container
/*!
 * C++ projection of XrSpaceContainerFB
 * 
 * Provided by the `XR_FB_spatial_entity_container` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceContainerFB>
 * @xrentity{XrSpaceContainerFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceContainerFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceContainerFB (
 uint32_t uuidCapacityInput_,  uint32_t uuidCountOutput_,  UuidEXT* uuids_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceContainerFB
, next_)
, uuidCapacityInput {uuidCapacityInput_}
, uuidCountOutput {uuidCountOutput_}
, uuids {uuids_}
        {
        }


        //! Default/empty constructor
                 SpaceContainerFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceContainerFB
             , next_)
, uuidCapacityInput{0}
, uuidCountOutput{0}
, uuids{nullptr}
            {}

        //! Default copy constructor
        SpaceContainerFB(const SpaceContainerFB& rhs) = default;
        //! Default copy assignment
        SpaceContainerFB& operator=(const SpaceContainerFB& rhs) = default;
        //! Copy construct from raw
        SpaceContainerFB(const XrSpaceContainerFB& rhs) : SpaceContainerFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceContainerFB& operator=(const XrSpaceContainerFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceContainerFB &() const { return *reinterpret_cast<const XrSpaceContainerFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceContainerFB &() {
            return *reinterpret_cast<XrSpaceContainerFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceContainerFB
        XrSpaceContainerFB const* get() const noexcept { return reinterpret_cast<XrSpaceContainerFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceContainerFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceContainerFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceContainerFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceContainerFB*>(this);
        }
        uint32_t uuidCapacityInput;
        uint32_t uuidCountOutput;
        UuidEXT* uuids;
    };
     static_assert(sizeof(XrSpaceContainerFB) == sizeof(SpaceContainerFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceContainerFB pointer to const from a SpaceContainerFB reference to const.
 * @relates SpaceContainerFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceContainerFB const* get(SpaceContainerFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceContainerFB as the address of a raw XrSpaceContainerFB
 * @relates SpaceContainerFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceContainerFB * put(SpaceContainerFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_container































    #ifdef XR_META_foveation_eye_tracked
/*!
 * C++ projection of XrFoveationEyeTrackedProfileCreateInfoMETA
 * 
 * Provided by the `XR_META_foveation_eye_tracked` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationEyeTrackedProfileCreateInfoMETA>
 * @xrentity{XrFoveationEyeTrackedProfileCreateInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationEyeTrackedProfileCreateInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FoveationEyeTrackedProfileCreateInfoMETA (
 const FoveationEyeTrackedProfileCreateFlagsMETA& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::FoveationEyeTrackedProfileCreateInfoMETA
, next_)
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 FoveationEyeTrackedProfileCreateInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::FoveationEyeTrackedProfileCreateInfoMETA
             , next_)
, flags{}
            {}

        //! Default copy constructor
        FoveationEyeTrackedProfileCreateInfoMETA(const FoveationEyeTrackedProfileCreateInfoMETA& rhs) = default;
        //! Default copy assignment
        FoveationEyeTrackedProfileCreateInfoMETA& operator=(const FoveationEyeTrackedProfileCreateInfoMETA& rhs) = default;
        //! Copy construct from raw
        FoveationEyeTrackedProfileCreateInfoMETA(const XrFoveationEyeTrackedProfileCreateInfoMETA& rhs) : FoveationEyeTrackedProfileCreateInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationEyeTrackedProfileCreateInfoMETA& operator=(const XrFoveationEyeTrackedProfileCreateInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationEyeTrackedProfileCreateInfoMETA &() const { return *reinterpret_cast<const XrFoveationEyeTrackedProfileCreateInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationEyeTrackedProfileCreateInfoMETA &() {
            return *reinterpret_cast<XrFoveationEyeTrackedProfileCreateInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationEyeTrackedProfileCreateInfoMETA
        XrFoveationEyeTrackedProfileCreateInfoMETA const* get() const noexcept { return reinterpret_cast<XrFoveationEyeTrackedProfileCreateInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationEyeTrackedProfileCreateInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationEyeTrackedProfileCreateInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationEyeTrackedProfileCreateInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrFoveationEyeTrackedProfileCreateInfoMETA*>(this);
        }
        FoveationEyeTrackedProfileCreateFlagsMETA flags;
    };
     static_assert(sizeof(XrFoveationEyeTrackedProfileCreateInfoMETA) == sizeof(FoveationEyeTrackedProfileCreateInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationEyeTrackedProfileCreateInfoMETA pointer to const from a FoveationEyeTrackedProfileCreateInfoMETA reference to const.
 * @relates FoveationEyeTrackedProfileCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationEyeTrackedProfileCreateInfoMETA const* get(FoveationEyeTrackedProfileCreateInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationEyeTrackedProfileCreateInfoMETA as the address of a raw XrFoveationEyeTrackedProfileCreateInfoMETA
 * @relates FoveationEyeTrackedProfileCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationEyeTrackedProfileCreateInfoMETA * put(FoveationEyeTrackedProfileCreateInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_foveation_eye_tracked































    #ifdef XR_META_foveation_eye_tracked
/*!
 * C++ projection of XrFoveationEyeTrackedStateMETA
 * 
 * Provided by the `XR_META_foveation_eye_tracked` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationEyeTrackedStateMETA>
 * @xrentity{XrFoveationEyeTrackedStateMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationEyeTrackedStateMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 FoveationEyeTrackedStateMETA (
            void * next_ = nullptr)

: Parent(StructureType::FoveationEyeTrackedStateMETA
             , next_)
            {}

        //! Default copy constructor
        FoveationEyeTrackedStateMETA(const FoveationEyeTrackedStateMETA& rhs) = default;
        //! Default copy assignment
        FoveationEyeTrackedStateMETA& operator=(const FoveationEyeTrackedStateMETA& rhs) = default;
        //! Copy construct from raw
        FoveationEyeTrackedStateMETA(const XrFoveationEyeTrackedStateMETA& rhs) : FoveationEyeTrackedStateMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationEyeTrackedStateMETA& operator=(const XrFoveationEyeTrackedStateMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationEyeTrackedStateMETA &() const { return *reinterpret_cast<const XrFoveationEyeTrackedStateMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationEyeTrackedStateMETA &() {
            return *reinterpret_cast<XrFoveationEyeTrackedStateMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationEyeTrackedStateMETA
        XrFoveationEyeTrackedStateMETA const* get() const noexcept { return reinterpret_cast<XrFoveationEyeTrackedStateMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationEyeTrackedStateMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationEyeTrackedStateMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationEyeTrackedStateMETA{};next = oldNext;}
            return reinterpret_cast<XrFoveationEyeTrackedStateMETA*>(this);
        }
        Vector2f foveationCenter[XR_FOVEATION_CENTER_SIZE_META];
        FoveationEyeTrackedStateFlagsMETA flags;
    };
     static_assert(sizeof(XrFoveationEyeTrackedStateMETA) == sizeof(FoveationEyeTrackedStateMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationEyeTrackedStateMETA pointer to const from a FoveationEyeTrackedStateMETA reference to const.
 * @relates FoveationEyeTrackedStateMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationEyeTrackedStateMETA const* get(FoveationEyeTrackedStateMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationEyeTrackedStateMETA as the address of a raw XrFoveationEyeTrackedStateMETA
 * @relates FoveationEyeTrackedStateMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationEyeTrackedStateMETA * put(FoveationEyeTrackedStateMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_foveation_eye_tracked































    #ifdef XR_META_foveation_eye_tracked
/*!
 * C++ projection of XrSystemFoveationEyeTrackedPropertiesMETA
 * 
 * Provided by the `XR_META_foveation_eye_tracked` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFoveationEyeTrackedPropertiesMETA>
 * @xrentity{XrSystemFoveationEyeTrackedPropertiesMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemFoveationEyeTrackedPropertiesMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemFoveationEyeTrackedPropertiesMETA (
            void * next_ = nullptr)

: Parent(StructureType::SystemFoveationEyeTrackedPropertiesMETA
             , next_)
            {}

        //! Default copy constructor
        SystemFoveationEyeTrackedPropertiesMETA(const SystemFoveationEyeTrackedPropertiesMETA& rhs) = default;
        //! Default copy assignment
        SystemFoveationEyeTrackedPropertiesMETA& operator=(const SystemFoveationEyeTrackedPropertiesMETA& rhs) = default;
        //! Copy construct from raw
        SystemFoveationEyeTrackedPropertiesMETA(const XrSystemFoveationEyeTrackedPropertiesMETA& rhs) : SystemFoveationEyeTrackedPropertiesMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemFoveationEyeTrackedPropertiesMETA& operator=(const XrSystemFoveationEyeTrackedPropertiesMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemFoveationEyeTrackedPropertiesMETA &() const { return *reinterpret_cast<const XrSystemFoveationEyeTrackedPropertiesMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemFoveationEyeTrackedPropertiesMETA &() {
            return *reinterpret_cast<XrSystemFoveationEyeTrackedPropertiesMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemFoveationEyeTrackedPropertiesMETA
        XrSystemFoveationEyeTrackedPropertiesMETA const* get() const noexcept { return reinterpret_cast<XrSystemFoveationEyeTrackedPropertiesMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemFoveationEyeTrackedPropertiesMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemFoveationEyeTrackedPropertiesMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemFoveationEyeTrackedPropertiesMETA{};next = oldNext;}
            return reinterpret_cast<XrSystemFoveationEyeTrackedPropertiesMETA*>(this);
        }
        Bool32 supportsFoveationEyeTracked;
    };
     static_assert(sizeof(XrSystemFoveationEyeTrackedPropertiesMETA) == sizeof(SystemFoveationEyeTrackedPropertiesMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemFoveationEyeTrackedPropertiesMETA pointer to const from a SystemFoveationEyeTrackedPropertiesMETA reference to const.
 * @relates SystemFoveationEyeTrackedPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFoveationEyeTrackedPropertiesMETA const* get(SystemFoveationEyeTrackedPropertiesMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemFoveationEyeTrackedPropertiesMETA as the address of a raw XrSystemFoveationEyeTrackedPropertiesMETA
 * @relates SystemFoveationEyeTrackedPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFoveationEyeTrackedPropertiesMETA * put(SystemFoveationEyeTrackedPropertiesMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_foveation_eye_tracked































    #ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrSystemFaceTrackingPropertiesFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFaceTrackingPropertiesFB>
 * @xrentity{XrSystemFaceTrackingPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemFaceTrackingPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemFaceTrackingPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemFaceTrackingPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemFaceTrackingPropertiesFB(const SystemFaceTrackingPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemFaceTrackingPropertiesFB& operator=(const SystemFaceTrackingPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemFaceTrackingPropertiesFB(const XrSystemFaceTrackingPropertiesFB& rhs) : SystemFaceTrackingPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemFaceTrackingPropertiesFB& operator=(const XrSystemFaceTrackingPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemFaceTrackingPropertiesFB &() const { return *reinterpret_cast<const XrSystemFaceTrackingPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemFaceTrackingPropertiesFB &() {
            return *reinterpret_cast<XrSystemFaceTrackingPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemFaceTrackingPropertiesFB
        XrSystemFaceTrackingPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemFaceTrackingPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemFaceTrackingPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemFaceTrackingPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemFaceTrackingPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemFaceTrackingPropertiesFB*>(this);
        }
        Bool32 supportsFaceTracking;
    };
     static_assert(sizeof(XrSystemFaceTrackingPropertiesFB) == sizeof(SystemFaceTrackingPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemFaceTrackingPropertiesFB pointer to const from a SystemFaceTrackingPropertiesFB reference to const.
 * @relates SystemFaceTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFaceTrackingPropertiesFB const* get(SystemFaceTrackingPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemFaceTrackingPropertiesFB as the address of a raw XrSystemFaceTrackingPropertiesFB
 * @relates SystemFaceTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemFaceTrackingPropertiesFB * put(SystemFaceTrackingPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_face_tracking































    #ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceTrackerCreateInfoFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceTrackerCreateInfoFB>
 * @xrentity{XrFaceTrackerCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FaceTrackerCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FaceTrackerCreateInfoFB (
 const FaceExpressionSetFB& faceExpressionSet_,  const void * next_ = nullptr                  )
: Parent(StructureType::FaceTrackerCreateInfoFB
, next_)
, faceExpressionSet {faceExpressionSet_}
        {
        }


        //! Default/empty constructor
                 FaceTrackerCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::FaceTrackerCreateInfoFB
             , next_)
, faceExpressionSet{}
            {}

        //! Default copy constructor
        FaceTrackerCreateInfoFB(const FaceTrackerCreateInfoFB& rhs) = default;
        //! Default copy assignment
        FaceTrackerCreateInfoFB& operator=(const FaceTrackerCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        FaceTrackerCreateInfoFB(const XrFaceTrackerCreateInfoFB& rhs) : FaceTrackerCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FaceTrackerCreateInfoFB& operator=(const XrFaceTrackerCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFaceTrackerCreateInfoFB &() const { return *reinterpret_cast<const XrFaceTrackerCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFaceTrackerCreateInfoFB &() {
            return *reinterpret_cast<XrFaceTrackerCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrFaceTrackerCreateInfoFB
        XrFaceTrackerCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrFaceTrackerCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFaceTrackerCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFaceTrackerCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FaceTrackerCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrFaceTrackerCreateInfoFB*>(this);
        }
        FaceExpressionSetFB faceExpressionSet;
    };
     static_assert(sizeof(XrFaceTrackerCreateInfoFB) == sizeof(FaceTrackerCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFaceTrackerCreateInfoFB pointer to const from a FaceTrackerCreateInfoFB reference to const.
 * @relates FaceTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceTrackerCreateInfoFB const* get(FaceTrackerCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceTrackerCreateInfoFB as the address of a raw XrFaceTrackerCreateInfoFB
 * @relates FaceTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceTrackerCreateInfoFB * put(FaceTrackerCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_face_tracking































    #ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceExpressionInfoFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionInfoFB>
 * @xrentity{XrFaceExpressionInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FaceExpressionInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FaceExpressionInfoFB (
 const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::FaceExpressionInfoFB
, next_)
, time {time_}
        {
        }


        //! Default/empty constructor
                 FaceExpressionInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::FaceExpressionInfoFB
             , next_)
, time{}
            {}

        //! Default copy constructor
        FaceExpressionInfoFB(const FaceExpressionInfoFB& rhs) = default;
        //! Default copy assignment
        FaceExpressionInfoFB& operator=(const FaceExpressionInfoFB& rhs) = default;
        //! Copy construct from raw
        FaceExpressionInfoFB(const XrFaceExpressionInfoFB& rhs) : FaceExpressionInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FaceExpressionInfoFB& operator=(const XrFaceExpressionInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFaceExpressionInfoFB &() const { return *reinterpret_cast<const XrFaceExpressionInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFaceExpressionInfoFB &() {
            return *reinterpret_cast<XrFaceExpressionInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrFaceExpressionInfoFB
        XrFaceExpressionInfoFB const* get() const noexcept { return reinterpret_cast<XrFaceExpressionInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFaceExpressionInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFaceExpressionInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FaceExpressionInfoFB{};next = oldNext;}
            return reinterpret_cast<XrFaceExpressionInfoFB*>(this);
        }
        Time time;
    };
     static_assert(sizeof(XrFaceExpressionInfoFB) == sizeof(FaceExpressionInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFaceExpressionInfoFB pointer to const from a FaceExpressionInfoFB reference to const.
 * @relates FaceExpressionInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceExpressionInfoFB const* get(FaceExpressionInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionInfoFB as the address of a raw XrFaceExpressionInfoFB
 * @relates FaceExpressionInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceExpressionInfoFB * put(FaceExpressionInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_face_tracking































    #ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceExpressionStatusFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionStatusFB>
 * @xrentity{XrFaceExpressionStatusFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS FaceExpressionStatusFB 
    {
    public:
        //! Constructor initializing all members.
                FaceExpressionStatusFB (
 const Bool32& isValid_,  const Bool32& isEyeFollowingBlendshapesValid_                  )
: isValid {isValid_}
, isEyeFollowingBlendshapesValid {isEyeFollowingBlendshapesValid_}
        {
        }


        //! Default/empty constructor
                 FaceExpressionStatusFB (
            )

: isValid{false}
, isEyeFollowingBlendshapesValid{false}
            {}

        //! Default copy constructor
        FaceExpressionStatusFB(const FaceExpressionStatusFB& rhs) = default;
        //! Default copy assignment
        FaceExpressionStatusFB& operator=(const FaceExpressionStatusFB& rhs) = default;
        //! Copy construct from raw
        FaceExpressionStatusFB(const XrFaceExpressionStatusFB& rhs) : FaceExpressionStatusFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FaceExpressionStatusFB& operator=(const XrFaceExpressionStatusFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFaceExpressionStatusFB &() const { return *reinterpret_cast<const XrFaceExpressionStatusFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFaceExpressionStatusFB &() {
            return *reinterpret_cast<XrFaceExpressionStatusFB*>(this);
        }

        //! Accessor for this as the address of a raw XrFaceExpressionStatusFB
        XrFaceExpressionStatusFB const* get() const noexcept { return reinterpret_cast<XrFaceExpressionStatusFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFaceExpressionStatusFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrFaceExpressionStatusFB * put(bool clear = true) noexcept {
            if (clear) {*this = FaceExpressionStatusFB{};}
            return reinterpret_cast<XrFaceExpressionStatusFB*>(this);
        }
        Bool32 isValid;
        Bool32 isEyeFollowingBlendshapesValid;
    };
     static_assert(sizeof(XrFaceExpressionStatusFB) == sizeof(FaceExpressionStatusFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFaceExpressionStatusFB pointer to const from a FaceExpressionStatusFB reference to const.
 * @relates FaceExpressionStatusFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceExpressionStatusFB const* get(FaceExpressionStatusFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionStatusFB as the address of a raw XrFaceExpressionStatusFB
 * @relates FaceExpressionStatusFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceExpressionStatusFB * put(FaceExpressionStatusFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_face_tracking































    #ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceExpressionWeightsFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionWeightsFB>
 * @xrentity{XrFaceExpressionWeightsFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FaceExpressionWeightsFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 FaceExpressionWeightsFB (
            void * next_ = nullptr)

: Parent(StructureType::FaceExpressionWeightsFB
             , next_)
            {}

        //! Default copy constructor
        FaceExpressionWeightsFB(const FaceExpressionWeightsFB& rhs) = default;
        //! Default copy assignment
        FaceExpressionWeightsFB& operator=(const FaceExpressionWeightsFB& rhs) = default;
        //! Copy construct from raw
        FaceExpressionWeightsFB(const XrFaceExpressionWeightsFB& rhs) : FaceExpressionWeightsFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FaceExpressionWeightsFB& operator=(const XrFaceExpressionWeightsFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFaceExpressionWeightsFB &() const { return *reinterpret_cast<const XrFaceExpressionWeightsFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFaceExpressionWeightsFB &() {
            return *reinterpret_cast<XrFaceExpressionWeightsFB*>(this);
        }

        //! Accessor for this as the address of a raw XrFaceExpressionWeightsFB
        XrFaceExpressionWeightsFB const* get() const noexcept { return reinterpret_cast<XrFaceExpressionWeightsFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFaceExpressionWeightsFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFaceExpressionWeightsFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FaceExpressionWeightsFB{};next = oldNext;}
            return reinterpret_cast<XrFaceExpressionWeightsFB*>(this);
        }
        uint32_t weightCount;
        float* weights;
        uint32_t confidenceCount;
        float* confidences;
        FaceExpressionStatusFB status;
        Time time;
    };
     static_assert(sizeof(XrFaceExpressionWeightsFB) == sizeof(FaceExpressionWeightsFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFaceExpressionWeightsFB pointer to const from a FaceExpressionWeightsFB reference to const.
 * @relates FaceExpressionWeightsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceExpressionWeightsFB const* get(FaceExpressionWeightsFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionWeightsFB as the address of a raw XrFaceExpressionWeightsFB
 * @relates FaceExpressionWeightsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFaceExpressionWeightsFB * put(FaceExpressionWeightsFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_face_tracking































    #ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeGazeFB
 * 
 * Provided by the `XR_FB_eye_tracking_social` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazeFB>
 * @xrentity{XrEyeGazeFB}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS EyeGazeFB 
    {
    public:
        //! Constructor initializing all members.
                EyeGazeFB (
 const Bool32& isValid_,  const Posef& gazePose_,  float gazeConfidence_                  )
: isValid {isValid_}
, gazePose {gazePose_}
, gazeConfidence {gazeConfidence_}
        {
        }


        //! Default/empty constructor
                 EyeGazeFB (
            )

: isValid{false}
, gazePose{}
, gazeConfidence{0.0f}
            {}

        //! Default copy constructor
        EyeGazeFB(const EyeGazeFB& rhs) = default;
        //! Default copy assignment
        EyeGazeFB& operator=(const EyeGazeFB& rhs) = default;
        //! Copy construct from raw
        EyeGazeFB(const XrEyeGazeFB& rhs) : EyeGazeFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EyeGazeFB& operator=(const XrEyeGazeFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEyeGazeFB &() const { return *reinterpret_cast<const XrEyeGazeFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEyeGazeFB &() {
            return *reinterpret_cast<XrEyeGazeFB*>(this);
        }

        //! Accessor for this as the address of a raw XrEyeGazeFB
        XrEyeGazeFB const* get() const noexcept { return reinterpret_cast<XrEyeGazeFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazeFB.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrEyeGazeFB * put(bool clear = true) noexcept {
            if (clear) {*this = EyeGazeFB{};}
            return reinterpret_cast<XrEyeGazeFB*>(this);
        }
        Bool32 isValid;
        Posef gazePose;
        float gazeConfidence;
    };
     static_assert(sizeof(XrEyeGazeFB) == sizeof(EyeGazeFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEyeGazeFB pointer to const from a EyeGazeFB reference to const.
 * @relates EyeGazeFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazeFB const* get(EyeGazeFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazeFB as the address of a raw XrEyeGazeFB
 * @relates EyeGazeFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazeFB * put(EyeGazeFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_eye_tracking_social































    #ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeTrackerCreateInfoFB
 * 
 * Provided by the `XR_FB_eye_tracking_social` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeTrackerCreateInfoFB>
 * @xrentity{XrEyeTrackerCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EyeTrackerCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Default/empty constructor
                 EyeTrackerCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::EyeTrackerCreateInfoFB
             , next_)
            {}

        //! Default copy constructor
        EyeTrackerCreateInfoFB(const EyeTrackerCreateInfoFB& rhs) = default;
        //! Default copy assignment
        EyeTrackerCreateInfoFB& operator=(const EyeTrackerCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        EyeTrackerCreateInfoFB(const XrEyeTrackerCreateInfoFB& rhs) : EyeTrackerCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EyeTrackerCreateInfoFB& operator=(const XrEyeTrackerCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEyeTrackerCreateInfoFB &() const { return *reinterpret_cast<const XrEyeTrackerCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEyeTrackerCreateInfoFB &() {
            return *reinterpret_cast<XrEyeTrackerCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrEyeTrackerCreateInfoFB
        XrEyeTrackerCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrEyeTrackerCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEyeTrackerCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEyeTrackerCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EyeTrackerCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrEyeTrackerCreateInfoFB*>(this);
        }
    };
     static_assert(sizeof(XrEyeTrackerCreateInfoFB) == sizeof(EyeTrackerCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEyeTrackerCreateInfoFB pointer to const from a EyeTrackerCreateInfoFB reference to const.
 * @relates EyeTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeTrackerCreateInfoFB const* get(EyeTrackerCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeTrackerCreateInfoFB as the address of a raw XrEyeTrackerCreateInfoFB
 * @relates EyeTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeTrackerCreateInfoFB * put(EyeTrackerCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_eye_tracking_social































    #ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeGazesInfoFB
 * 
 * Provided by the `XR_FB_eye_tracking_social` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazesInfoFB>
 * @xrentity{XrEyeGazesInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EyeGazesInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                EyeGazesInfoFB (
 const Space& baseSpace_,  const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::EyeGazesInfoFB
, next_)
, baseSpace {baseSpace_}
, time {time_}
        {
        }


        //! Default/empty constructor
                 EyeGazesInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::EyeGazesInfoFB
             , next_)
, baseSpace{}
, time{}
            {}

        //! Default copy constructor
        EyeGazesInfoFB(const EyeGazesInfoFB& rhs) = default;
        //! Default copy assignment
        EyeGazesInfoFB& operator=(const EyeGazesInfoFB& rhs) = default;
        //! Copy construct from raw
        EyeGazesInfoFB(const XrEyeGazesInfoFB& rhs) : EyeGazesInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EyeGazesInfoFB& operator=(const XrEyeGazesInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEyeGazesInfoFB &() const { return *reinterpret_cast<const XrEyeGazesInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEyeGazesInfoFB &() {
            return *reinterpret_cast<XrEyeGazesInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrEyeGazesInfoFB
        XrEyeGazesInfoFB const* get() const noexcept { return reinterpret_cast<XrEyeGazesInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazesInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEyeGazesInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EyeGazesInfoFB{};next = oldNext;}
            return reinterpret_cast<XrEyeGazesInfoFB*>(this);
        }
        Space baseSpace;
        Time time;
    };
     static_assert(sizeof(XrEyeGazesInfoFB) == sizeof(EyeGazesInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEyeGazesInfoFB pointer to const from a EyeGazesInfoFB reference to const.
 * @relates EyeGazesInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazesInfoFB const* get(EyeGazesInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazesInfoFB as the address of a raw XrEyeGazesInfoFB
 * @relates EyeGazesInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazesInfoFB * put(EyeGazesInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_eye_tracking_social































    #ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrSystemEyeTrackingPropertiesFB
 * 
 * Provided by the `XR_FB_eye_tracking_social` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEyeTrackingPropertiesFB>
 * @xrentity{XrSystemEyeTrackingPropertiesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemEyeTrackingPropertiesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemEyeTrackingPropertiesFB (
            void * next_ = nullptr)

: Parent(StructureType::SystemEyeTrackingPropertiesFB
             , next_)
            {}

        //! Default copy constructor
        SystemEyeTrackingPropertiesFB(const SystemEyeTrackingPropertiesFB& rhs) = default;
        //! Default copy assignment
        SystemEyeTrackingPropertiesFB& operator=(const SystemEyeTrackingPropertiesFB& rhs) = default;
        //! Copy construct from raw
        SystemEyeTrackingPropertiesFB(const XrSystemEyeTrackingPropertiesFB& rhs) : SystemEyeTrackingPropertiesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemEyeTrackingPropertiesFB& operator=(const XrSystemEyeTrackingPropertiesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemEyeTrackingPropertiesFB &() const { return *reinterpret_cast<const XrSystemEyeTrackingPropertiesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemEyeTrackingPropertiesFB &() {
            return *reinterpret_cast<XrSystemEyeTrackingPropertiesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemEyeTrackingPropertiesFB
        XrSystemEyeTrackingPropertiesFB const* get() const noexcept { return reinterpret_cast<XrSystemEyeTrackingPropertiesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemEyeTrackingPropertiesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemEyeTrackingPropertiesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemEyeTrackingPropertiesFB{};next = oldNext;}
            return reinterpret_cast<XrSystemEyeTrackingPropertiesFB*>(this);
        }
        Bool32 supportsEyeTracking;
    };
     static_assert(sizeof(XrSystemEyeTrackingPropertiesFB) == sizeof(SystemEyeTrackingPropertiesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemEyeTrackingPropertiesFB pointer to const from a SystemEyeTrackingPropertiesFB reference to const.
 * @relates SystemEyeTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemEyeTrackingPropertiesFB const* get(SystemEyeTrackingPropertiesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemEyeTrackingPropertiesFB as the address of a raw XrSystemEyeTrackingPropertiesFB
 * @relates SystemEyeTrackingPropertiesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemEyeTrackingPropertiesFB * put(SystemEyeTrackingPropertiesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_eye_tracking_social































    #ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeGazesFB
 * 
 * Provided by the `XR_FB_eye_tracking_social` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazesFB>
 * @xrentity{XrEyeGazesFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EyeGazesFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EyeGazesFB (
            void * next_ = nullptr)

: Parent(StructureType::EyeGazesFB
             , next_)
            {}

        //! Default copy constructor
        EyeGazesFB(const EyeGazesFB& rhs) = default;
        //! Default copy assignment
        EyeGazesFB& operator=(const EyeGazesFB& rhs) = default;
        //! Copy construct from raw
        EyeGazesFB(const XrEyeGazesFB& rhs) : EyeGazesFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EyeGazesFB& operator=(const XrEyeGazesFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEyeGazesFB &() const { return *reinterpret_cast<const XrEyeGazesFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEyeGazesFB &() {
            return *reinterpret_cast<XrEyeGazesFB*>(this);
        }

        //! Accessor for this as the address of a raw XrEyeGazesFB
        XrEyeGazesFB const* get() const noexcept { return reinterpret_cast<XrEyeGazesFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazesFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEyeGazesFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EyeGazesFB{};next = oldNext;}
            return reinterpret_cast<XrEyeGazesFB*>(this);
        }
        EyeGazeFB gaze[XR_EYE_POSITION_COUNT_FB];
        Time time;
    };
     static_assert(sizeof(XrEyeGazesFB) == sizeof(EyeGazesFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEyeGazesFB pointer to const from a EyeGazesFB reference to const.
 * @relates EyeGazesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazesFB const* get(EyeGazesFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazesFB as the address of a raw XrEyeGazesFB
 * @relates EyeGazesFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEyeGazesFB * put(EyeGazesFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_eye_tracking_social































    #ifdef XR_FB_passthrough_keyboard_hands
/*!
 * C++ projection of XrPassthroughKeyboardHandsIntensityFB
 * 
 * Provided by the `XR_FB_passthrough_keyboard_hands` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughKeyboardHandsIntensityFB>
 * @xrentity{XrPassthroughKeyboardHandsIntensityFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughKeyboardHandsIntensityFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughKeyboardHandsIntensityFB (
 float leftHandIntensity_,  float rightHandIntensity_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughKeyboardHandsIntensityFB
, next_)
, leftHandIntensity {leftHandIntensity_}
, rightHandIntensity {rightHandIntensity_}
        {
        }


        //! Default/empty constructor
                 PassthroughKeyboardHandsIntensityFB (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughKeyboardHandsIntensityFB
             , next_)
, leftHandIntensity{0.0f}
, rightHandIntensity{0.0f}
            {}

        //! Default copy constructor
        PassthroughKeyboardHandsIntensityFB(const PassthroughKeyboardHandsIntensityFB& rhs) = default;
        //! Default copy assignment
        PassthroughKeyboardHandsIntensityFB& operator=(const PassthroughKeyboardHandsIntensityFB& rhs) = default;
        //! Copy construct from raw
        PassthroughKeyboardHandsIntensityFB(const XrPassthroughKeyboardHandsIntensityFB& rhs) : PassthroughKeyboardHandsIntensityFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughKeyboardHandsIntensityFB& operator=(const XrPassthroughKeyboardHandsIntensityFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughKeyboardHandsIntensityFB &() const { return *reinterpret_cast<const XrPassthroughKeyboardHandsIntensityFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughKeyboardHandsIntensityFB &() {
            return *reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughKeyboardHandsIntensityFB
        XrPassthroughKeyboardHandsIntensityFB const* get() const noexcept { return reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughKeyboardHandsIntensityFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughKeyboardHandsIntensityFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughKeyboardHandsIntensityFB{};next = oldNext;}
            return reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB*>(this);
        }
        float leftHandIntensity;
        float rightHandIntensity;
    };
     static_assert(sizeof(XrPassthroughKeyboardHandsIntensityFB) == sizeof(PassthroughKeyboardHandsIntensityFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughKeyboardHandsIntensityFB pointer to const from a PassthroughKeyboardHandsIntensityFB reference to const.
 * @relates PassthroughKeyboardHandsIntensityFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughKeyboardHandsIntensityFB const* get(PassthroughKeyboardHandsIntensityFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughKeyboardHandsIntensityFB as the address of a raw XrPassthroughKeyboardHandsIntensityFB
 * @relates PassthroughKeyboardHandsIntensityFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughKeyboardHandsIntensityFB * put(PassthroughKeyboardHandsIntensityFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_passthrough_keyboard_hands































    #ifdef XR_FB_composition_layer_settings
/*!
 * C++ projection of XrCompositionLayerSettingsFB
 * 
 * Provided by the `XR_FB_composition_layer_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSettingsFB>
 * @xrentity{XrCompositionLayerSettingsFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerSettingsFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerSettingsFB (
 const CompositionLayerSettingsFlagsFB& layerFlags_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerSettingsFB
, next_)
, layerFlags {layerFlags_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerSettingsFB (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerSettingsFB
             , next_)
, layerFlags{}
            {}

        //! Default copy constructor
        CompositionLayerSettingsFB(const CompositionLayerSettingsFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerSettingsFB& operator=(const CompositionLayerSettingsFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerSettingsFB(const XrCompositionLayerSettingsFB& rhs) : CompositionLayerSettingsFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerSettingsFB& operator=(const XrCompositionLayerSettingsFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerSettingsFB &() const { return *reinterpret_cast<const XrCompositionLayerSettingsFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerSettingsFB &() {
            return *reinterpret_cast<XrCompositionLayerSettingsFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerSettingsFB
        XrCompositionLayerSettingsFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerSettingsFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerSettingsFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerSettingsFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerSettingsFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerSettingsFB*>(this);
        }
        CompositionLayerSettingsFlagsFB layerFlags;
    };
     static_assert(sizeof(XrCompositionLayerSettingsFB) == sizeof(CompositionLayerSettingsFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerSettingsFB pointer to const from a CompositionLayerSettingsFB reference to const.
 * @relates CompositionLayerSettingsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerSettingsFB const* get(CompositionLayerSettingsFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerSettingsFB as the address of a raw XrCompositionLayerSettingsFB
 * @relates CompositionLayerSettingsFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerSettingsFB * put(CompositionLayerSettingsFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_composition_layer_settings































    #ifdef XR_FB_haptic_pcm
/*!
 * C++ projection of XrHapticPcmVibrationFB
 * 
 * Provided by the `XR_FB_haptic_pcm` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticPcmVibrationFB>
 * @xrentity{XrHapticPcmVibrationFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HapticPcmVibrationFB : public HapticBaseHeader
    {
    private:
        using Parent = HapticBaseHeader;
    public:
        //! Constructor initializing all members.
                HapticPcmVibrationFB (
 uint32_t bufferSize_,  const float* buffer_,  float sampleRate_,  const Bool32& append_,  uint32_t* samplesConsumed_,  const void * next_ = nullptr                  )
: Parent(StructureType::HapticPcmVibrationFB
, next_)
, bufferSize {bufferSize_}
, buffer {buffer_}
, sampleRate {sampleRate_}
, append {append_}
, samplesConsumed {samplesConsumed_}
        {
        }


        //! Default/empty constructor
                 HapticPcmVibrationFB (
            const void * next_ = nullptr)

: Parent(StructureType::HapticPcmVibrationFB
             , next_)
, bufferSize{0}
, buffer{nullptr}
, sampleRate{0.0f}
, append{false}
, samplesConsumed{nullptr}
            {}

        //! Default copy constructor
        HapticPcmVibrationFB(const HapticPcmVibrationFB& rhs) = default;
        //! Default copy assignment
        HapticPcmVibrationFB& operator=(const HapticPcmVibrationFB& rhs) = default;
        //! Copy construct from raw
        HapticPcmVibrationFB(const XrHapticPcmVibrationFB& rhs) : HapticPcmVibrationFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HapticPcmVibrationFB& operator=(const XrHapticPcmVibrationFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHapticPcmVibrationFB &() const { return *reinterpret_cast<const XrHapticPcmVibrationFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHapticPcmVibrationFB &() {
            return *reinterpret_cast<XrHapticPcmVibrationFB*>(this);
        }

        //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
        XrHapticBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrHapticBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrHapticPcmVibrationFB
        XrHapticPcmVibrationFB const* get() const noexcept { return reinterpret_cast<XrHapticPcmVibrationFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHapticPcmVibrationFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHapticPcmVibrationFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HapticPcmVibrationFB{};next = oldNext;}
            return reinterpret_cast<XrHapticPcmVibrationFB*>(this);
        }
        uint32_t bufferSize;
        const float* buffer;
        float sampleRate;
        Bool32 append;
        uint32_t* samplesConsumed;
    };
     static_assert(sizeof(XrHapticPcmVibrationFB) == sizeof(HapticPcmVibrationFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHapticPcmVibrationFB pointer to const from a HapticPcmVibrationFB reference to const.
 * @relates HapticPcmVibrationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticPcmVibrationFB const* get(HapticPcmVibrationFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticPcmVibrationFB as the address of a raw XrHapticPcmVibrationFB
 * @relates HapticPcmVibrationFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticPcmVibrationFB * put(HapticPcmVibrationFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const HapticPcmVibrationFB as a raw, pointer to const XrHapticBaseHeader (the base type)
 * @relates HapticPcmVibrationFB
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticPcmVibrationFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_haptic_pcm































    #ifdef XR_FB_haptic_pcm
/*!
 * C++ projection of XrDevicePcmSampleRateStateFB
 * 
 * Provided by the `XR_FB_haptic_pcm` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDevicePcmSampleRateStateFB>
 * @xrentity{XrDevicePcmSampleRateStateFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS DevicePcmSampleRateStateFB : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 DevicePcmSampleRateStateFB (
            void * next_ = nullptr)

: Parent(StructureType::DevicePcmSampleRateStateFB
             , next_)
            {}

        //! Default copy constructor
        DevicePcmSampleRateStateFB(const DevicePcmSampleRateStateFB& rhs) = default;
        //! Default copy assignment
        DevicePcmSampleRateStateFB& operator=(const DevicePcmSampleRateStateFB& rhs) = default;
        //! Copy construct from raw
        DevicePcmSampleRateStateFB(const XrDevicePcmSampleRateStateFB& rhs) : DevicePcmSampleRateStateFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        DevicePcmSampleRateStateFB& operator=(const XrDevicePcmSampleRateStateFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrDevicePcmSampleRateStateFB &() const { return *reinterpret_cast<const XrDevicePcmSampleRateStateFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrDevicePcmSampleRateStateFB &() {
            return *reinterpret_cast<XrDevicePcmSampleRateStateFB*>(this);
        }

        //! Accessor for this as the address of a raw XrDevicePcmSampleRateStateFB
        XrDevicePcmSampleRateStateFB const* get() const noexcept { return reinterpret_cast<XrDevicePcmSampleRateStateFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrDevicePcmSampleRateStateFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrDevicePcmSampleRateStateFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = DevicePcmSampleRateStateFB{};next = oldNext;}
            return reinterpret_cast<XrDevicePcmSampleRateStateFB*>(this);
        }
        float sampleRate;
    };
     static_assert(sizeof(XrDevicePcmSampleRateStateFB) == sizeof(DevicePcmSampleRateStateFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrDevicePcmSampleRateStateFB pointer to const from a DevicePcmSampleRateStateFB reference to const.
 * @relates DevicePcmSampleRateStateFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDevicePcmSampleRateStateFB const* get(DevicePcmSampleRateStateFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing DevicePcmSampleRateStateFB as the address of a raw XrDevicePcmSampleRateStateFB
 * @relates DevicePcmSampleRateStateFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrDevicePcmSampleRateStateFB * put(DevicePcmSampleRateStateFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_haptic_pcm































    #ifdef XR_FB_composition_layer_depth_test
/*!
 * C++ projection of XrCompositionLayerDepthTestFB
 * 
 * Provided by the `XR_FB_composition_layer_depth_test` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthTestFB>
 * @xrentity{XrCompositionLayerDepthTestFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerDepthTestFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                CompositionLayerDepthTestFB (
 const Bool32& depthMask_,  const CompareOpFB& compareOp_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerDepthTestFB
, next_)
, depthMask {depthMask_}
, compareOp {compareOp_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerDepthTestFB (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerDepthTestFB
             , next_)
, depthMask{false}
, compareOp{}
            {}

        //! Default copy constructor
        CompositionLayerDepthTestFB(const CompositionLayerDepthTestFB& rhs) = default;
        //! Default copy assignment
        CompositionLayerDepthTestFB& operator=(const CompositionLayerDepthTestFB& rhs) = default;
        //! Copy construct from raw
        CompositionLayerDepthTestFB(const XrCompositionLayerDepthTestFB& rhs) : CompositionLayerDepthTestFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerDepthTestFB& operator=(const XrCompositionLayerDepthTestFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerDepthTestFB &() const { return *reinterpret_cast<const XrCompositionLayerDepthTestFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerDepthTestFB &() {
            return *reinterpret_cast<XrCompositionLayerDepthTestFB*>(this);
        }

        //! Accessor for this as the address of a raw XrCompositionLayerDepthTestFB
        XrCompositionLayerDepthTestFB const* get() const noexcept { return reinterpret_cast<XrCompositionLayerDepthTestFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerDepthTestFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerDepthTestFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerDepthTestFB{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerDepthTestFB*>(this);
        }
        Bool32 depthMask;
        CompareOpFB compareOp;
    };
     static_assert(sizeof(XrCompositionLayerDepthTestFB) == sizeof(CompositionLayerDepthTestFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthTestFB pointer to const from a CompositionLayerDepthTestFB reference to const.
 * @relates CompositionLayerDepthTestFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerDepthTestFB const* get(CompositionLayerDepthTestFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthTestFB as the address of a raw XrCompositionLayerDepthTestFB
 * @relates CompositionLayerDepthTestFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerDepthTestFB * put(CompositionLayerDepthTestFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_composition_layer_depth_test































    #ifdef XR_META_local_dimming
/*!
 * C++ projection of XrLocalDimmingFrameEndInfoMETA
 * 
 * Provided by the `XR_META_local_dimming` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalDimmingFrameEndInfoMETA>
 * @xrentity{XrLocalDimmingFrameEndInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS LocalDimmingFrameEndInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                LocalDimmingFrameEndInfoMETA (
 const LocalDimmingModeMETA& localDimmingMode_,  const void * next_ = nullptr                  )
: Parent(StructureType::LocalDimmingFrameEndInfoMETA
, next_)
, localDimmingMode {localDimmingMode_}
        {
        }


        //! Default/empty constructor
                 LocalDimmingFrameEndInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::LocalDimmingFrameEndInfoMETA
             , next_)
, localDimmingMode{}
            {}

        //! Default copy constructor
        LocalDimmingFrameEndInfoMETA(const LocalDimmingFrameEndInfoMETA& rhs) = default;
        //! Default copy assignment
        LocalDimmingFrameEndInfoMETA& operator=(const LocalDimmingFrameEndInfoMETA& rhs) = default;
        //! Copy construct from raw
        LocalDimmingFrameEndInfoMETA(const XrLocalDimmingFrameEndInfoMETA& rhs) : LocalDimmingFrameEndInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        LocalDimmingFrameEndInfoMETA& operator=(const XrLocalDimmingFrameEndInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrLocalDimmingFrameEndInfoMETA &() const { return *reinterpret_cast<const XrLocalDimmingFrameEndInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrLocalDimmingFrameEndInfoMETA &() {
            return *reinterpret_cast<XrLocalDimmingFrameEndInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrLocalDimmingFrameEndInfoMETA
        XrLocalDimmingFrameEndInfoMETA const* get() const noexcept { return reinterpret_cast<XrLocalDimmingFrameEndInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrLocalDimmingFrameEndInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrLocalDimmingFrameEndInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = LocalDimmingFrameEndInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrLocalDimmingFrameEndInfoMETA*>(this);
        }
        LocalDimmingModeMETA localDimmingMode;
    };
     static_assert(sizeof(XrLocalDimmingFrameEndInfoMETA) == sizeof(LocalDimmingFrameEndInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrLocalDimmingFrameEndInfoMETA pointer to const from a LocalDimmingFrameEndInfoMETA reference to const.
 * @relates LocalDimmingFrameEndInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrLocalDimmingFrameEndInfoMETA const* get(LocalDimmingFrameEndInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing LocalDimmingFrameEndInfoMETA as the address of a raw XrLocalDimmingFrameEndInfoMETA
 * @relates LocalDimmingFrameEndInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrLocalDimmingFrameEndInfoMETA * put(LocalDimmingFrameEndInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_local_dimming































    #ifdef XR_META_passthrough_preferences
/*!
 * C++ projection of XrPassthroughPreferencesMETA
 * 
 * Provided by the `XR_META_passthrough_preferences` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughPreferencesMETA>
 * @xrentity{XrPassthroughPreferencesMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughPreferencesMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 PassthroughPreferencesMETA (
            void * next_ = nullptr)

: Parent(StructureType::PassthroughPreferencesMETA
             , next_)
            {}

        //! Default copy constructor
        PassthroughPreferencesMETA(const PassthroughPreferencesMETA& rhs) = default;
        //! Default copy assignment
        PassthroughPreferencesMETA& operator=(const PassthroughPreferencesMETA& rhs) = default;
        //! Copy construct from raw
        PassthroughPreferencesMETA(const XrPassthroughPreferencesMETA& rhs) : PassthroughPreferencesMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughPreferencesMETA& operator=(const XrPassthroughPreferencesMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughPreferencesMETA &() const { return *reinterpret_cast<const XrPassthroughPreferencesMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughPreferencesMETA &() {
            return *reinterpret_cast<XrPassthroughPreferencesMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughPreferencesMETA
        XrPassthroughPreferencesMETA const* get() const noexcept { return reinterpret_cast<XrPassthroughPreferencesMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughPreferencesMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughPreferencesMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughPreferencesMETA{};next = oldNext;}
            return reinterpret_cast<XrPassthroughPreferencesMETA*>(this);
        }
        PassthroughPreferenceFlagsMETA flags;
    };
     static_assert(sizeof(XrPassthroughPreferencesMETA) == sizeof(PassthroughPreferencesMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughPreferencesMETA pointer to const from a PassthroughPreferencesMETA reference to const.
 * @relates PassthroughPreferencesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughPreferencesMETA const* get(PassthroughPreferencesMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughPreferencesMETA as the address of a raw XrPassthroughPreferencesMETA
 * @relates PassthroughPreferencesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughPreferencesMETA * put(PassthroughPreferencesMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_preferences































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrSystemVirtualKeyboardPropertiesMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemVirtualKeyboardPropertiesMETA>
 * @xrentity{XrSystemVirtualKeyboardPropertiesMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemVirtualKeyboardPropertiesMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemVirtualKeyboardPropertiesMETA (
            void * next_ = nullptr)

: Parent(StructureType::SystemVirtualKeyboardPropertiesMETA
             , next_)
            {}

        //! Default copy constructor
        SystemVirtualKeyboardPropertiesMETA(const SystemVirtualKeyboardPropertiesMETA& rhs) = default;
        //! Default copy assignment
        SystemVirtualKeyboardPropertiesMETA& operator=(const SystemVirtualKeyboardPropertiesMETA& rhs) = default;
        //! Copy construct from raw
        SystemVirtualKeyboardPropertiesMETA(const XrSystemVirtualKeyboardPropertiesMETA& rhs) : SystemVirtualKeyboardPropertiesMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemVirtualKeyboardPropertiesMETA& operator=(const XrSystemVirtualKeyboardPropertiesMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemVirtualKeyboardPropertiesMETA &() const { return *reinterpret_cast<const XrSystemVirtualKeyboardPropertiesMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemVirtualKeyboardPropertiesMETA &() {
            return *reinterpret_cast<XrSystemVirtualKeyboardPropertiesMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemVirtualKeyboardPropertiesMETA
        XrSystemVirtualKeyboardPropertiesMETA const* get() const noexcept { return reinterpret_cast<XrSystemVirtualKeyboardPropertiesMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemVirtualKeyboardPropertiesMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemVirtualKeyboardPropertiesMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemVirtualKeyboardPropertiesMETA{};next = oldNext;}
            return reinterpret_cast<XrSystemVirtualKeyboardPropertiesMETA*>(this);
        }
        Bool32 supportsVirtualKeyboard;
    };
     static_assert(sizeof(XrSystemVirtualKeyboardPropertiesMETA) == sizeof(SystemVirtualKeyboardPropertiesMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemVirtualKeyboardPropertiesMETA pointer to const from a SystemVirtualKeyboardPropertiesMETA reference to const.
 * @relates SystemVirtualKeyboardPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemVirtualKeyboardPropertiesMETA const* get(SystemVirtualKeyboardPropertiesMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemVirtualKeyboardPropertiesMETA as the address of a raw XrSystemVirtualKeyboardPropertiesMETA
 * @relates SystemVirtualKeyboardPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemVirtualKeyboardPropertiesMETA * put(SystemVirtualKeyboardPropertiesMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardCreateInfoMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardCreateInfoMETA>
 * @xrentity{XrVirtualKeyboardCreateInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardCreateInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Default/empty constructor
                 VirtualKeyboardCreateInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardCreateInfoMETA
             , next_)
            {}

        //! Default copy constructor
        VirtualKeyboardCreateInfoMETA(const VirtualKeyboardCreateInfoMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardCreateInfoMETA& operator=(const VirtualKeyboardCreateInfoMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardCreateInfoMETA(const XrVirtualKeyboardCreateInfoMETA& rhs) : VirtualKeyboardCreateInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardCreateInfoMETA& operator=(const XrVirtualKeyboardCreateInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardCreateInfoMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardCreateInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardCreateInfoMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardCreateInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardCreateInfoMETA
        XrVirtualKeyboardCreateInfoMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardCreateInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardCreateInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardCreateInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardCreateInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardCreateInfoMETA*>(this);
        }
    };
     static_assert(sizeof(XrVirtualKeyboardCreateInfoMETA) == sizeof(VirtualKeyboardCreateInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardCreateInfoMETA pointer to const from a VirtualKeyboardCreateInfoMETA reference to const.
 * @relates VirtualKeyboardCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardCreateInfoMETA const* get(VirtualKeyboardCreateInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardCreateInfoMETA as the address of a raw XrVirtualKeyboardCreateInfoMETA
 * @relates VirtualKeyboardCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardCreateInfoMETA * put(VirtualKeyboardCreateInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardSpaceCreateInfoMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardSpaceCreateInfoMETA>
 * @xrentity{XrVirtualKeyboardSpaceCreateInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardSpaceCreateInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VirtualKeyboardSpaceCreateInfoMETA (
 const VirtualKeyboardLocationTypeMETA& locationType_,  const Space& space_,  const Posef& poseInSpace_,  const void * next_ = nullptr                  )
: Parent(StructureType::VirtualKeyboardSpaceCreateInfoMETA
, next_)
, locationType {locationType_}
, space {space_}
, poseInSpace {poseInSpace_}
        {
        }


        //! Default/empty constructor
                 VirtualKeyboardSpaceCreateInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardSpaceCreateInfoMETA
             , next_)
, locationType{}
, space{}
, poseInSpace{}
            {}

        //! Default copy constructor
        VirtualKeyboardSpaceCreateInfoMETA(const VirtualKeyboardSpaceCreateInfoMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardSpaceCreateInfoMETA& operator=(const VirtualKeyboardSpaceCreateInfoMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardSpaceCreateInfoMETA(const XrVirtualKeyboardSpaceCreateInfoMETA& rhs) : VirtualKeyboardSpaceCreateInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardSpaceCreateInfoMETA& operator=(const XrVirtualKeyboardSpaceCreateInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardSpaceCreateInfoMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardSpaceCreateInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardSpaceCreateInfoMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardSpaceCreateInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardSpaceCreateInfoMETA
        XrVirtualKeyboardSpaceCreateInfoMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardSpaceCreateInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardSpaceCreateInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardSpaceCreateInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardSpaceCreateInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardSpaceCreateInfoMETA*>(this);
        }
        VirtualKeyboardLocationTypeMETA locationType;
        Space space;
        Posef poseInSpace;
    };
     static_assert(sizeof(XrVirtualKeyboardSpaceCreateInfoMETA) == sizeof(VirtualKeyboardSpaceCreateInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardSpaceCreateInfoMETA pointer to const from a VirtualKeyboardSpaceCreateInfoMETA reference to const.
 * @relates VirtualKeyboardSpaceCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardSpaceCreateInfoMETA const* get(VirtualKeyboardSpaceCreateInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardSpaceCreateInfoMETA as the address of a raw XrVirtualKeyboardSpaceCreateInfoMETA
 * @relates VirtualKeyboardSpaceCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardSpaceCreateInfoMETA * put(VirtualKeyboardSpaceCreateInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardLocationInfoMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardLocationInfoMETA>
 * @xrentity{XrVirtualKeyboardLocationInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardLocationInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VirtualKeyboardLocationInfoMETA (
 const VirtualKeyboardLocationTypeMETA& locationType_,  const Space& space_,  const Posef& poseInSpace_,  float scale_,  const void * next_ = nullptr                  )
: Parent(StructureType::VirtualKeyboardLocationInfoMETA
, next_)
, locationType {locationType_}
, space {space_}
, poseInSpace {poseInSpace_}
, scale {scale_}
        {
        }


        //! Default/empty constructor
                 VirtualKeyboardLocationInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardLocationInfoMETA
             , next_)
, locationType{}
, space{}
, poseInSpace{}
, scale{0.0f}
            {}

        //! Default copy constructor
        VirtualKeyboardLocationInfoMETA(const VirtualKeyboardLocationInfoMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardLocationInfoMETA& operator=(const VirtualKeyboardLocationInfoMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardLocationInfoMETA(const XrVirtualKeyboardLocationInfoMETA& rhs) : VirtualKeyboardLocationInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardLocationInfoMETA& operator=(const XrVirtualKeyboardLocationInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardLocationInfoMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardLocationInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardLocationInfoMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardLocationInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardLocationInfoMETA
        XrVirtualKeyboardLocationInfoMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardLocationInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardLocationInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardLocationInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardLocationInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardLocationInfoMETA*>(this);
        }
        VirtualKeyboardLocationTypeMETA locationType;
        Space space;
        Posef poseInSpace;
        float scale;
    };
     static_assert(sizeof(XrVirtualKeyboardLocationInfoMETA) == sizeof(VirtualKeyboardLocationInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardLocationInfoMETA pointer to const from a VirtualKeyboardLocationInfoMETA reference to const.
 * @relates VirtualKeyboardLocationInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardLocationInfoMETA const* get(VirtualKeyboardLocationInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardLocationInfoMETA as the address of a raw XrVirtualKeyboardLocationInfoMETA
 * @relates VirtualKeyboardLocationInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardLocationInfoMETA * put(VirtualKeyboardLocationInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardModelVisibilitySetInfoMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardModelVisibilitySetInfoMETA>
 * @xrentity{XrVirtualKeyboardModelVisibilitySetInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardModelVisibilitySetInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VirtualKeyboardModelVisibilitySetInfoMETA (
 const Bool32& visible_,  const void * next_ = nullptr                  )
: Parent(StructureType::VirtualKeyboardModelVisibilitySetInfoMETA
, next_)
, visible {visible_}
        {
        }


        //! Default/empty constructor
                 VirtualKeyboardModelVisibilitySetInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardModelVisibilitySetInfoMETA
             , next_)
, visible{false}
            {}

        //! Default copy constructor
        VirtualKeyboardModelVisibilitySetInfoMETA(const VirtualKeyboardModelVisibilitySetInfoMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardModelVisibilitySetInfoMETA& operator=(const VirtualKeyboardModelVisibilitySetInfoMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardModelVisibilitySetInfoMETA(const XrVirtualKeyboardModelVisibilitySetInfoMETA& rhs) : VirtualKeyboardModelVisibilitySetInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardModelVisibilitySetInfoMETA& operator=(const XrVirtualKeyboardModelVisibilitySetInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardModelVisibilitySetInfoMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardModelVisibilitySetInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardModelVisibilitySetInfoMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardModelVisibilitySetInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardModelVisibilitySetInfoMETA
        XrVirtualKeyboardModelVisibilitySetInfoMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardModelVisibilitySetInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardModelVisibilitySetInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardModelVisibilitySetInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardModelVisibilitySetInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardModelVisibilitySetInfoMETA*>(this);
        }
        Bool32 visible;
    };
     static_assert(sizeof(XrVirtualKeyboardModelVisibilitySetInfoMETA) == sizeof(VirtualKeyboardModelVisibilitySetInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardModelVisibilitySetInfoMETA pointer to const from a VirtualKeyboardModelVisibilitySetInfoMETA reference to const.
 * @relates VirtualKeyboardModelVisibilitySetInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardModelVisibilitySetInfoMETA const* get(VirtualKeyboardModelVisibilitySetInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardModelVisibilitySetInfoMETA as the address of a raw XrVirtualKeyboardModelVisibilitySetInfoMETA
 * @relates VirtualKeyboardModelVisibilitySetInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardModelVisibilitySetInfoMETA * put(VirtualKeyboardModelVisibilitySetInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardAnimationStateMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardAnimationStateMETA>
 * @xrentity{XrVirtualKeyboardAnimationStateMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardAnimationStateMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 VirtualKeyboardAnimationStateMETA (
            void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardAnimationStateMETA
             , next_)
            {}

        //! Default copy constructor
        VirtualKeyboardAnimationStateMETA(const VirtualKeyboardAnimationStateMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardAnimationStateMETA& operator=(const VirtualKeyboardAnimationStateMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardAnimationStateMETA(const XrVirtualKeyboardAnimationStateMETA& rhs) : VirtualKeyboardAnimationStateMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardAnimationStateMETA& operator=(const XrVirtualKeyboardAnimationStateMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardAnimationStateMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardAnimationStateMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardAnimationStateMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardAnimationStateMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardAnimationStateMETA
        XrVirtualKeyboardAnimationStateMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardAnimationStateMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardAnimationStateMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardAnimationStateMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardAnimationStateMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardAnimationStateMETA*>(this);
        }
        int32_t animationIndex;
        float fraction;
    };
     static_assert(sizeof(XrVirtualKeyboardAnimationStateMETA) == sizeof(VirtualKeyboardAnimationStateMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardAnimationStateMETA pointer to const from a VirtualKeyboardAnimationStateMETA reference to const.
 * @relates VirtualKeyboardAnimationStateMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardAnimationStateMETA const* get(VirtualKeyboardAnimationStateMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardAnimationStateMETA as the address of a raw XrVirtualKeyboardAnimationStateMETA
 * @relates VirtualKeyboardAnimationStateMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardAnimationStateMETA * put(VirtualKeyboardAnimationStateMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardModelAnimationStatesMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardModelAnimationStatesMETA>
 * @xrentity{XrVirtualKeyboardModelAnimationStatesMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardModelAnimationStatesMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 VirtualKeyboardModelAnimationStatesMETA (
            void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardModelAnimationStatesMETA
             , next_)
            {}

        //! Default copy constructor
        VirtualKeyboardModelAnimationStatesMETA(const VirtualKeyboardModelAnimationStatesMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardModelAnimationStatesMETA& operator=(const VirtualKeyboardModelAnimationStatesMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardModelAnimationStatesMETA(const XrVirtualKeyboardModelAnimationStatesMETA& rhs) : VirtualKeyboardModelAnimationStatesMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardModelAnimationStatesMETA& operator=(const XrVirtualKeyboardModelAnimationStatesMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardModelAnimationStatesMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardModelAnimationStatesMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardModelAnimationStatesMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardModelAnimationStatesMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardModelAnimationStatesMETA
        XrVirtualKeyboardModelAnimationStatesMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardModelAnimationStatesMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardModelAnimationStatesMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardModelAnimationStatesMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardModelAnimationStatesMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardModelAnimationStatesMETA*>(this);
        }
        uint32_t stateCapacityInput;
        uint32_t stateCountOutput;
        VirtualKeyboardAnimationStateMETA* states;
    };
     static_assert(sizeof(XrVirtualKeyboardModelAnimationStatesMETA) == sizeof(VirtualKeyboardModelAnimationStatesMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardModelAnimationStatesMETA pointer to const from a VirtualKeyboardModelAnimationStatesMETA reference to const.
 * @relates VirtualKeyboardModelAnimationStatesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardModelAnimationStatesMETA const* get(VirtualKeyboardModelAnimationStatesMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardModelAnimationStatesMETA as the address of a raw XrVirtualKeyboardModelAnimationStatesMETA
 * @relates VirtualKeyboardModelAnimationStatesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardModelAnimationStatesMETA * put(VirtualKeyboardModelAnimationStatesMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardTextureDataMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardTextureDataMETA>
 * @xrentity{XrVirtualKeyboardTextureDataMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardTextureDataMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 VirtualKeyboardTextureDataMETA (
            void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardTextureDataMETA
             , next_)
            {}

        //! Default copy constructor
        VirtualKeyboardTextureDataMETA(const VirtualKeyboardTextureDataMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardTextureDataMETA& operator=(const VirtualKeyboardTextureDataMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardTextureDataMETA(const XrVirtualKeyboardTextureDataMETA& rhs) : VirtualKeyboardTextureDataMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardTextureDataMETA& operator=(const XrVirtualKeyboardTextureDataMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardTextureDataMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardTextureDataMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardTextureDataMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardTextureDataMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardTextureDataMETA
        XrVirtualKeyboardTextureDataMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardTextureDataMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardTextureDataMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardTextureDataMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardTextureDataMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardTextureDataMETA*>(this);
        }
        uint32_t textureWidth;
        uint32_t textureHeight;
        uint32_t bufferCapacityInput;
        uint32_t bufferCountOutput;
        uint8_t* buffer;
    };
     static_assert(sizeof(XrVirtualKeyboardTextureDataMETA) == sizeof(VirtualKeyboardTextureDataMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardTextureDataMETA pointer to const from a VirtualKeyboardTextureDataMETA reference to const.
 * @relates VirtualKeyboardTextureDataMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardTextureDataMETA const* get(VirtualKeyboardTextureDataMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardTextureDataMETA as the address of a raw XrVirtualKeyboardTextureDataMETA
 * @relates VirtualKeyboardTextureDataMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardTextureDataMETA * put(VirtualKeyboardTextureDataMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardInputInfoMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardInputInfoMETA>
 * @xrentity{XrVirtualKeyboardInputInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardInputInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VirtualKeyboardInputInfoMETA (
 const VirtualKeyboardInputSourceMETA& inputSource_,  const Space& inputSpace_,  const Posef& inputPoseInSpace_,  const VirtualKeyboardInputStateFlagsMETA& inputState_,  const void * next_ = nullptr                  )
: Parent(StructureType::VirtualKeyboardInputInfoMETA
, next_)
, inputSource {inputSource_}
, inputSpace {inputSpace_}
, inputPoseInSpace {inputPoseInSpace_}
, inputState {inputState_}
        {
        }


        //! Default/empty constructor
                 VirtualKeyboardInputInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardInputInfoMETA
             , next_)
, inputSource{}
, inputSpace{}
, inputPoseInSpace{}
, inputState{}
            {}

        //! Default copy constructor
        VirtualKeyboardInputInfoMETA(const VirtualKeyboardInputInfoMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardInputInfoMETA& operator=(const VirtualKeyboardInputInfoMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardInputInfoMETA(const XrVirtualKeyboardInputInfoMETA& rhs) : VirtualKeyboardInputInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardInputInfoMETA& operator=(const XrVirtualKeyboardInputInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardInputInfoMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardInputInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardInputInfoMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardInputInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardInputInfoMETA
        XrVirtualKeyboardInputInfoMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardInputInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardInputInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardInputInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardInputInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardInputInfoMETA*>(this);
        }
        VirtualKeyboardInputSourceMETA inputSource;
        Space inputSpace;
        Posef inputPoseInSpace;
        VirtualKeyboardInputStateFlagsMETA inputState;
    };
     static_assert(sizeof(XrVirtualKeyboardInputInfoMETA) == sizeof(VirtualKeyboardInputInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardInputInfoMETA pointer to const from a VirtualKeyboardInputInfoMETA reference to const.
 * @relates VirtualKeyboardInputInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardInputInfoMETA const* get(VirtualKeyboardInputInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardInputInfoMETA as the address of a raw XrVirtualKeyboardInputInfoMETA
 * @relates VirtualKeyboardInputInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardInputInfoMETA * put(VirtualKeyboardInputInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardTextContextChangeInfoMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardTextContextChangeInfoMETA>
 * @xrentity{XrVirtualKeyboardTextContextChangeInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VirtualKeyboardTextContextChangeInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VirtualKeyboardTextContextChangeInfoMETA (
 const char* textContext_,  const void * next_ = nullptr                  )
: Parent(StructureType::VirtualKeyboardTextContextChangeInfoMETA
, next_)
, textContext {textContext_}
        {
        }


        //! Default/empty constructor
                 VirtualKeyboardTextContextChangeInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VirtualKeyboardTextContextChangeInfoMETA
             , next_)
, textContext{nullptr}
            {}

        //! Default copy constructor
        VirtualKeyboardTextContextChangeInfoMETA(const VirtualKeyboardTextContextChangeInfoMETA& rhs) = default;
        //! Default copy assignment
        VirtualKeyboardTextContextChangeInfoMETA& operator=(const VirtualKeyboardTextContextChangeInfoMETA& rhs) = default;
        //! Copy construct from raw
        VirtualKeyboardTextContextChangeInfoMETA(const XrVirtualKeyboardTextContextChangeInfoMETA& rhs) : VirtualKeyboardTextContextChangeInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VirtualKeyboardTextContextChangeInfoMETA& operator=(const XrVirtualKeyboardTextContextChangeInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVirtualKeyboardTextContextChangeInfoMETA &() const { return *reinterpret_cast<const XrVirtualKeyboardTextContextChangeInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVirtualKeyboardTextContextChangeInfoMETA &() {
            return *reinterpret_cast<XrVirtualKeyboardTextContextChangeInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVirtualKeyboardTextContextChangeInfoMETA
        XrVirtualKeyboardTextContextChangeInfoMETA const* get() const noexcept { return reinterpret_cast<XrVirtualKeyboardTextContextChangeInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVirtualKeyboardTextContextChangeInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVirtualKeyboardTextContextChangeInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VirtualKeyboardTextContextChangeInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVirtualKeyboardTextContextChangeInfoMETA*>(this);
        }
        const char* textContext;
    };
     static_assert(sizeof(XrVirtualKeyboardTextContextChangeInfoMETA) == sizeof(VirtualKeyboardTextContextChangeInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardTextContextChangeInfoMETA pointer to const from a VirtualKeyboardTextContextChangeInfoMETA reference to const.
 * @relates VirtualKeyboardTextContextChangeInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardTextContextChangeInfoMETA const* get(VirtualKeyboardTextContextChangeInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardTextContextChangeInfoMETA as the address of a raw XrVirtualKeyboardTextContextChangeInfoMETA
 * @relates VirtualKeyboardTextContextChangeInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVirtualKeyboardTextContextChangeInfoMETA * put(VirtualKeyboardTextContextChangeInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardCommitTextMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardCommitTextMETA>
 * @xrentity{XrEventDataVirtualKeyboardCommitTextMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataVirtualKeyboardCommitTextMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataVirtualKeyboardCommitTextMETA (
            void * next_ = nullptr)

: Parent(StructureType::EventDataVirtualKeyboardCommitTextMETA
             , next_)
            {}

        //! Default copy constructor
        EventDataVirtualKeyboardCommitTextMETA(const EventDataVirtualKeyboardCommitTextMETA& rhs) = default;
        //! Default copy assignment
        EventDataVirtualKeyboardCommitTextMETA& operator=(const EventDataVirtualKeyboardCommitTextMETA& rhs) = default;
        //! Copy construct from raw
        EventDataVirtualKeyboardCommitTextMETA(const XrEventDataVirtualKeyboardCommitTextMETA& rhs) : EventDataVirtualKeyboardCommitTextMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataVirtualKeyboardCommitTextMETA& operator=(const XrEventDataVirtualKeyboardCommitTextMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataVirtualKeyboardCommitTextMETA &() const { return *reinterpret_cast<const XrEventDataVirtualKeyboardCommitTextMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataVirtualKeyboardCommitTextMETA &() {
            return *reinterpret_cast<XrEventDataVirtualKeyboardCommitTextMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardCommitTextMETA
        XrEventDataVirtualKeyboardCommitTextMETA const* get() const noexcept { return reinterpret_cast<XrEventDataVirtualKeyboardCommitTextMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataVirtualKeyboardCommitTextMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataVirtualKeyboardCommitTextMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataVirtualKeyboardCommitTextMETA{};next = oldNext;}
            return reinterpret_cast<XrEventDataVirtualKeyboardCommitTextMETA*>(this);
        }
        VirtualKeyboardMETA keyboard;
        char text[XR_MAX_VIRTUAL_KEYBOARD_COMMIT_TEXT_SIZE_META];
    };
     static_assert(sizeof(XrEventDataVirtualKeyboardCommitTextMETA) == sizeof(EventDataVirtualKeyboardCommitTextMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardCommitTextMETA pointer to const from a EventDataVirtualKeyboardCommitTextMETA reference to const.
 * @relates EventDataVirtualKeyboardCommitTextMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardCommitTextMETA const* get(EventDataVirtualKeyboardCommitTextMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataVirtualKeyboardCommitTextMETA as the address of a raw XrEventDataVirtualKeyboardCommitTextMETA
 * @relates EventDataVirtualKeyboardCommitTextMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardCommitTextMETA * put(EventDataVirtualKeyboardCommitTextMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardBackspaceMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardBackspaceMETA>
 * @xrentity{XrEventDataVirtualKeyboardBackspaceMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataVirtualKeyboardBackspaceMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataVirtualKeyboardBackspaceMETA (
            void * next_ = nullptr)

: Parent(StructureType::EventDataVirtualKeyboardBackspaceMETA
             , next_)
            {}

        //! Default copy constructor
        EventDataVirtualKeyboardBackspaceMETA(const EventDataVirtualKeyboardBackspaceMETA& rhs) = default;
        //! Default copy assignment
        EventDataVirtualKeyboardBackspaceMETA& operator=(const EventDataVirtualKeyboardBackspaceMETA& rhs) = default;
        //! Copy construct from raw
        EventDataVirtualKeyboardBackspaceMETA(const XrEventDataVirtualKeyboardBackspaceMETA& rhs) : EventDataVirtualKeyboardBackspaceMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataVirtualKeyboardBackspaceMETA& operator=(const XrEventDataVirtualKeyboardBackspaceMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataVirtualKeyboardBackspaceMETA &() const { return *reinterpret_cast<const XrEventDataVirtualKeyboardBackspaceMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataVirtualKeyboardBackspaceMETA &() {
            return *reinterpret_cast<XrEventDataVirtualKeyboardBackspaceMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardBackspaceMETA
        XrEventDataVirtualKeyboardBackspaceMETA const* get() const noexcept { return reinterpret_cast<XrEventDataVirtualKeyboardBackspaceMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataVirtualKeyboardBackspaceMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataVirtualKeyboardBackspaceMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataVirtualKeyboardBackspaceMETA{};next = oldNext;}
            return reinterpret_cast<XrEventDataVirtualKeyboardBackspaceMETA*>(this);
        }
        VirtualKeyboardMETA keyboard;
    };
     static_assert(sizeof(XrEventDataVirtualKeyboardBackspaceMETA) == sizeof(EventDataVirtualKeyboardBackspaceMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardBackspaceMETA pointer to const from a EventDataVirtualKeyboardBackspaceMETA reference to const.
 * @relates EventDataVirtualKeyboardBackspaceMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardBackspaceMETA const* get(EventDataVirtualKeyboardBackspaceMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataVirtualKeyboardBackspaceMETA as the address of a raw XrEventDataVirtualKeyboardBackspaceMETA
 * @relates EventDataVirtualKeyboardBackspaceMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardBackspaceMETA * put(EventDataVirtualKeyboardBackspaceMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardEnterMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardEnterMETA>
 * @xrentity{XrEventDataVirtualKeyboardEnterMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataVirtualKeyboardEnterMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataVirtualKeyboardEnterMETA (
            void * next_ = nullptr)

: Parent(StructureType::EventDataVirtualKeyboardEnterMETA
             , next_)
            {}

        //! Default copy constructor
        EventDataVirtualKeyboardEnterMETA(const EventDataVirtualKeyboardEnterMETA& rhs) = default;
        //! Default copy assignment
        EventDataVirtualKeyboardEnterMETA& operator=(const EventDataVirtualKeyboardEnterMETA& rhs) = default;
        //! Copy construct from raw
        EventDataVirtualKeyboardEnterMETA(const XrEventDataVirtualKeyboardEnterMETA& rhs) : EventDataVirtualKeyboardEnterMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataVirtualKeyboardEnterMETA& operator=(const XrEventDataVirtualKeyboardEnterMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataVirtualKeyboardEnterMETA &() const { return *reinterpret_cast<const XrEventDataVirtualKeyboardEnterMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataVirtualKeyboardEnterMETA &() {
            return *reinterpret_cast<XrEventDataVirtualKeyboardEnterMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardEnterMETA
        XrEventDataVirtualKeyboardEnterMETA const* get() const noexcept { return reinterpret_cast<XrEventDataVirtualKeyboardEnterMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataVirtualKeyboardEnterMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataVirtualKeyboardEnterMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataVirtualKeyboardEnterMETA{};next = oldNext;}
            return reinterpret_cast<XrEventDataVirtualKeyboardEnterMETA*>(this);
        }
        VirtualKeyboardMETA keyboard;
    };
     static_assert(sizeof(XrEventDataVirtualKeyboardEnterMETA) == sizeof(EventDataVirtualKeyboardEnterMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardEnterMETA pointer to const from a EventDataVirtualKeyboardEnterMETA reference to const.
 * @relates EventDataVirtualKeyboardEnterMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardEnterMETA const* get(EventDataVirtualKeyboardEnterMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataVirtualKeyboardEnterMETA as the address of a raw XrEventDataVirtualKeyboardEnterMETA
 * @relates EventDataVirtualKeyboardEnterMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardEnterMETA * put(EventDataVirtualKeyboardEnterMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardShownMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardShownMETA>
 * @xrentity{XrEventDataVirtualKeyboardShownMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataVirtualKeyboardShownMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataVirtualKeyboardShownMETA (
            void * next_ = nullptr)

: Parent(StructureType::EventDataVirtualKeyboardShownMETA
             , next_)
            {}

        //! Default copy constructor
        EventDataVirtualKeyboardShownMETA(const EventDataVirtualKeyboardShownMETA& rhs) = default;
        //! Default copy assignment
        EventDataVirtualKeyboardShownMETA& operator=(const EventDataVirtualKeyboardShownMETA& rhs) = default;
        //! Copy construct from raw
        EventDataVirtualKeyboardShownMETA(const XrEventDataVirtualKeyboardShownMETA& rhs) : EventDataVirtualKeyboardShownMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataVirtualKeyboardShownMETA& operator=(const XrEventDataVirtualKeyboardShownMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataVirtualKeyboardShownMETA &() const { return *reinterpret_cast<const XrEventDataVirtualKeyboardShownMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataVirtualKeyboardShownMETA &() {
            return *reinterpret_cast<XrEventDataVirtualKeyboardShownMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardShownMETA
        XrEventDataVirtualKeyboardShownMETA const* get() const noexcept { return reinterpret_cast<XrEventDataVirtualKeyboardShownMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataVirtualKeyboardShownMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataVirtualKeyboardShownMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataVirtualKeyboardShownMETA{};next = oldNext;}
            return reinterpret_cast<XrEventDataVirtualKeyboardShownMETA*>(this);
        }
        VirtualKeyboardMETA keyboard;
    };
     static_assert(sizeof(XrEventDataVirtualKeyboardShownMETA) == sizeof(EventDataVirtualKeyboardShownMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardShownMETA pointer to const from a EventDataVirtualKeyboardShownMETA reference to const.
 * @relates EventDataVirtualKeyboardShownMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardShownMETA const* get(EventDataVirtualKeyboardShownMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataVirtualKeyboardShownMETA as the address of a raw XrEventDataVirtualKeyboardShownMETA
 * @relates EventDataVirtualKeyboardShownMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardShownMETA * put(EventDataVirtualKeyboardShownMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardHiddenMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardHiddenMETA>
 * @xrentity{XrEventDataVirtualKeyboardHiddenMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataVirtualKeyboardHiddenMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataVirtualKeyboardHiddenMETA (
            void * next_ = nullptr)

: Parent(StructureType::EventDataVirtualKeyboardHiddenMETA
             , next_)
            {}

        //! Default copy constructor
        EventDataVirtualKeyboardHiddenMETA(const EventDataVirtualKeyboardHiddenMETA& rhs) = default;
        //! Default copy assignment
        EventDataVirtualKeyboardHiddenMETA& operator=(const EventDataVirtualKeyboardHiddenMETA& rhs) = default;
        //! Copy construct from raw
        EventDataVirtualKeyboardHiddenMETA(const XrEventDataVirtualKeyboardHiddenMETA& rhs) : EventDataVirtualKeyboardHiddenMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataVirtualKeyboardHiddenMETA& operator=(const XrEventDataVirtualKeyboardHiddenMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataVirtualKeyboardHiddenMETA &() const { return *reinterpret_cast<const XrEventDataVirtualKeyboardHiddenMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataVirtualKeyboardHiddenMETA &() {
            return *reinterpret_cast<XrEventDataVirtualKeyboardHiddenMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardHiddenMETA
        XrEventDataVirtualKeyboardHiddenMETA const* get() const noexcept { return reinterpret_cast<XrEventDataVirtualKeyboardHiddenMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataVirtualKeyboardHiddenMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataVirtualKeyboardHiddenMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataVirtualKeyboardHiddenMETA{};next = oldNext;}
            return reinterpret_cast<XrEventDataVirtualKeyboardHiddenMETA*>(this);
        }
        VirtualKeyboardMETA keyboard;
    };
     static_assert(sizeof(XrEventDataVirtualKeyboardHiddenMETA) == sizeof(EventDataVirtualKeyboardHiddenMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardHiddenMETA pointer to const from a EventDataVirtualKeyboardHiddenMETA reference to const.
 * @relates EventDataVirtualKeyboardHiddenMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardHiddenMETA const* get(EventDataVirtualKeyboardHiddenMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataVirtualKeyboardHiddenMETA as the address of a raw XrEventDataVirtualKeyboardHiddenMETA
 * @relates EventDataVirtualKeyboardHiddenMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardHiddenMETA * put(EventDataVirtualKeyboardHiddenMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_virtual_keyboard































    #ifdef XR_OCULUS_external_camera
/*!
 * C++ projection of XrExternalCameraIntrinsicsOCULUS
 * 
 * Provided by the `XR_OCULUS_external_camera` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraIntrinsicsOCULUS>
 * @xrentity{XrExternalCameraIntrinsicsOCULUS}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ExternalCameraIntrinsicsOCULUS 
    {
    public:
        //! Constructor initializing all members.
                ExternalCameraIntrinsicsOCULUS (
 const Time& lastChangeTime_,  const Fovf& fov_,  float virtualNearPlaneDistance_,  float virtualFarPlaneDistance_,  const Extent2Di& imageSensorPixelResolution_                  )
: lastChangeTime {lastChangeTime_}
, fov {fov_}
, virtualNearPlaneDistance {virtualNearPlaneDistance_}
, virtualFarPlaneDistance {virtualFarPlaneDistance_}
, imageSensorPixelResolution {imageSensorPixelResolution_}
        {
        }


        //! Default/empty constructor
                 ExternalCameraIntrinsicsOCULUS (
            )

: lastChangeTime{}
, fov{}
, virtualNearPlaneDistance{0.0f}
, virtualFarPlaneDistance{0.0f}
, imageSensorPixelResolution{}
            {}

        //! Default copy constructor
        ExternalCameraIntrinsicsOCULUS(const ExternalCameraIntrinsicsOCULUS& rhs) = default;
        //! Default copy assignment
        ExternalCameraIntrinsicsOCULUS& operator=(const ExternalCameraIntrinsicsOCULUS& rhs) = default;
        //! Copy construct from raw
        ExternalCameraIntrinsicsOCULUS(const XrExternalCameraIntrinsicsOCULUS& rhs) : ExternalCameraIntrinsicsOCULUS() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ExternalCameraIntrinsicsOCULUS& operator=(const XrExternalCameraIntrinsicsOCULUS& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExternalCameraIntrinsicsOCULUS &() const { return *reinterpret_cast<const XrExternalCameraIntrinsicsOCULUS*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExternalCameraIntrinsicsOCULUS &() {
            return *reinterpret_cast<XrExternalCameraIntrinsicsOCULUS*>(this);
        }

        //! Accessor for this as the address of a raw XrExternalCameraIntrinsicsOCULUS
        XrExternalCameraIntrinsicsOCULUS const* get() const noexcept { return reinterpret_cast<XrExternalCameraIntrinsicsOCULUS const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExternalCameraIntrinsicsOCULUS.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrExternalCameraIntrinsicsOCULUS * put(bool clear = true) noexcept {
            if (clear) {*this = ExternalCameraIntrinsicsOCULUS{};}
            return reinterpret_cast<XrExternalCameraIntrinsicsOCULUS*>(this);
        }
        Time lastChangeTime;
        Fovf fov;
        float virtualNearPlaneDistance;
        float virtualFarPlaneDistance;
        Extent2Di imageSensorPixelResolution;
    };
     static_assert(sizeof(XrExternalCameraIntrinsicsOCULUS) == sizeof(ExternalCameraIntrinsicsOCULUS), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExternalCameraIntrinsicsOCULUS pointer to const from a ExternalCameraIntrinsicsOCULUS reference to const.
 * @relates ExternalCameraIntrinsicsOCULUS
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExternalCameraIntrinsicsOCULUS const* get(ExternalCameraIntrinsicsOCULUS const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ExternalCameraIntrinsicsOCULUS as the address of a raw XrExternalCameraIntrinsicsOCULUS
 * @relates ExternalCameraIntrinsicsOCULUS
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExternalCameraIntrinsicsOCULUS * put(ExternalCameraIntrinsicsOCULUS &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_OCULUS_external_camera































    #ifdef XR_OCULUS_external_camera
/*!
 * C++ projection of XrExternalCameraExtrinsicsOCULUS
 * 
 * Provided by the `XR_OCULUS_external_camera` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraExtrinsicsOCULUS>
 * @xrentity{XrExternalCameraExtrinsicsOCULUS}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ExternalCameraExtrinsicsOCULUS 
    {
    public:
        //! Constructor initializing all members.
                ExternalCameraExtrinsicsOCULUS (
 const Time& lastChangeTime_,  const ExternalCameraStatusFlagsOCULUS& cameraStatusFlags_,  const ExternalCameraAttachedToDeviceOCULUS& attachedToDevice_,  const Posef& relativePose_                  )
: lastChangeTime {lastChangeTime_}
, cameraStatusFlags {cameraStatusFlags_}
, attachedToDevice {attachedToDevice_}
, relativePose {relativePose_}
        {
        }


        //! Default/empty constructor
                 ExternalCameraExtrinsicsOCULUS (
            )

: lastChangeTime{}
, cameraStatusFlags{}
, attachedToDevice{}
, relativePose{}
            {}

        //! Default copy constructor
        ExternalCameraExtrinsicsOCULUS(const ExternalCameraExtrinsicsOCULUS& rhs) = default;
        //! Default copy assignment
        ExternalCameraExtrinsicsOCULUS& operator=(const ExternalCameraExtrinsicsOCULUS& rhs) = default;
        //! Copy construct from raw
        ExternalCameraExtrinsicsOCULUS(const XrExternalCameraExtrinsicsOCULUS& rhs) : ExternalCameraExtrinsicsOCULUS() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ExternalCameraExtrinsicsOCULUS& operator=(const XrExternalCameraExtrinsicsOCULUS& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExternalCameraExtrinsicsOCULUS &() const { return *reinterpret_cast<const XrExternalCameraExtrinsicsOCULUS*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExternalCameraExtrinsicsOCULUS &() {
            return *reinterpret_cast<XrExternalCameraExtrinsicsOCULUS*>(this);
        }

        //! Accessor for this as the address of a raw XrExternalCameraExtrinsicsOCULUS
        XrExternalCameraExtrinsicsOCULUS const* get() const noexcept { return reinterpret_cast<XrExternalCameraExtrinsicsOCULUS const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExternalCameraExtrinsicsOCULUS.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrExternalCameraExtrinsicsOCULUS * put(bool clear = true) noexcept {
            if (clear) {*this = ExternalCameraExtrinsicsOCULUS{};}
            return reinterpret_cast<XrExternalCameraExtrinsicsOCULUS*>(this);
        }
        Time lastChangeTime;
        ExternalCameraStatusFlagsOCULUS cameraStatusFlags;
        ExternalCameraAttachedToDeviceOCULUS attachedToDevice;
        Posef relativePose;
    };
     static_assert(sizeof(XrExternalCameraExtrinsicsOCULUS) == sizeof(ExternalCameraExtrinsicsOCULUS), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExternalCameraExtrinsicsOCULUS pointer to const from a ExternalCameraExtrinsicsOCULUS reference to const.
 * @relates ExternalCameraExtrinsicsOCULUS
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExternalCameraExtrinsicsOCULUS const* get(ExternalCameraExtrinsicsOCULUS const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ExternalCameraExtrinsicsOCULUS as the address of a raw XrExternalCameraExtrinsicsOCULUS
 * @relates ExternalCameraExtrinsicsOCULUS
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExternalCameraExtrinsicsOCULUS * put(ExternalCameraExtrinsicsOCULUS &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_OCULUS_external_camera































    #ifdef XR_OCULUS_external_camera
/*!
 * C++ projection of XrExternalCameraOCULUS
 * 
 * Provided by the `XR_OCULUS_external_camera` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraOCULUS>
 * @xrentity{XrExternalCameraOCULUS}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ExternalCameraOCULUS : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 ExternalCameraOCULUS (
            void * next_ = nullptr)

: Parent(StructureType::ExternalCameraOCULUS
             , next_)
            {}

        //! Default copy constructor
        ExternalCameraOCULUS(const ExternalCameraOCULUS& rhs) = default;
        //! Default copy assignment
        ExternalCameraOCULUS& operator=(const ExternalCameraOCULUS& rhs) = default;
        //! Copy construct from raw
        ExternalCameraOCULUS(const XrExternalCameraOCULUS& rhs) : ExternalCameraOCULUS() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ExternalCameraOCULUS& operator=(const XrExternalCameraOCULUS& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExternalCameraOCULUS &() const { return *reinterpret_cast<const XrExternalCameraOCULUS*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExternalCameraOCULUS &() {
            return *reinterpret_cast<XrExternalCameraOCULUS*>(this);
        }

        //! Accessor for this as the address of a raw XrExternalCameraOCULUS
        XrExternalCameraOCULUS const* get() const noexcept { return reinterpret_cast<XrExternalCameraOCULUS const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExternalCameraOCULUS.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrExternalCameraOCULUS * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ExternalCameraOCULUS{};next = oldNext;}
            return reinterpret_cast<XrExternalCameraOCULUS*>(this);
        }
        char name[XR_MAX_EXTERNAL_CAMERA_NAME_SIZE_OCULUS];
        ExternalCameraIntrinsicsOCULUS intrinsics;
        ExternalCameraExtrinsicsOCULUS extrinsics;
    };
     static_assert(sizeof(XrExternalCameraOCULUS) == sizeof(ExternalCameraOCULUS), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExternalCameraOCULUS pointer to const from a ExternalCameraOCULUS reference to const.
 * @relates ExternalCameraOCULUS
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExternalCameraOCULUS const* get(ExternalCameraOCULUS const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ExternalCameraOCULUS as the address of a raw XrExternalCameraOCULUS
 * @relates ExternalCameraOCULUS
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExternalCameraOCULUS * put(ExternalCameraOCULUS &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_OCULUS_external_camera































    #ifdef XR_META_vulkan_swapchain_create_info
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanSwapchainCreateInfoMETA
 * 
 * Provided by the `XR_META_vulkan_swapchain_create_info` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanSwapchainCreateInfoMETA>
 * @xrentity{XrVulkanSwapchainCreateInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS VulkanSwapchainCreateInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                VulkanSwapchainCreateInfoMETA (
 VkImageCreateFlags additionalCreateFlags_,  VkImageUsageFlags additionalUsageFlags_,  const void * next_ = nullptr                  )
: Parent(StructureType::VulkanSwapchainCreateInfoMETA
, next_)
, additionalCreateFlags {additionalCreateFlags_}
, additionalUsageFlags {additionalUsageFlags_}
        {
        }


        //! Default/empty constructor
                 VulkanSwapchainCreateInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::VulkanSwapchainCreateInfoMETA
             , next_)
, additionalCreateFlags{}
, additionalUsageFlags{}
            {}

        //! Default copy constructor
        VulkanSwapchainCreateInfoMETA(const VulkanSwapchainCreateInfoMETA& rhs) = default;
        //! Default copy assignment
        VulkanSwapchainCreateInfoMETA& operator=(const VulkanSwapchainCreateInfoMETA& rhs) = default;
        //! Copy construct from raw
        VulkanSwapchainCreateInfoMETA(const XrVulkanSwapchainCreateInfoMETA& rhs) : VulkanSwapchainCreateInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        VulkanSwapchainCreateInfoMETA& operator=(const XrVulkanSwapchainCreateInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrVulkanSwapchainCreateInfoMETA &() const { return *reinterpret_cast<const XrVulkanSwapchainCreateInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrVulkanSwapchainCreateInfoMETA &() {
            return *reinterpret_cast<XrVulkanSwapchainCreateInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrVulkanSwapchainCreateInfoMETA
        XrVulkanSwapchainCreateInfoMETA const* get() const noexcept { return reinterpret_cast<XrVulkanSwapchainCreateInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrVulkanSwapchainCreateInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrVulkanSwapchainCreateInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = VulkanSwapchainCreateInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrVulkanSwapchainCreateInfoMETA*>(this);
        }
        VkImageCreateFlags additionalCreateFlags;
        VkImageUsageFlags additionalUsageFlags;
    };
     static_assert(sizeof(XrVulkanSwapchainCreateInfoMETA) == sizeof(VulkanSwapchainCreateInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrVulkanSwapchainCreateInfoMETA pointer to const from a VulkanSwapchainCreateInfoMETA reference to const.
 * @relates VulkanSwapchainCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanSwapchainCreateInfoMETA const* get(VulkanSwapchainCreateInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanSwapchainCreateInfoMETA as the address of a raw XrVulkanSwapchainCreateInfoMETA
 * @relates VulkanSwapchainCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrVulkanSwapchainCreateInfoMETA * put(VulkanSwapchainCreateInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_META_vulkan_swapchain_create_info































    #ifdef XR_META_performance_metrics
/*!
 * C++ projection of XrPerformanceMetricsStateMETA
 * 
 * Provided by the `XR_META_performance_metrics` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerformanceMetricsStateMETA>
 * @xrentity{XrPerformanceMetricsStateMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PerformanceMetricsStateMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PerformanceMetricsStateMETA (
 const Bool32& enabled_,  const void * next_ = nullptr                  )
: Parent(StructureType::PerformanceMetricsStateMETA
, next_)
, enabled {enabled_}
        {
        }


        //! Default/empty constructor
                 PerformanceMetricsStateMETA (
            const void * next_ = nullptr)

: Parent(StructureType::PerformanceMetricsStateMETA
             , next_)
, enabled{false}
            {}

        //! Default copy constructor
        PerformanceMetricsStateMETA(const PerformanceMetricsStateMETA& rhs) = default;
        //! Default copy assignment
        PerformanceMetricsStateMETA& operator=(const PerformanceMetricsStateMETA& rhs) = default;
        //! Copy construct from raw
        PerformanceMetricsStateMETA(const XrPerformanceMetricsStateMETA& rhs) : PerformanceMetricsStateMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PerformanceMetricsStateMETA& operator=(const XrPerformanceMetricsStateMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPerformanceMetricsStateMETA &() const { return *reinterpret_cast<const XrPerformanceMetricsStateMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPerformanceMetricsStateMETA &() {
            return *reinterpret_cast<XrPerformanceMetricsStateMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPerformanceMetricsStateMETA
        XrPerformanceMetricsStateMETA const* get() const noexcept { return reinterpret_cast<XrPerformanceMetricsStateMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPerformanceMetricsStateMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPerformanceMetricsStateMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PerformanceMetricsStateMETA{};next = oldNext;}
            return reinterpret_cast<XrPerformanceMetricsStateMETA*>(this);
        }
        Bool32 enabled;
    };
     static_assert(sizeof(XrPerformanceMetricsStateMETA) == sizeof(PerformanceMetricsStateMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPerformanceMetricsStateMETA pointer to const from a PerformanceMetricsStateMETA reference to const.
 * @relates PerformanceMetricsStateMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPerformanceMetricsStateMETA const* get(PerformanceMetricsStateMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PerformanceMetricsStateMETA as the address of a raw XrPerformanceMetricsStateMETA
 * @relates PerformanceMetricsStateMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPerformanceMetricsStateMETA * put(PerformanceMetricsStateMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_performance_metrics































    #ifdef XR_META_performance_metrics
/*!
 * C++ projection of XrPerformanceMetricsCounterMETA
 * 
 * Provided by the `XR_META_performance_metrics` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerformanceMetricsCounterMETA>
 * @xrentity{XrPerformanceMetricsCounterMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PerformanceMetricsCounterMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PerformanceMetricsCounterMETA (
 const PerformanceMetricsCounterFlagsMETA& counterFlags_,  const PerformanceMetricsCounterUnitMETA& counterUnit_,  uint32_t uintValue_,  float floatValue_,  const void * next_ = nullptr                  )
: Parent(StructureType::PerformanceMetricsCounterMETA
, next_)
, counterFlags {counterFlags_}
, counterUnit {counterUnit_}
, uintValue {uintValue_}
, floatValue {floatValue_}
        {
        }


        //! Default/empty constructor
                 PerformanceMetricsCounterMETA (
            const void * next_ = nullptr)

: Parent(StructureType::PerformanceMetricsCounterMETA
             , next_)
, counterFlags{}
, counterUnit{}
, uintValue{0}
, floatValue{0.0f}
            {}

        //! Default copy constructor
        PerformanceMetricsCounterMETA(const PerformanceMetricsCounterMETA& rhs) = default;
        //! Default copy assignment
        PerformanceMetricsCounterMETA& operator=(const PerformanceMetricsCounterMETA& rhs) = default;
        //! Copy construct from raw
        PerformanceMetricsCounterMETA(const XrPerformanceMetricsCounterMETA& rhs) : PerformanceMetricsCounterMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PerformanceMetricsCounterMETA& operator=(const XrPerformanceMetricsCounterMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPerformanceMetricsCounterMETA &() const { return *reinterpret_cast<const XrPerformanceMetricsCounterMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPerformanceMetricsCounterMETA &() {
            return *reinterpret_cast<XrPerformanceMetricsCounterMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPerformanceMetricsCounterMETA
        XrPerformanceMetricsCounterMETA const* get() const noexcept { return reinterpret_cast<XrPerformanceMetricsCounterMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPerformanceMetricsCounterMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPerformanceMetricsCounterMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PerformanceMetricsCounterMETA{};next = oldNext;}
            return reinterpret_cast<XrPerformanceMetricsCounterMETA*>(this);
        }
        PerformanceMetricsCounterFlagsMETA counterFlags;
        PerformanceMetricsCounterUnitMETA counterUnit;
        uint32_t uintValue;
        float floatValue;
    };
     static_assert(sizeof(XrPerformanceMetricsCounterMETA) == sizeof(PerformanceMetricsCounterMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPerformanceMetricsCounterMETA pointer to const from a PerformanceMetricsCounterMETA reference to const.
 * @relates PerformanceMetricsCounterMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPerformanceMetricsCounterMETA const* get(PerformanceMetricsCounterMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PerformanceMetricsCounterMETA as the address of a raw XrPerformanceMetricsCounterMETA
 * @relates PerformanceMetricsCounterMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPerformanceMetricsCounterMETA * put(PerformanceMetricsCounterMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_performance_metrics































    #ifdef XR_FB_spatial_entity_storage_batch
/*!
 * C++ projection of XrSpaceListSaveInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage_batch` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceListSaveInfoFB>
 * @xrentity{XrSpaceListSaveInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceListSaveInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceListSaveInfoFB (
 uint32_t spaceCount_,  Space* spaces_,  const SpaceStorageLocationFB& location_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceListSaveInfoFB
, next_)
, spaceCount {spaceCount_}
, spaces {spaces_}
, location {location_}
        {
        }


        //! Default/empty constructor
                 SpaceListSaveInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceListSaveInfoFB
             , next_)
, spaceCount{0}
, spaces{nullptr}
, location{}
            {}

        //! Default copy constructor
        SpaceListSaveInfoFB(const SpaceListSaveInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceListSaveInfoFB& operator=(const SpaceListSaveInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceListSaveInfoFB(const XrSpaceListSaveInfoFB& rhs) : SpaceListSaveInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceListSaveInfoFB& operator=(const XrSpaceListSaveInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceListSaveInfoFB &() const { return *reinterpret_cast<const XrSpaceListSaveInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceListSaveInfoFB &() {
            return *reinterpret_cast<XrSpaceListSaveInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceListSaveInfoFB
        XrSpaceListSaveInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceListSaveInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceListSaveInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceListSaveInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceListSaveInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceListSaveInfoFB*>(this);
        }
        uint32_t spaceCount;
        Space* spaces;
        SpaceStorageLocationFB location;
    };
     static_assert(sizeof(XrSpaceListSaveInfoFB) == sizeof(SpaceListSaveInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceListSaveInfoFB pointer to const from a SpaceListSaveInfoFB reference to const.
 * @relates SpaceListSaveInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceListSaveInfoFB const* get(SpaceListSaveInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceListSaveInfoFB as the address of a raw XrSpaceListSaveInfoFB
 * @relates SpaceListSaveInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceListSaveInfoFB * put(SpaceListSaveInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_storage_batch































    #ifdef XR_FB_spatial_entity_storage_batch
/*!
 * C++ projection of XrEventDataSpaceListSaveCompleteFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage_batch` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceListSaveCompleteFB>
 * @xrentity{XrEventDataSpaceListSaveCompleteFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataSpaceListSaveCompleteFB : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataSpaceListSaveCompleteFB (
            void * next_ = nullptr)

: Parent(StructureType::EventDataSpaceListSaveCompleteFB
             , next_)
            {}

        //! Default copy constructor
        EventDataSpaceListSaveCompleteFB(const EventDataSpaceListSaveCompleteFB& rhs) = default;
        //! Default copy assignment
        EventDataSpaceListSaveCompleteFB& operator=(const EventDataSpaceListSaveCompleteFB& rhs) = default;
        //! Copy construct from raw
        EventDataSpaceListSaveCompleteFB(const XrEventDataSpaceListSaveCompleteFB& rhs) : EventDataSpaceListSaveCompleteFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataSpaceListSaveCompleteFB& operator=(const XrEventDataSpaceListSaveCompleteFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataSpaceListSaveCompleteFB &() const { return *reinterpret_cast<const XrEventDataSpaceListSaveCompleteFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataSpaceListSaveCompleteFB &() {
            return *reinterpret_cast<XrEventDataSpaceListSaveCompleteFB*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataSpaceListSaveCompleteFB
        XrEventDataSpaceListSaveCompleteFB const* get() const noexcept { return reinterpret_cast<XrEventDataSpaceListSaveCompleteFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataSpaceListSaveCompleteFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataSpaceListSaveCompleteFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataSpaceListSaveCompleteFB{};next = oldNext;}
            return reinterpret_cast<XrEventDataSpaceListSaveCompleteFB*>(this);
        }
        AsyncRequestIdFB requestId;
        Result result;
    };
     static_assert(sizeof(XrEventDataSpaceListSaveCompleteFB) == sizeof(EventDataSpaceListSaveCompleteFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataSpaceListSaveCompleteFB pointer to const from a EventDataSpaceListSaveCompleteFB reference to const.
 * @relates EventDataSpaceListSaveCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceListSaveCompleteFB const* get(EventDataSpaceListSaveCompleteFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceListSaveCompleteFB as the address of a raw XrEventDataSpaceListSaveCompleteFB
 * @relates EventDataSpaceListSaveCompleteFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataSpaceListSaveCompleteFB * put(EventDataSpaceListSaveCompleteFB &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceListSaveCompleteFB as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceListSaveCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataSpaceListSaveCompleteFB const& h) {
        return h.get_base();
    }
#endif  // XR_FB_spatial_entity_storage_batch































    #ifdef XR_FB_spatial_entity_user
/*!
 * C++ projection of XrSpaceUserCreateInfoFB
 * 
 * Provided by the `XR_FB_spatial_entity_user` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceUserCreateInfoFB>
 * @xrentity{XrSpaceUserCreateInfoFB}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SpaceUserCreateInfoFB : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                SpaceUserCreateInfoFB (
 const SpaceUserIdFB& userId_,  const void * next_ = nullptr                  )
: Parent(StructureType::SpaceUserCreateInfoFB
, next_)
, userId {userId_}
        {
        }


        //! Default/empty constructor
                 SpaceUserCreateInfoFB (
            const void * next_ = nullptr)

: Parent(StructureType::SpaceUserCreateInfoFB
             , next_)
, userId{}
            {}

        //! Default copy constructor
        SpaceUserCreateInfoFB(const SpaceUserCreateInfoFB& rhs) = default;
        //! Default copy assignment
        SpaceUserCreateInfoFB& operator=(const SpaceUserCreateInfoFB& rhs) = default;
        //! Copy construct from raw
        SpaceUserCreateInfoFB(const XrSpaceUserCreateInfoFB& rhs) : SpaceUserCreateInfoFB() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SpaceUserCreateInfoFB& operator=(const XrSpaceUserCreateInfoFB& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSpaceUserCreateInfoFB &() const { return *reinterpret_cast<const XrSpaceUserCreateInfoFB*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSpaceUserCreateInfoFB &() {
            return *reinterpret_cast<XrSpaceUserCreateInfoFB*>(this);
        }

        //! Accessor for this as the address of a raw XrSpaceUserCreateInfoFB
        XrSpaceUserCreateInfoFB const* get() const noexcept { return reinterpret_cast<XrSpaceUserCreateInfoFB const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSpaceUserCreateInfoFB.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSpaceUserCreateInfoFB * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SpaceUserCreateInfoFB{};next = oldNext;}
            return reinterpret_cast<XrSpaceUserCreateInfoFB*>(this);
        }
        SpaceUserIdFB userId;
    };
     static_assert(sizeof(XrSpaceUserCreateInfoFB) == sizeof(SpaceUserCreateInfoFB), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSpaceUserCreateInfoFB pointer to const from a SpaceUserCreateInfoFB reference to const.
 * @relates SpaceUserCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceUserCreateInfoFB const* get(SpaceUserCreateInfoFB const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceUserCreateInfoFB as the address of a raw XrSpaceUserCreateInfoFB
 * @relates SpaceUserCreateInfoFB
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSpaceUserCreateInfoFB * put(SpaceUserCreateInfoFB &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_FB_spatial_entity_user































    #ifdef XR_META_headset_id
/*!
 * C++ projection of XrSystemHeadsetIdPropertiesMETA
 * 
 * Provided by the `XR_META_headset_id` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHeadsetIdPropertiesMETA>
 * @xrentity{XrSystemHeadsetIdPropertiesMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemHeadsetIdPropertiesMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemHeadsetIdPropertiesMETA (
            void * next_ = nullptr)

: Parent(StructureType::SystemHeadsetIdPropertiesMETA
             , next_)
            {}

        //! Default copy constructor
        SystemHeadsetIdPropertiesMETA(const SystemHeadsetIdPropertiesMETA& rhs) = default;
        //! Default copy assignment
        SystemHeadsetIdPropertiesMETA& operator=(const SystemHeadsetIdPropertiesMETA& rhs) = default;
        //! Copy construct from raw
        SystemHeadsetIdPropertiesMETA(const XrSystemHeadsetIdPropertiesMETA& rhs) : SystemHeadsetIdPropertiesMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemHeadsetIdPropertiesMETA& operator=(const XrSystemHeadsetIdPropertiesMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemHeadsetIdPropertiesMETA &() const { return *reinterpret_cast<const XrSystemHeadsetIdPropertiesMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemHeadsetIdPropertiesMETA &() {
            return *reinterpret_cast<XrSystemHeadsetIdPropertiesMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemHeadsetIdPropertiesMETA
        XrSystemHeadsetIdPropertiesMETA const* get() const noexcept { return reinterpret_cast<XrSystemHeadsetIdPropertiesMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemHeadsetIdPropertiesMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemHeadsetIdPropertiesMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemHeadsetIdPropertiesMETA{};next = oldNext;}
            return reinterpret_cast<XrSystemHeadsetIdPropertiesMETA*>(this);
        }
        UuidEXT id;
    };
     static_assert(sizeof(XrSystemHeadsetIdPropertiesMETA) == sizeof(SystemHeadsetIdPropertiesMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemHeadsetIdPropertiesMETA pointer to const from a SystemHeadsetIdPropertiesMETA reference to const.
 * @relates SystemHeadsetIdPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemHeadsetIdPropertiesMETA const* get(SystemHeadsetIdPropertiesMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemHeadsetIdPropertiesMETA as the address of a raw XrSystemHeadsetIdPropertiesMETA
 * @relates SystemHeadsetIdPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemHeadsetIdPropertiesMETA * put(SystemHeadsetIdPropertiesMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_headset_id































    #ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorLutDataMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutDataMETA>
 * @xrentity{XrPassthroughColorLutDataMETA}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS PassthroughColorLutDataMETA 
    {
    public:
        //! Constructor initializing all members.
                PassthroughColorLutDataMETA (
 uint32_t bufferSize_,  const uint8_t* buffer_                  )
: bufferSize {bufferSize_}
, buffer {buffer_}
        {
        }


        //! Default/empty constructor
                 PassthroughColorLutDataMETA (
            )

: bufferSize{0}
, buffer{nullptr}
            {}

        //! Default copy constructor
        PassthroughColorLutDataMETA(const PassthroughColorLutDataMETA& rhs) = default;
        //! Default copy assignment
        PassthroughColorLutDataMETA& operator=(const PassthroughColorLutDataMETA& rhs) = default;
        //! Copy construct from raw
        PassthroughColorLutDataMETA(const XrPassthroughColorLutDataMETA& rhs) : PassthroughColorLutDataMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorLutDataMETA& operator=(const XrPassthroughColorLutDataMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorLutDataMETA &() const { return *reinterpret_cast<const XrPassthroughColorLutDataMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorLutDataMETA &() {
            return *reinterpret_cast<XrPassthroughColorLutDataMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorLutDataMETA
        XrPassthroughColorLutDataMETA const* get() const noexcept { return reinterpret_cast<XrPassthroughColorLutDataMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorLutDataMETA.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorLutDataMETA * put(bool clear = true) noexcept {
            if (clear) {*this = PassthroughColorLutDataMETA{};}
            return reinterpret_cast<XrPassthroughColorLutDataMETA*>(this);
        }
        uint32_t bufferSize;
        const uint8_t* buffer;
    };
     static_assert(sizeof(XrPassthroughColorLutDataMETA) == sizeof(PassthroughColorLutDataMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorLutDataMETA pointer to const from a PassthroughColorLutDataMETA reference to const.
 * @relates PassthroughColorLutDataMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorLutDataMETA const* get(PassthroughColorLutDataMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorLutDataMETA as the address of a raw XrPassthroughColorLutDataMETA
 * @relates PassthroughColorLutDataMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorLutDataMETA * put(PassthroughColorLutDataMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_color_lut































    #ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorLutCreateInfoMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutCreateInfoMETA>
 * @xrentity{XrPassthroughColorLutCreateInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughColorLutCreateInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughColorLutCreateInfoMETA (
 const PassthroughColorLutChannelsMETA& channels_,  uint32_t resolution_,  const PassthroughColorLutDataMETA& data_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughColorLutCreateInfoMETA
, next_)
, channels {channels_}
, resolution {resolution_}
, data {data_}
        {
        }


        //! Default/empty constructor
                 PassthroughColorLutCreateInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughColorLutCreateInfoMETA
             , next_)
, channels{}
, resolution{0}
, data{}
            {}

        //! Default copy constructor
        PassthroughColorLutCreateInfoMETA(const PassthroughColorLutCreateInfoMETA& rhs) = default;
        //! Default copy assignment
        PassthroughColorLutCreateInfoMETA& operator=(const PassthroughColorLutCreateInfoMETA& rhs) = default;
        //! Copy construct from raw
        PassthroughColorLutCreateInfoMETA(const XrPassthroughColorLutCreateInfoMETA& rhs) : PassthroughColorLutCreateInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorLutCreateInfoMETA& operator=(const XrPassthroughColorLutCreateInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorLutCreateInfoMETA &() const { return *reinterpret_cast<const XrPassthroughColorLutCreateInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorLutCreateInfoMETA &() {
            return *reinterpret_cast<XrPassthroughColorLutCreateInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorLutCreateInfoMETA
        XrPassthroughColorLutCreateInfoMETA const* get() const noexcept { return reinterpret_cast<XrPassthroughColorLutCreateInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorLutCreateInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorLutCreateInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughColorLutCreateInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrPassthroughColorLutCreateInfoMETA*>(this);
        }
        PassthroughColorLutChannelsMETA channels;
        uint32_t resolution;
        PassthroughColorLutDataMETA data;
    };
     static_assert(sizeof(XrPassthroughColorLutCreateInfoMETA) == sizeof(PassthroughColorLutCreateInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorLutCreateInfoMETA pointer to const from a PassthroughColorLutCreateInfoMETA reference to const.
 * @relates PassthroughColorLutCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorLutCreateInfoMETA const* get(PassthroughColorLutCreateInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorLutCreateInfoMETA as the address of a raw XrPassthroughColorLutCreateInfoMETA
 * @relates PassthroughColorLutCreateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorLutCreateInfoMETA * put(PassthroughColorLutCreateInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_color_lut































    #ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorLutUpdateInfoMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutUpdateInfoMETA>
 * @xrentity{XrPassthroughColorLutUpdateInfoMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughColorLutUpdateInfoMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughColorLutUpdateInfoMETA (
 const PassthroughColorLutDataMETA& data_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughColorLutUpdateInfoMETA
, next_)
, data {data_}
        {
        }


        //! Default/empty constructor
                 PassthroughColorLutUpdateInfoMETA (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughColorLutUpdateInfoMETA
             , next_)
, data{}
            {}

        //! Default copy constructor
        PassthroughColorLutUpdateInfoMETA(const PassthroughColorLutUpdateInfoMETA& rhs) = default;
        //! Default copy assignment
        PassthroughColorLutUpdateInfoMETA& operator=(const PassthroughColorLutUpdateInfoMETA& rhs) = default;
        //! Copy construct from raw
        PassthroughColorLutUpdateInfoMETA(const XrPassthroughColorLutUpdateInfoMETA& rhs) : PassthroughColorLutUpdateInfoMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorLutUpdateInfoMETA& operator=(const XrPassthroughColorLutUpdateInfoMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorLutUpdateInfoMETA &() const { return *reinterpret_cast<const XrPassthroughColorLutUpdateInfoMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorLutUpdateInfoMETA &() {
            return *reinterpret_cast<XrPassthroughColorLutUpdateInfoMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorLutUpdateInfoMETA
        XrPassthroughColorLutUpdateInfoMETA const* get() const noexcept { return reinterpret_cast<XrPassthroughColorLutUpdateInfoMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorLutUpdateInfoMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorLutUpdateInfoMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughColorLutUpdateInfoMETA{};next = oldNext;}
            return reinterpret_cast<XrPassthroughColorLutUpdateInfoMETA*>(this);
        }
        PassthroughColorLutDataMETA data;
    };
     static_assert(sizeof(XrPassthroughColorLutUpdateInfoMETA) == sizeof(PassthroughColorLutUpdateInfoMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorLutUpdateInfoMETA pointer to const from a PassthroughColorLutUpdateInfoMETA reference to const.
 * @relates PassthroughColorLutUpdateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorLutUpdateInfoMETA const* get(PassthroughColorLutUpdateInfoMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorLutUpdateInfoMETA as the address of a raw XrPassthroughColorLutUpdateInfoMETA
 * @relates PassthroughColorLutUpdateInfoMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorLutUpdateInfoMETA * put(PassthroughColorLutUpdateInfoMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_color_lut































    #ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorMapLutMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapLutMETA>
 * @xrentity{XrPassthroughColorMapLutMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughColorMapLutMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughColorMapLutMETA (
 const PassthroughColorLutMETA& colorLut_,  float weight_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughColorMapLutMETA
, next_)
, colorLut {colorLut_}
, weight {weight_}
        {
        }


        //! Default/empty constructor
                 PassthroughColorMapLutMETA (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughColorMapLutMETA
             , next_)
, colorLut{}
, weight{0.0f}
            {}

        //! Default copy constructor
        PassthroughColorMapLutMETA(const PassthroughColorMapLutMETA& rhs) = default;
        //! Default copy assignment
        PassthroughColorMapLutMETA& operator=(const PassthroughColorMapLutMETA& rhs) = default;
        //! Copy construct from raw
        PassthroughColorMapLutMETA(const XrPassthroughColorMapLutMETA& rhs) : PassthroughColorMapLutMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorMapLutMETA& operator=(const XrPassthroughColorMapLutMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorMapLutMETA &() const { return *reinterpret_cast<const XrPassthroughColorMapLutMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorMapLutMETA &() {
            return *reinterpret_cast<XrPassthroughColorMapLutMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorMapLutMETA
        XrPassthroughColorMapLutMETA const* get() const noexcept { return reinterpret_cast<XrPassthroughColorMapLutMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorMapLutMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorMapLutMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughColorMapLutMETA{};next = oldNext;}
            return reinterpret_cast<XrPassthroughColorMapLutMETA*>(this);
        }
        PassthroughColorLutMETA colorLut;
        float weight;
    };
     static_assert(sizeof(XrPassthroughColorMapLutMETA) == sizeof(PassthroughColorMapLutMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapLutMETA pointer to const from a PassthroughColorMapLutMETA reference to const.
 * @relates PassthroughColorMapLutMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorMapLutMETA const* get(PassthroughColorMapLutMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorMapLutMETA as the address of a raw XrPassthroughColorMapLutMETA
 * @relates PassthroughColorMapLutMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorMapLutMETA * put(PassthroughColorMapLutMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_color_lut































    #ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorMapInterpolatedLutMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapInterpolatedLutMETA>
 * @xrentity{XrPassthroughColorMapInterpolatedLutMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughColorMapInterpolatedLutMETA : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughColorMapInterpolatedLutMETA (
 const PassthroughColorLutMETA& sourceColorLut_,  const PassthroughColorLutMETA& targetColorLut_,  float weight_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughColorMapInterpolatedLutMETA
, next_)
, sourceColorLut {sourceColorLut_}
, targetColorLut {targetColorLut_}
, weight {weight_}
        {
        }


        //! Default/empty constructor
                 PassthroughColorMapInterpolatedLutMETA (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughColorMapInterpolatedLutMETA
             , next_)
, sourceColorLut{}
, targetColorLut{}
, weight{0.0f}
            {}

        //! Default copy constructor
        PassthroughColorMapInterpolatedLutMETA(const PassthroughColorMapInterpolatedLutMETA& rhs) = default;
        //! Default copy assignment
        PassthroughColorMapInterpolatedLutMETA& operator=(const PassthroughColorMapInterpolatedLutMETA& rhs) = default;
        //! Copy construct from raw
        PassthroughColorMapInterpolatedLutMETA(const XrPassthroughColorMapInterpolatedLutMETA& rhs) : PassthroughColorMapInterpolatedLutMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorMapInterpolatedLutMETA& operator=(const XrPassthroughColorMapInterpolatedLutMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorMapInterpolatedLutMETA &() const { return *reinterpret_cast<const XrPassthroughColorMapInterpolatedLutMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorMapInterpolatedLutMETA &() {
            return *reinterpret_cast<XrPassthroughColorMapInterpolatedLutMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorMapInterpolatedLutMETA
        XrPassthroughColorMapInterpolatedLutMETA const* get() const noexcept { return reinterpret_cast<XrPassthroughColorMapInterpolatedLutMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorMapInterpolatedLutMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorMapInterpolatedLutMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughColorMapInterpolatedLutMETA{};next = oldNext;}
            return reinterpret_cast<XrPassthroughColorMapInterpolatedLutMETA*>(this);
        }
        PassthroughColorLutMETA sourceColorLut;
        PassthroughColorLutMETA targetColorLut;
        float weight;
    };
     static_assert(sizeof(XrPassthroughColorMapInterpolatedLutMETA) == sizeof(PassthroughColorMapInterpolatedLutMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapInterpolatedLutMETA pointer to const from a PassthroughColorMapInterpolatedLutMETA reference to const.
 * @relates PassthroughColorMapInterpolatedLutMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorMapInterpolatedLutMETA const* get(PassthroughColorMapInterpolatedLutMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorMapInterpolatedLutMETA as the address of a raw XrPassthroughColorMapInterpolatedLutMETA
 * @relates PassthroughColorMapInterpolatedLutMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorMapInterpolatedLutMETA * put(PassthroughColorMapInterpolatedLutMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_color_lut































    #ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrSystemPassthroughColorLutPropertiesMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughColorLutPropertiesMETA>
 * @xrentity{XrSystemPassthroughColorLutPropertiesMETA}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemPassthroughColorLutPropertiesMETA : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemPassthroughColorLutPropertiesMETA (
            void * next_ = nullptr)

: Parent(StructureType::SystemPassthroughColorLutPropertiesMETA
             , next_)
            {}

        //! Default copy constructor
        SystemPassthroughColorLutPropertiesMETA(const SystemPassthroughColorLutPropertiesMETA& rhs) = default;
        //! Default copy assignment
        SystemPassthroughColorLutPropertiesMETA& operator=(const SystemPassthroughColorLutPropertiesMETA& rhs) = default;
        //! Copy construct from raw
        SystemPassthroughColorLutPropertiesMETA(const XrSystemPassthroughColorLutPropertiesMETA& rhs) : SystemPassthroughColorLutPropertiesMETA() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemPassthroughColorLutPropertiesMETA& operator=(const XrSystemPassthroughColorLutPropertiesMETA& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemPassthroughColorLutPropertiesMETA &() const { return *reinterpret_cast<const XrSystemPassthroughColorLutPropertiesMETA*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemPassthroughColorLutPropertiesMETA &() {
            return *reinterpret_cast<XrSystemPassthroughColorLutPropertiesMETA*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemPassthroughColorLutPropertiesMETA
        XrSystemPassthroughColorLutPropertiesMETA const* get() const noexcept { return reinterpret_cast<XrSystemPassthroughColorLutPropertiesMETA const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemPassthroughColorLutPropertiesMETA.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemPassthroughColorLutPropertiesMETA * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemPassthroughColorLutPropertiesMETA{};next = oldNext;}
            return reinterpret_cast<XrSystemPassthroughColorLutPropertiesMETA*>(this);
        }
        uint32_t maxColorLutResolution;
    };
     static_assert(sizeof(XrSystemPassthroughColorLutPropertiesMETA) == sizeof(SystemPassthroughColorLutPropertiesMETA), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemPassthroughColorLutPropertiesMETA pointer to const from a SystemPassthroughColorLutPropertiesMETA reference to const.
 * @relates SystemPassthroughColorLutPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPassthroughColorLutPropertiesMETA const* get(SystemPassthroughColorLutPropertiesMETA const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemPassthroughColorLutPropertiesMETA as the address of a raw XrSystemPassthroughColorLutPropertiesMETA
 * @relates SystemPassthroughColorLutPropertiesMETA
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPassthroughColorLutPropertiesMETA * put(SystemPassthroughColorLutPropertiesMETA &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_META_passthrough_color_lut































    #ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrPassthroughCreateInfoHTC
 * 
 * Provided by the `XR_HTC_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughCreateInfoHTC>
 * @xrentity{XrPassthroughCreateInfoHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughCreateInfoHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughCreateInfoHTC (
 const PassthroughFormHTC& form_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughCreateInfoHTC
, next_)
, form {form_}
        {
        }


        //! Default/empty constructor
                 PassthroughCreateInfoHTC (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughCreateInfoHTC
             , next_)
, form{}
            {}

        //! Default copy constructor
        PassthroughCreateInfoHTC(const PassthroughCreateInfoHTC& rhs) = default;
        //! Default copy assignment
        PassthroughCreateInfoHTC& operator=(const PassthroughCreateInfoHTC& rhs) = default;
        //! Copy construct from raw
        PassthroughCreateInfoHTC(const XrPassthroughCreateInfoHTC& rhs) : PassthroughCreateInfoHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughCreateInfoHTC& operator=(const XrPassthroughCreateInfoHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughCreateInfoHTC &() const { return *reinterpret_cast<const XrPassthroughCreateInfoHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughCreateInfoHTC &() {
            return *reinterpret_cast<XrPassthroughCreateInfoHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughCreateInfoHTC
        XrPassthroughCreateInfoHTC const* get() const noexcept { return reinterpret_cast<XrPassthroughCreateInfoHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughCreateInfoHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughCreateInfoHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughCreateInfoHTC{};next = oldNext;}
            return reinterpret_cast<XrPassthroughCreateInfoHTC*>(this);
        }
        PassthroughFormHTC form;
    };
     static_assert(sizeof(XrPassthroughCreateInfoHTC) == sizeof(PassthroughCreateInfoHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughCreateInfoHTC pointer to const from a PassthroughCreateInfoHTC reference to const.
 * @relates PassthroughCreateInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughCreateInfoHTC const* get(PassthroughCreateInfoHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughCreateInfoHTC as the address of a raw XrPassthroughCreateInfoHTC
 * @relates PassthroughCreateInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughCreateInfoHTC * put(PassthroughCreateInfoHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_passthrough































    #ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrPassthroughColorHTC
 * 
 * Provided by the `XR_HTC_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorHTC>
 * @xrentity{XrPassthroughColorHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughColorHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughColorHTC (
 float alpha_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughColorHTC
, next_)
, alpha {alpha_}
        {
        }


        //! Default/empty constructor
                 PassthroughColorHTC (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughColorHTC
             , next_)
, alpha{0.0f}
            {}

        //! Default copy constructor
        PassthroughColorHTC(const PassthroughColorHTC& rhs) = default;
        //! Default copy assignment
        PassthroughColorHTC& operator=(const PassthroughColorHTC& rhs) = default;
        //! Copy construct from raw
        PassthroughColorHTC(const XrPassthroughColorHTC& rhs) : PassthroughColorHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughColorHTC& operator=(const XrPassthroughColorHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughColorHTC &() const { return *reinterpret_cast<const XrPassthroughColorHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughColorHTC &() {
            return *reinterpret_cast<XrPassthroughColorHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughColorHTC
        XrPassthroughColorHTC const* get() const noexcept { return reinterpret_cast<XrPassthroughColorHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughColorHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughColorHTC{};next = oldNext;}
            return reinterpret_cast<XrPassthroughColorHTC*>(this);
        }
        float alpha;
    };
     static_assert(sizeof(XrPassthroughColorHTC) == sizeof(PassthroughColorHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughColorHTC pointer to const from a PassthroughColorHTC reference to const.
 * @relates PassthroughColorHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorHTC const* get(PassthroughColorHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorHTC as the address of a raw XrPassthroughColorHTC
 * @relates PassthroughColorHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughColorHTC * put(PassthroughColorHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_passthrough































    #ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrPassthroughMeshTransformInfoHTC
 * 
 * Provided by the `XR_HTC_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughMeshTransformInfoHTC>
 * @xrentity{XrPassthroughMeshTransformInfoHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PassthroughMeshTransformInfoHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PassthroughMeshTransformInfoHTC (
 uint32_t vertexCount_,  const Vector3f* vertices_,  uint32_t indexCount_,  const uint32_t* indices_,  const Space& baseSpace_,  const Time& time_,  const Posef& pose_,  const Vector3f& scale_,  const void * next_ = nullptr                  )
: Parent(StructureType::PassthroughMeshTransformInfoHTC
, next_)
, vertexCount {vertexCount_}
, vertices {vertices_}
, indexCount {indexCount_}
, indices {indices_}
, baseSpace {baseSpace_}
, time {time_}
, pose {pose_}
, scale {scale_}
        {
        }


        //! Default/empty constructor
                 PassthroughMeshTransformInfoHTC (
            const void * next_ = nullptr)

: Parent(StructureType::PassthroughMeshTransformInfoHTC
             , next_)
, vertexCount{0}
, vertices{nullptr}
, indexCount{0}
, indices{nullptr}
, baseSpace{}
, time{}
, pose{}
, scale{}
            {}

        //! Default copy constructor
        PassthroughMeshTransformInfoHTC(const PassthroughMeshTransformInfoHTC& rhs) = default;
        //! Default copy assignment
        PassthroughMeshTransformInfoHTC& operator=(const PassthroughMeshTransformInfoHTC& rhs) = default;
        //! Copy construct from raw
        PassthroughMeshTransformInfoHTC(const XrPassthroughMeshTransformInfoHTC& rhs) : PassthroughMeshTransformInfoHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PassthroughMeshTransformInfoHTC& operator=(const XrPassthroughMeshTransformInfoHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPassthroughMeshTransformInfoHTC &() const { return *reinterpret_cast<const XrPassthroughMeshTransformInfoHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPassthroughMeshTransformInfoHTC &() {
            return *reinterpret_cast<XrPassthroughMeshTransformInfoHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrPassthroughMeshTransformInfoHTC
        XrPassthroughMeshTransformInfoHTC const* get() const noexcept { return reinterpret_cast<XrPassthroughMeshTransformInfoHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughMeshTransformInfoHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPassthroughMeshTransformInfoHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PassthroughMeshTransformInfoHTC{};next = oldNext;}
            return reinterpret_cast<XrPassthroughMeshTransformInfoHTC*>(this);
        }
        uint32_t vertexCount;
        const Vector3f* vertices;
        uint32_t indexCount;
        const uint32_t* indices;
        Space baseSpace;
        Time time;
        Posef pose;
        Vector3f scale;
    };
     static_assert(sizeof(XrPassthroughMeshTransformInfoHTC) == sizeof(PassthroughMeshTransformInfoHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPassthroughMeshTransformInfoHTC pointer to const from a PassthroughMeshTransformInfoHTC reference to const.
 * @relates PassthroughMeshTransformInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughMeshTransformInfoHTC const* get(PassthroughMeshTransformInfoHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughMeshTransformInfoHTC as the address of a raw XrPassthroughMeshTransformInfoHTC
 * @relates PassthroughMeshTransformInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPassthroughMeshTransformInfoHTC * put(PassthroughMeshTransformInfoHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_passthrough































    #ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrCompositionLayerPassthroughHTC
 * 
 * Provided by the `XR_HTC_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerPassthroughHTC>
 * @xrentity{XrCompositionLayerPassthroughHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS CompositionLayerPassthroughHTC : public CompositionLayerBaseHeader
    {
    private:
        using Parent = CompositionLayerBaseHeader;
    public:
        //! Constructor initializing all members.
                CompositionLayerPassthroughHTC (
 const CompositionLayerFlags& layerFlags_,  const Space& space_,  const PassthroughHTC& passthrough_,  const PassthroughColorHTC& color_,  const void * next_ = nullptr                  )
: Parent(StructureType::CompositionLayerPassthroughHTC
, layerFlags_, space_, next_)
, passthrough {passthrough_}
, color {color_}
        {
        }


        //! Default/empty constructor
                 CompositionLayerPassthroughHTC (
            const void * next_ = nullptr)

: Parent(StructureType::CompositionLayerPassthroughHTC
, {}, {}             , next_)
, passthrough{}
, color{}
            {}

        //! Default copy constructor
        CompositionLayerPassthroughHTC(const CompositionLayerPassthroughHTC& rhs) = default;
        //! Default copy assignment
        CompositionLayerPassthroughHTC& operator=(const CompositionLayerPassthroughHTC& rhs) = default;
        //! Copy construct from raw
        CompositionLayerPassthroughHTC(const XrCompositionLayerPassthroughHTC& rhs) : CompositionLayerPassthroughHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        CompositionLayerPassthroughHTC& operator=(const XrCompositionLayerPassthroughHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrCompositionLayerPassthroughHTC &() const { return *reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrCompositionLayerPassthroughHTC &() {
            return *reinterpret_cast<XrCompositionLayerPassthroughHTC*>(this);
        }

        //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
        XrCompositionLayerBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrCompositionLayerPassthroughHTC
        XrCompositionLayerPassthroughHTC const* get() const noexcept { return reinterpret_cast<XrCompositionLayerPassthroughHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerPassthroughHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrCompositionLayerPassthroughHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = CompositionLayerPassthroughHTC{};next = oldNext;}
            return reinterpret_cast<XrCompositionLayerPassthroughHTC*>(this);
        }
        PassthroughHTC passthrough;
        PassthroughColorHTC color;
    };
     static_assert(sizeof(XrCompositionLayerPassthroughHTC) == sizeof(CompositionLayerPassthroughHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrCompositionLayerPassthroughHTC pointer to const from a CompositionLayerPassthroughHTC reference to const.
 * @relates CompositionLayerPassthroughHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerPassthroughHTC const* get(CompositionLayerPassthroughHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerPassthroughHTC as the address of a raw XrCompositionLayerPassthroughHTC
 * @relates CompositionLayerPassthroughHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerPassthroughHTC * put(CompositionLayerPassthroughHTC &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const CompositionLayerPassthroughHTC as a raw, pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerPassthroughHTC
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(CompositionLayerPassthroughHTC const& h) {
        return h.get_base();
    }
#endif  // XR_HTC_passthrough































    #ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationApplyInfoHTC
 * 
 * Provided by the `XR_HTC_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationApplyInfoHTC>
 * @xrentity{XrFoveationApplyInfoHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationApplyInfoHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FoveationApplyInfoHTC (
 const FoveationModeHTC& mode_,  uint32_t subImageCount_,  SwapchainSubImage* subImages_,  const void * next_ = nullptr                  )
: Parent(StructureType::FoveationApplyInfoHTC
, next_)
, mode {mode_}
, subImageCount {subImageCount_}
, subImages {subImages_}
        {
        }


        //! Default/empty constructor
                 FoveationApplyInfoHTC (
            const void * next_ = nullptr)

: Parent(StructureType::FoveationApplyInfoHTC
             , next_)
, mode{}
, subImageCount{0}
, subImages{nullptr}
            {}

        //! Default copy constructor
        FoveationApplyInfoHTC(const FoveationApplyInfoHTC& rhs) = default;
        //! Default copy assignment
        FoveationApplyInfoHTC& operator=(const FoveationApplyInfoHTC& rhs) = default;
        //! Copy construct from raw
        FoveationApplyInfoHTC(const XrFoveationApplyInfoHTC& rhs) : FoveationApplyInfoHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationApplyInfoHTC& operator=(const XrFoveationApplyInfoHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationApplyInfoHTC &() const { return *reinterpret_cast<const XrFoveationApplyInfoHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationApplyInfoHTC &() {
            return *reinterpret_cast<XrFoveationApplyInfoHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationApplyInfoHTC
        XrFoveationApplyInfoHTC const* get() const noexcept { return reinterpret_cast<XrFoveationApplyInfoHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationApplyInfoHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationApplyInfoHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationApplyInfoHTC{};next = oldNext;}
            return reinterpret_cast<XrFoveationApplyInfoHTC*>(this);
        }
        FoveationModeHTC mode;
        uint32_t subImageCount;
        SwapchainSubImage* subImages;
    };
     static_assert(sizeof(XrFoveationApplyInfoHTC) == sizeof(FoveationApplyInfoHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationApplyInfoHTC pointer to const from a FoveationApplyInfoHTC reference to const.
 * @relates FoveationApplyInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationApplyInfoHTC const* get(FoveationApplyInfoHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationApplyInfoHTC as the address of a raw XrFoveationApplyInfoHTC
 * @relates FoveationApplyInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationApplyInfoHTC * put(FoveationApplyInfoHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_foveation































    #ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationConfigurationHTC
 * 
 * Provided by the `XR_HTC_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationConfigurationHTC>
 * @xrentity{XrFoveationConfigurationHTC}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS FoveationConfigurationHTC 
    {
    public:
        //! Constructor initializing all members.
                FoveationConfigurationHTC (
 const FoveationLevelHTC& level_,  float clearFovDegree_,  const Vector2f& focalCenterOffset_                  )
: level {level_}
, clearFovDegree {clearFovDegree_}
, focalCenterOffset {focalCenterOffset_}
        {
        }


        //! Default/empty constructor
                 FoveationConfigurationHTC (
            )

: level{}
, clearFovDegree{0.0f}
, focalCenterOffset{}
            {}

        //! Default copy constructor
        FoveationConfigurationHTC(const FoveationConfigurationHTC& rhs) = default;
        //! Default copy assignment
        FoveationConfigurationHTC& operator=(const FoveationConfigurationHTC& rhs) = default;
        //! Copy construct from raw
        FoveationConfigurationHTC(const XrFoveationConfigurationHTC& rhs) : FoveationConfigurationHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationConfigurationHTC& operator=(const XrFoveationConfigurationHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationConfigurationHTC &() const { return *reinterpret_cast<const XrFoveationConfigurationHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationConfigurationHTC &() {
            return *reinterpret_cast<XrFoveationConfigurationHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationConfigurationHTC
        XrFoveationConfigurationHTC const* get() const noexcept { return reinterpret_cast<XrFoveationConfigurationHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationConfigurationHTC.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrFoveationConfigurationHTC * put(bool clear = true) noexcept {
            if (clear) {*this = FoveationConfigurationHTC{};}
            return reinterpret_cast<XrFoveationConfigurationHTC*>(this);
        }
        FoveationLevelHTC level;
        float clearFovDegree;
        Vector2f focalCenterOffset;
    };
     static_assert(sizeof(XrFoveationConfigurationHTC) == sizeof(FoveationConfigurationHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationConfigurationHTC pointer to const from a FoveationConfigurationHTC reference to const.
 * @relates FoveationConfigurationHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationConfigurationHTC const* get(FoveationConfigurationHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationConfigurationHTC as the address of a raw XrFoveationConfigurationHTC
 * @relates FoveationConfigurationHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationConfigurationHTC * put(FoveationConfigurationHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_foveation































    #ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationDynamicModeInfoHTC
 * 
 * Provided by the `XR_HTC_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationDynamicModeInfoHTC>
 * @xrentity{XrFoveationDynamicModeInfoHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationDynamicModeInfoHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FoveationDynamicModeInfoHTC (
 const FoveationDynamicFlagsHTC& dynamicFlags_,  const void * next_ = nullptr                  )
: Parent(StructureType::FoveationDynamicModeInfoHTC
, next_)
, dynamicFlags {dynamicFlags_}
        {
        }


        //! Default/empty constructor
                 FoveationDynamicModeInfoHTC (
            const void * next_ = nullptr)

: Parent(StructureType::FoveationDynamicModeInfoHTC
             , next_)
, dynamicFlags{}
            {}

        //! Default copy constructor
        FoveationDynamicModeInfoHTC(const FoveationDynamicModeInfoHTC& rhs) = default;
        //! Default copy assignment
        FoveationDynamicModeInfoHTC& operator=(const FoveationDynamicModeInfoHTC& rhs) = default;
        //! Copy construct from raw
        FoveationDynamicModeInfoHTC(const XrFoveationDynamicModeInfoHTC& rhs) : FoveationDynamicModeInfoHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationDynamicModeInfoHTC& operator=(const XrFoveationDynamicModeInfoHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationDynamicModeInfoHTC &() const { return *reinterpret_cast<const XrFoveationDynamicModeInfoHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationDynamicModeInfoHTC &() {
            return *reinterpret_cast<XrFoveationDynamicModeInfoHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationDynamicModeInfoHTC
        XrFoveationDynamicModeInfoHTC const* get() const noexcept { return reinterpret_cast<XrFoveationDynamicModeInfoHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationDynamicModeInfoHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationDynamicModeInfoHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationDynamicModeInfoHTC{};next = oldNext;}
            return reinterpret_cast<XrFoveationDynamicModeInfoHTC*>(this);
        }
        FoveationDynamicFlagsHTC dynamicFlags;
    };
     static_assert(sizeof(XrFoveationDynamicModeInfoHTC) == sizeof(FoveationDynamicModeInfoHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationDynamicModeInfoHTC pointer to const from a FoveationDynamicModeInfoHTC reference to const.
 * @relates FoveationDynamicModeInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationDynamicModeInfoHTC const* get(FoveationDynamicModeInfoHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationDynamicModeInfoHTC as the address of a raw XrFoveationDynamicModeInfoHTC
 * @relates FoveationDynamicModeInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationDynamicModeInfoHTC * put(FoveationDynamicModeInfoHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_foveation































    #ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationCustomModeInfoHTC
 * 
 * Provided by the `XR_HTC_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationCustomModeInfoHTC>
 * @xrentity{XrFoveationCustomModeInfoHTC}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS FoveationCustomModeInfoHTC : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                FoveationCustomModeInfoHTC (
 uint32_t configCount_,  const FoveationConfigurationHTC* configs_,  const void * next_ = nullptr                  )
: Parent(StructureType::FoveationCustomModeInfoHTC
, next_)
, configCount {configCount_}
, configs {configs_}
        {
        }


        //! Default/empty constructor
                 FoveationCustomModeInfoHTC (
            const void * next_ = nullptr)

: Parent(StructureType::FoveationCustomModeInfoHTC
             , next_)
, configCount{0}
, configs{nullptr}
            {}

        //! Default copy constructor
        FoveationCustomModeInfoHTC(const FoveationCustomModeInfoHTC& rhs) = default;
        //! Default copy assignment
        FoveationCustomModeInfoHTC& operator=(const FoveationCustomModeInfoHTC& rhs) = default;
        //! Copy construct from raw
        FoveationCustomModeInfoHTC(const XrFoveationCustomModeInfoHTC& rhs) : FoveationCustomModeInfoHTC() {
            *put() = rhs;
        }
        //! Copy assign from raw
        FoveationCustomModeInfoHTC& operator=(const XrFoveationCustomModeInfoHTC& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrFoveationCustomModeInfoHTC &() const { return *reinterpret_cast<const XrFoveationCustomModeInfoHTC*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrFoveationCustomModeInfoHTC &() {
            return *reinterpret_cast<XrFoveationCustomModeInfoHTC*>(this);
        }

        //! Accessor for this as the address of a raw XrFoveationCustomModeInfoHTC
        XrFoveationCustomModeInfoHTC const* get() const noexcept { return reinterpret_cast<XrFoveationCustomModeInfoHTC const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrFoveationCustomModeInfoHTC.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrFoveationCustomModeInfoHTC * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = FoveationCustomModeInfoHTC{};next = oldNext;}
            return reinterpret_cast<XrFoveationCustomModeInfoHTC*>(this);
        }
        uint32_t configCount;
        const FoveationConfigurationHTC* configs;
    };
     static_assert(sizeof(XrFoveationCustomModeInfoHTC) == sizeof(FoveationCustomModeInfoHTC), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrFoveationCustomModeInfoHTC pointer to const from a FoveationCustomModeInfoHTC reference to const.
 * @relates FoveationCustomModeInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationCustomModeInfoHTC const* get(FoveationCustomModeInfoHTC const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationCustomModeInfoHTC as the address of a raw XrFoveationCustomModeInfoHTC
 * @relates FoveationCustomModeInfoHTC
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrFoveationCustomModeInfoHTC * put(FoveationCustomModeInfoHTC &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_HTC_foveation































    #ifdef XR_EXT_active_action_set_priority
/*!
 * C++ projection of XrActiveActionSetPriorityEXT
 * 
 * Provided by the `XR_EXT_active_action_set_priority` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSetPriorityEXT>
 * @xrentity{XrActiveActionSetPriorityEXT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ActiveActionSetPriorityEXT 
    {
    public:
        //! Constructor initializing all members.
                ActiveActionSetPriorityEXT (
 const ActionSet& actionSet_,  uint32_t priorityOverride_                  )
: actionSet {actionSet_}
, priorityOverride {priorityOverride_}
        {
        }


        //! Default/empty constructor
                 ActiveActionSetPriorityEXT (
            )

: actionSet{}
, priorityOverride{0}
            {}

        //! Default copy constructor
        ActiveActionSetPriorityEXT(const ActiveActionSetPriorityEXT& rhs) = default;
        //! Default copy assignment
        ActiveActionSetPriorityEXT& operator=(const ActiveActionSetPriorityEXT& rhs) = default;
        //! Copy construct from raw
        ActiveActionSetPriorityEXT(const XrActiveActionSetPriorityEXT& rhs) : ActiveActionSetPriorityEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActiveActionSetPriorityEXT& operator=(const XrActiveActionSetPriorityEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActiveActionSetPriorityEXT &() const { return *reinterpret_cast<const XrActiveActionSetPriorityEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActiveActionSetPriorityEXT &() {
            return *reinterpret_cast<XrActiveActionSetPriorityEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrActiveActionSetPriorityEXT
        XrActiveActionSetPriorityEXT const* get() const noexcept { return reinterpret_cast<XrActiveActionSetPriorityEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActiveActionSetPriorityEXT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrActiveActionSetPriorityEXT * put(bool clear = true) noexcept {
            if (clear) {*this = ActiveActionSetPriorityEXT{};}
            return reinterpret_cast<XrActiveActionSetPriorityEXT*>(this);
        }
        ActionSet actionSet;
        uint32_t priorityOverride;
    };
     static_assert(sizeof(XrActiveActionSetPriorityEXT) == sizeof(ActiveActionSetPriorityEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActiveActionSetPriorityEXT pointer to const from a ActiveActionSetPriorityEXT reference to const.
 * @relates ActiveActionSetPriorityEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActiveActionSetPriorityEXT const* get(ActiveActionSetPriorityEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSetPriorityEXT as the address of a raw XrActiveActionSetPriorityEXT
 * @relates ActiveActionSetPriorityEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActiveActionSetPriorityEXT * put(ActiveActionSetPriorityEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_active_action_set_priority































    #ifdef XR_EXT_active_action_set_priority
/*!
 * C++ projection of XrActiveActionSetPrioritiesEXT
 * 
 * Provided by the `XR_EXT_active_action_set_priority` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSetPrioritiesEXT>
 * @xrentity{XrActiveActionSetPrioritiesEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ActiveActionSetPrioritiesEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ActiveActionSetPrioritiesEXT (
 uint32_t actionSetPriorityCount_,  const ActiveActionSetPriorityEXT* actionSetPriorities_,  const void * next_ = nullptr                  )
: Parent(StructureType::ActiveActionSetPrioritiesEXT
, next_)
, actionSetPriorityCount {actionSetPriorityCount_}
, actionSetPriorities {actionSetPriorities_}
        {
        }


        //! Default/empty constructor
                 ActiveActionSetPrioritiesEXT (
            const void * next_ = nullptr)

: Parent(StructureType::ActiveActionSetPrioritiesEXT
             , next_)
, actionSetPriorityCount{0}
, actionSetPriorities{nullptr}
            {}

        //! Default copy constructor
        ActiveActionSetPrioritiesEXT(const ActiveActionSetPrioritiesEXT& rhs) = default;
        //! Default copy assignment
        ActiveActionSetPrioritiesEXT& operator=(const ActiveActionSetPrioritiesEXT& rhs) = default;
        //! Copy construct from raw
        ActiveActionSetPrioritiesEXT(const XrActiveActionSetPrioritiesEXT& rhs) : ActiveActionSetPrioritiesEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ActiveActionSetPrioritiesEXT& operator=(const XrActiveActionSetPrioritiesEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrActiveActionSetPrioritiesEXT &() const { return *reinterpret_cast<const XrActiveActionSetPrioritiesEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrActiveActionSetPrioritiesEXT &() {
            return *reinterpret_cast<XrActiveActionSetPrioritiesEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrActiveActionSetPrioritiesEXT
        XrActiveActionSetPrioritiesEXT const* get() const noexcept { return reinterpret_cast<XrActiveActionSetPrioritiesEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrActiveActionSetPrioritiesEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrActiveActionSetPrioritiesEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ActiveActionSetPrioritiesEXT{};next = oldNext;}
            return reinterpret_cast<XrActiveActionSetPrioritiesEXT*>(this);
        }
        uint32_t actionSetPriorityCount;
        const ActiveActionSetPriorityEXT* actionSetPriorities;
    };
     static_assert(sizeof(XrActiveActionSetPrioritiesEXT) == sizeof(ActiveActionSetPrioritiesEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrActiveActionSetPrioritiesEXT pointer to const from a ActiveActionSetPrioritiesEXT reference to const.
 * @relates ActiveActionSetPrioritiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActiveActionSetPrioritiesEXT const* get(ActiveActionSetPrioritiesEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSetPrioritiesEXT as the address of a raw XrActiveActionSetPrioritiesEXT
 * @relates ActiveActionSetPrioritiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrActiveActionSetPrioritiesEXT * put(ActiveActionSetPrioritiesEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_active_action_set_priority































    #ifdef XR_MNDX_force_feedback_curl
/*!
 * C++ projection of XrSystemForceFeedbackCurlPropertiesMNDX
 * 
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemForceFeedbackCurlPropertiesMNDX>
 * @xrentity{XrSystemForceFeedbackCurlPropertiesMNDX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemForceFeedbackCurlPropertiesMNDX : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemForceFeedbackCurlPropertiesMNDX (
            void * next_ = nullptr)

: Parent(StructureType::SystemForceFeedbackCurlPropertiesMNDX
             , next_)
            {}

        //! Default copy constructor
        SystemForceFeedbackCurlPropertiesMNDX(const SystemForceFeedbackCurlPropertiesMNDX& rhs) = default;
        //! Default copy assignment
        SystemForceFeedbackCurlPropertiesMNDX& operator=(const SystemForceFeedbackCurlPropertiesMNDX& rhs) = default;
        //! Copy construct from raw
        SystemForceFeedbackCurlPropertiesMNDX(const XrSystemForceFeedbackCurlPropertiesMNDX& rhs) : SystemForceFeedbackCurlPropertiesMNDX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemForceFeedbackCurlPropertiesMNDX& operator=(const XrSystemForceFeedbackCurlPropertiesMNDX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemForceFeedbackCurlPropertiesMNDX &() const { return *reinterpret_cast<const XrSystemForceFeedbackCurlPropertiesMNDX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemForceFeedbackCurlPropertiesMNDX &() {
            return *reinterpret_cast<XrSystemForceFeedbackCurlPropertiesMNDX*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemForceFeedbackCurlPropertiesMNDX
        XrSystemForceFeedbackCurlPropertiesMNDX const* get() const noexcept { return reinterpret_cast<XrSystemForceFeedbackCurlPropertiesMNDX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemForceFeedbackCurlPropertiesMNDX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemForceFeedbackCurlPropertiesMNDX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemForceFeedbackCurlPropertiesMNDX{};next = oldNext;}
            return reinterpret_cast<XrSystemForceFeedbackCurlPropertiesMNDX*>(this);
        }
        Bool32 supportsForceFeedbackCurl;
    };
     static_assert(sizeof(XrSystemForceFeedbackCurlPropertiesMNDX) == sizeof(SystemForceFeedbackCurlPropertiesMNDX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemForceFeedbackCurlPropertiesMNDX pointer to const from a SystemForceFeedbackCurlPropertiesMNDX reference to const.
 * @relates SystemForceFeedbackCurlPropertiesMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemForceFeedbackCurlPropertiesMNDX const* get(SystemForceFeedbackCurlPropertiesMNDX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemForceFeedbackCurlPropertiesMNDX as the address of a raw XrSystemForceFeedbackCurlPropertiesMNDX
 * @relates SystemForceFeedbackCurlPropertiesMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemForceFeedbackCurlPropertiesMNDX * put(SystemForceFeedbackCurlPropertiesMNDX &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MNDX_force_feedback_curl































    #ifdef XR_MNDX_force_feedback_curl
/*!
 * C++ projection of XrForceFeedbackCurlApplyLocationMNDX
 * 
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrForceFeedbackCurlApplyLocationMNDX>
 * @xrentity{XrForceFeedbackCurlApplyLocationMNDX}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS ForceFeedbackCurlApplyLocationMNDX 
    {
    public:
        //! Constructor initializing all members.
                ForceFeedbackCurlApplyLocationMNDX (
 const ForceFeedbackCurlLocationMNDX& location_,  float value_                  )
: location {location_}
, value {value_}
        {
        }


        //! Default/empty constructor
                 ForceFeedbackCurlApplyLocationMNDX (
            )

: location{}
, value{0.0f}
            {}

        //! Default copy constructor
        ForceFeedbackCurlApplyLocationMNDX(const ForceFeedbackCurlApplyLocationMNDX& rhs) = default;
        //! Default copy assignment
        ForceFeedbackCurlApplyLocationMNDX& operator=(const ForceFeedbackCurlApplyLocationMNDX& rhs) = default;
        //! Copy construct from raw
        ForceFeedbackCurlApplyLocationMNDX(const XrForceFeedbackCurlApplyLocationMNDX& rhs) : ForceFeedbackCurlApplyLocationMNDX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ForceFeedbackCurlApplyLocationMNDX& operator=(const XrForceFeedbackCurlApplyLocationMNDX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrForceFeedbackCurlApplyLocationMNDX &() const { return *reinterpret_cast<const XrForceFeedbackCurlApplyLocationMNDX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrForceFeedbackCurlApplyLocationMNDX &() {
            return *reinterpret_cast<XrForceFeedbackCurlApplyLocationMNDX*>(this);
        }

        //! Accessor for this as the address of a raw XrForceFeedbackCurlApplyLocationMNDX
        XrForceFeedbackCurlApplyLocationMNDX const* get() const noexcept { return reinterpret_cast<XrForceFeedbackCurlApplyLocationMNDX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrForceFeedbackCurlApplyLocationMNDX.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrForceFeedbackCurlApplyLocationMNDX * put(bool clear = true) noexcept {
            if (clear) {*this = ForceFeedbackCurlApplyLocationMNDX{};}
            return reinterpret_cast<XrForceFeedbackCurlApplyLocationMNDX*>(this);
        }
        ForceFeedbackCurlLocationMNDX location;
        float value;
    };
     static_assert(sizeof(XrForceFeedbackCurlApplyLocationMNDX) == sizeof(ForceFeedbackCurlApplyLocationMNDX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrForceFeedbackCurlApplyLocationMNDX pointer to const from a ForceFeedbackCurlApplyLocationMNDX reference to const.
 * @relates ForceFeedbackCurlApplyLocationMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationMNDX const* get(ForceFeedbackCurlApplyLocationMNDX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ForceFeedbackCurlApplyLocationMNDX as the address of a raw XrForceFeedbackCurlApplyLocationMNDX
 * @relates ForceFeedbackCurlApplyLocationMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationMNDX * put(ForceFeedbackCurlApplyLocationMNDX &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MNDX_force_feedback_curl































    #ifdef XR_MNDX_force_feedback_curl
/*!
 * C++ projection of XrForceFeedbackCurlApplyLocationsMNDX
 * 
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrForceFeedbackCurlApplyLocationsMNDX>
 * @xrentity{XrForceFeedbackCurlApplyLocationsMNDX}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS ForceFeedbackCurlApplyLocationsMNDX : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                ForceFeedbackCurlApplyLocationsMNDX (
 uint32_t locationCount_,  ForceFeedbackCurlApplyLocationMNDX* locations_,  const void * next_ = nullptr                  )
: Parent(StructureType::ForceFeedbackCurlApplyLocationsMNDX
, next_)
, locationCount {locationCount_}
, locations {locations_}
        {
        }


        //! Default/empty constructor
                 ForceFeedbackCurlApplyLocationsMNDX (
            const void * next_ = nullptr)

: Parent(StructureType::ForceFeedbackCurlApplyLocationsMNDX
             , next_)
, locationCount{0}
, locations{nullptr}
            {}

        //! Default copy constructor
        ForceFeedbackCurlApplyLocationsMNDX(const ForceFeedbackCurlApplyLocationsMNDX& rhs) = default;
        //! Default copy assignment
        ForceFeedbackCurlApplyLocationsMNDX& operator=(const ForceFeedbackCurlApplyLocationsMNDX& rhs) = default;
        //! Copy construct from raw
        ForceFeedbackCurlApplyLocationsMNDX(const XrForceFeedbackCurlApplyLocationsMNDX& rhs) : ForceFeedbackCurlApplyLocationsMNDX() {
            *put() = rhs;
        }
        //! Copy assign from raw
        ForceFeedbackCurlApplyLocationsMNDX& operator=(const XrForceFeedbackCurlApplyLocationsMNDX& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrForceFeedbackCurlApplyLocationsMNDX &() const { return *reinterpret_cast<const XrForceFeedbackCurlApplyLocationsMNDX*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrForceFeedbackCurlApplyLocationsMNDX &() {
            return *reinterpret_cast<XrForceFeedbackCurlApplyLocationsMNDX*>(this);
        }

        //! Accessor for this as the address of a raw XrForceFeedbackCurlApplyLocationsMNDX
        XrForceFeedbackCurlApplyLocationsMNDX const* get() const noexcept { return reinterpret_cast<XrForceFeedbackCurlApplyLocationsMNDX const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrForceFeedbackCurlApplyLocationsMNDX.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrForceFeedbackCurlApplyLocationsMNDX * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = ForceFeedbackCurlApplyLocationsMNDX{};next = oldNext;}
            return reinterpret_cast<XrForceFeedbackCurlApplyLocationsMNDX*>(this);
        }
        uint32_t locationCount;
        ForceFeedbackCurlApplyLocationMNDX* locations;
    };
     static_assert(sizeof(XrForceFeedbackCurlApplyLocationsMNDX) == sizeof(ForceFeedbackCurlApplyLocationsMNDX), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrForceFeedbackCurlApplyLocationsMNDX pointer to const from a ForceFeedbackCurlApplyLocationsMNDX reference to const.
 * @relates ForceFeedbackCurlApplyLocationsMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationsMNDX const* get(ForceFeedbackCurlApplyLocationsMNDX const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing ForceFeedbackCurlApplyLocationsMNDX as the address of a raw XrForceFeedbackCurlApplyLocationsMNDX
 * @relates ForceFeedbackCurlApplyLocationsMNDX
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationsMNDX * put(ForceFeedbackCurlApplyLocationsMNDX &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_MNDX_force_feedback_curl































    #ifdef XR_EXT_hand_tracking_data_source
/*!
 * C++ projection of XrHandTrackingDataSourceInfoEXT
 * 
 * Provided by the `XR_EXT_hand_tracking_data_source` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingDataSourceInfoEXT>
 * @xrentity{XrHandTrackingDataSourceInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackingDataSourceInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                HandTrackingDataSourceInfoEXT (
 uint32_t requestedDataSourceCount_,  HandTrackingDataSourceEXT* requestedDataSources_,  const void * next_ = nullptr                  )
: Parent(StructureType::HandTrackingDataSourceInfoEXT
, next_)
, requestedDataSourceCount {requestedDataSourceCount_}
, requestedDataSources {requestedDataSources_}
        {
        }


        //! Default/empty constructor
                 HandTrackingDataSourceInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::HandTrackingDataSourceInfoEXT
             , next_)
, requestedDataSourceCount{0}
, requestedDataSources{nullptr}
            {}

        //! Default copy constructor
        HandTrackingDataSourceInfoEXT(const HandTrackingDataSourceInfoEXT& rhs) = default;
        //! Default copy assignment
        HandTrackingDataSourceInfoEXT& operator=(const HandTrackingDataSourceInfoEXT& rhs) = default;
        //! Copy construct from raw
        HandTrackingDataSourceInfoEXT(const XrHandTrackingDataSourceInfoEXT& rhs) : HandTrackingDataSourceInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackingDataSourceInfoEXT& operator=(const XrHandTrackingDataSourceInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackingDataSourceInfoEXT &() const { return *reinterpret_cast<const XrHandTrackingDataSourceInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackingDataSourceInfoEXT &() {
            return *reinterpret_cast<XrHandTrackingDataSourceInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackingDataSourceInfoEXT
        XrHandTrackingDataSourceInfoEXT const* get() const noexcept { return reinterpret_cast<XrHandTrackingDataSourceInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingDataSourceInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackingDataSourceInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackingDataSourceInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrHandTrackingDataSourceInfoEXT*>(this);
        }
        uint32_t requestedDataSourceCount;
        HandTrackingDataSourceEXT* requestedDataSources;
    };
     static_assert(sizeof(XrHandTrackingDataSourceInfoEXT) == sizeof(HandTrackingDataSourceInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackingDataSourceInfoEXT pointer to const from a HandTrackingDataSourceInfoEXT reference to const.
 * @relates HandTrackingDataSourceInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingDataSourceInfoEXT const* get(HandTrackingDataSourceInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingDataSourceInfoEXT as the address of a raw XrHandTrackingDataSourceInfoEXT
 * @relates HandTrackingDataSourceInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingDataSourceInfoEXT * put(HandTrackingDataSourceInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking_data_source































    #ifdef XR_EXT_hand_tracking_data_source
/*!
 * C++ projection of XrHandTrackingDataSourceStateEXT
 * 
 * Provided by the `XR_EXT_hand_tracking_data_source` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingDataSourceStateEXT>
 * @xrentity{XrHandTrackingDataSourceStateEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS HandTrackingDataSourceStateEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 HandTrackingDataSourceStateEXT (
            void * next_ = nullptr)

: Parent(StructureType::HandTrackingDataSourceStateEXT
             , next_)
            {}

        //! Default copy constructor
        HandTrackingDataSourceStateEXT(const HandTrackingDataSourceStateEXT& rhs) = default;
        //! Default copy assignment
        HandTrackingDataSourceStateEXT& operator=(const HandTrackingDataSourceStateEXT& rhs) = default;
        //! Copy construct from raw
        HandTrackingDataSourceStateEXT(const XrHandTrackingDataSourceStateEXT& rhs) : HandTrackingDataSourceStateEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        HandTrackingDataSourceStateEXT& operator=(const XrHandTrackingDataSourceStateEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrHandTrackingDataSourceStateEXT &() const { return *reinterpret_cast<const XrHandTrackingDataSourceStateEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrHandTrackingDataSourceStateEXT &() {
            return *reinterpret_cast<XrHandTrackingDataSourceStateEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrHandTrackingDataSourceStateEXT
        XrHandTrackingDataSourceStateEXT const* get() const noexcept { return reinterpret_cast<XrHandTrackingDataSourceStateEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingDataSourceStateEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrHandTrackingDataSourceStateEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = HandTrackingDataSourceStateEXT{};next = oldNext;}
            return reinterpret_cast<XrHandTrackingDataSourceStateEXT*>(this);
        }
        Bool32 isActive;
        HandTrackingDataSourceEXT dataSource;
    };
     static_assert(sizeof(XrHandTrackingDataSourceStateEXT) == sizeof(HandTrackingDataSourceStateEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrHandTrackingDataSourceStateEXT pointer to const from a HandTrackingDataSourceStateEXT reference to const.
 * @relates HandTrackingDataSourceStateEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingDataSourceStateEXT const* get(HandTrackingDataSourceStateEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingDataSourceStateEXT as the address of a raw XrHandTrackingDataSourceStateEXT
 * @relates HandTrackingDataSourceStateEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrHandTrackingDataSourceStateEXT * put(HandTrackingDataSourceStateEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_hand_tracking_data_source































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrSystemPlaneDetectionPropertiesEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPlaneDetectionPropertiesEXT>
 * @xrentity{XrSystemPlaneDetectionPropertiesEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS SystemPlaneDetectionPropertiesEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 SystemPlaneDetectionPropertiesEXT (
            void * next_ = nullptr)

: Parent(StructureType::SystemPlaneDetectionPropertiesEXT
             , next_)
            {}

        //! Default copy constructor
        SystemPlaneDetectionPropertiesEXT(const SystemPlaneDetectionPropertiesEXT& rhs) = default;
        //! Default copy assignment
        SystemPlaneDetectionPropertiesEXT& operator=(const SystemPlaneDetectionPropertiesEXT& rhs) = default;
        //! Copy construct from raw
        SystemPlaneDetectionPropertiesEXT(const XrSystemPlaneDetectionPropertiesEXT& rhs) : SystemPlaneDetectionPropertiesEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        SystemPlaneDetectionPropertiesEXT& operator=(const XrSystemPlaneDetectionPropertiesEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrSystemPlaneDetectionPropertiesEXT &() const { return *reinterpret_cast<const XrSystemPlaneDetectionPropertiesEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrSystemPlaneDetectionPropertiesEXT &() {
            return *reinterpret_cast<XrSystemPlaneDetectionPropertiesEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrSystemPlaneDetectionPropertiesEXT
        XrSystemPlaneDetectionPropertiesEXT const* get() const noexcept { return reinterpret_cast<XrSystemPlaneDetectionPropertiesEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrSystemPlaneDetectionPropertiesEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrSystemPlaneDetectionPropertiesEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = SystemPlaneDetectionPropertiesEXT{};next = oldNext;}
            return reinterpret_cast<XrSystemPlaneDetectionPropertiesEXT*>(this);
        }
        PlaneDetectionCapabilityFlagsEXT supportedFeatures;
    };
     static_assert(sizeof(XrSystemPlaneDetectionPropertiesEXT) == sizeof(SystemPlaneDetectionPropertiesEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrSystemPlaneDetectionPropertiesEXT pointer to const from a SystemPlaneDetectionPropertiesEXT reference to const.
 * @relates SystemPlaneDetectionPropertiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPlaneDetectionPropertiesEXT const* get(SystemPlaneDetectionPropertiesEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemPlaneDetectionPropertiesEXT as the address of a raw XrSystemPlaneDetectionPropertiesEXT
 * @relates SystemPlaneDetectionPropertiesEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrSystemPlaneDetectionPropertiesEXT * put(SystemPlaneDetectionPropertiesEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorCreateInfoEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorCreateInfoEXT>
 * @xrentity{XrPlaneDetectorCreateInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PlaneDetectorCreateInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PlaneDetectorCreateInfoEXT (
 const PlaneDetectorFlagsEXT& flags_,  const void * next_ = nullptr                  )
: Parent(StructureType::PlaneDetectorCreateInfoEXT
, next_)
, flags {flags_}
        {
        }


        //! Default/empty constructor
                 PlaneDetectorCreateInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::PlaneDetectorCreateInfoEXT
             , next_)
, flags{}
            {}

        //! Default copy constructor
        PlaneDetectorCreateInfoEXT(const PlaneDetectorCreateInfoEXT& rhs) = default;
        //! Default copy assignment
        PlaneDetectorCreateInfoEXT& operator=(const PlaneDetectorCreateInfoEXT& rhs) = default;
        //! Copy construct from raw
        PlaneDetectorCreateInfoEXT(const XrPlaneDetectorCreateInfoEXT& rhs) : PlaneDetectorCreateInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PlaneDetectorCreateInfoEXT& operator=(const XrPlaneDetectorCreateInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPlaneDetectorCreateInfoEXT &() const { return *reinterpret_cast<const XrPlaneDetectorCreateInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPlaneDetectorCreateInfoEXT &() {
            return *reinterpret_cast<XrPlaneDetectorCreateInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrPlaneDetectorCreateInfoEXT
        XrPlaneDetectorCreateInfoEXT const* get() const noexcept { return reinterpret_cast<XrPlaneDetectorCreateInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPlaneDetectorCreateInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPlaneDetectorCreateInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PlaneDetectorCreateInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrPlaneDetectorCreateInfoEXT*>(this);
        }
        PlaneDetectorFlagsEXT flags;
    };
     static_assert(sizeof(XrPlaneDetectorCreateInfoEXT) == sizeof(PlaneDetectorCreateInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPlaneDetectorCreateInfoEXT pointer to const from a PlaneDetectorCreateInfoEXT reference to const.
 * @relates PlaneDetectorCreateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorCreateInfoEXT const* get(PlaneDetectorCreateInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorCreateInfoEXT as the address of a raw XrPlaneDetectorCreateInfoEXT
 * @relates PlaneDetectorCreateInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorCreateInfoEXT * put(PlaneDetectorCreateInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrExtent3DfEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent3DfEXT>
 * @xrentity{XrExtent3DfEXT}
 * @ingroup structs
 */
    struct XR_MAY_ALIAS Extent3DfEXT 
    {
    public:
        //! Constructor initializing all members.
                Extent3DfEXT (
 float width_,  float height_,  float depth_                  )
: width {width_}
, height {height_}
, depth {depth_}
        {
        }


        //! Default/empty constructor
                 Extent3DfEXT (
            )

: width{0.0f}
, height{0.0f}
, depth{0.0f}
            {}

        //! Default copy constructor
        Extent3DfEXT(const Extent3DfEXT& rhs) = default;
        //! Default copy assignment
        Extent3DfEXT& operator=(const Extent3DfEXT& rhs) = default;
        //! Copy construct from raw
        Extent3DfEXT(const XrExtent3DfEXT& rhs) : Extent3DfEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        Extent3DfEXT& operator=(const XrExtent3DfEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrExtent3DfEXT &() const { return *reinterpret_cast<const XrExtent3DfEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrExtent3DfEXT &() {
            return *reinterpret_cast<XrExtent3DfEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrExtent3DfEXT
        XrExtent3DfEXT const* get() const noexcept { return reinterpret_cast<XrExtent3DfEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrExtent3DfEXT.
 * 
 * Pass false for the optional argument to skip clearing.
 */
        XrExtent3DfEXT * put(bool clear = true) noexcept {
            if (clear) {*this = Extent3DfEXT{};}
            return reinterpret_cast<XrExtent3DfEXT*>(this);
        }
        float width;
        float height;
        float depth;
    };
     static_assert(sizeof(XrExtent3DfEXT) == sizeof(Extent3DfEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrExtent3DfEXT pointer to const from a Extent3DfEXT reference to const.
 * @relates Extent3DfEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent3DfEXT const* get(Extent3DfEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent3DfEXT as the address of a raw XrExtent3DfEXT
 * @relates Extent3DfEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrExtent3DfEXT * put(Extent3DfEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorBeginInfoEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorBeginInfoEXT>
 * @xrentity{XrPlaneDetectorBeginInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PlaneDetectorBeginInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PlaneDetectorBeginInfoEXT (
 const Space& baseSpace_,  const Time& time_,  uint32_t orientationCount_,  const PlaneDetectorOrientationEXT* orientations_,  uint32_t semanticTypeCount_,  const PlaneDetectorSemanticTypeEXT* semanticTypes_,  uint32_t maxPlanes_,  float minArea_,  const Posef& boundingBoxPose_,  const Extent3DfEXT& boundingBoxExtent_,  const void * next_ = nullptr                  )
: Parent(StructureType::PlaneDetectorBeginInfoEXT
, next_)
, baseSpace {baseSpace_}
, time {time_}
, orientationCount {orientationCount_}
, orientations {orientations_}
, semanticTypeCount {semanticTypeCount_}
, semanticTypes {semanticTypes_}
, maxPlanes {maxPlanes_}
, minArea {minArea_}
, boundingBoxPose {boundingBoxPose_}
, boundingBoxExtent {boundingBoxExtent_}
        {
        }


        //! Default/empty constructor
                 PlaneDetectorBeginInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::PlaneDetectorBeginInfoEXT
             , next_)
, baseSpace{}
, time{}
, orientationCount{0}
, orientations{nullptr}
, semanticTypeCount{0}
, semanticTypes{nullptr}
, maxPlanes{0}
, minArea{0.0f}
, boundingBoxPose{}
, boundingBoxExtent{}
            {}

        //! Default copy constructor
        PlaneDetectorBeginInfoEXT(const PlaneDetectorBeginInfoEXT& rhs) = default;
        //! Default copy assignment
        PlaneDetectorBeginInfoEXT& operator=(const PlaneDetectorBeginInfoEXT& rhs) = default;
        //! Copy construct from raw
        PlaneDetectorBeginInfoEXT(const XrPlaneDetectorBeginInfoEXT& rhs) : PlaneDetectorBeginInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PlaneDetectorBeginInfoEXT& operator=(const XrPlaneDetectorBeginInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPlaneDetectorBeginInfoEXT &() const { return *reinterpret_cast<const XrPlaneDetectorBeginInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPlaneDetectorBeginInfoEXT &() {
            return *reinterpret_cast<XrPlaneDetectorBeginInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrPlaneDetectorBeginInfoEXT
        XrPlaneDetectorBeginInfoEXT const* get() const noexcept { return reinterpret_cast<XrPlaneDetectorBeginInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPlaneDetectorBeginInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPlaneDetectorBeginInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PlaneDetectorBeginInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrPlaneDetectorBeginInfoEXT*>(this);
        }
        Space baseSpace;
        Time time;
        uint32_t orientationCount;
        const PlaneDetectorOrientationEXT* orientations;
        uint32_t semanticTypeCount;
        const PlaneDetectorSemanticTypeEXT* semanticTypes;
        uint32_t maxPlanes;
        float minArea;
        Posef boundingBoxPose;
        Extent3DfEXT boundingBoxExtent;
    };
     static_assert(sizeof(XrPlaneDetectorBeginInfoEXT) == sizeof(PlaneDetectorBeginInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPlaneDetectorBeginInfoEXT pointer to const from a PlaneDetectorBeginInfoEXT reference to const.
 * @relates PlaneDetectorBeginInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorBeginInfoEXT const* get(PlaneDetectorBeginInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorBeginInfoEXT as the address of a raw XrPlaneDetectorBeginInfoEXT
 * @relates PlaneDetectorBeginInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorBeginInfoEXT * put(PlaneDetectorBeginInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorGetInfoEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorGetInfoEXT>
 * @xrentity{XrPlaneDetectorGetInfoEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PlaneDetectorGetInfoEXT : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                PlaneDetectorGetInfoEXT (
 const Space& baseSpace_,  const Time& time_,  const void * next_ = nullptr                  )
: Parent(StructureType::PlaneDetectorGetInfoEXT
, next_)
, baseSpace {baseSpace_}
, time {time_}
        {
        }


        //! Default/empty constructor
                 PlaneDetectorGetInfoEXT (
            const void * next_ = nullptr)

: Parent(StructureType::PlaneDetectorGetInfoEXT
             , next_)
, baseSpace{}
, time{}
            {}

        //! Default copy constructor
        PlaneDetectorGetInfoEXT(const PlaneDetectorGetInfoEXT& rhs) = default;
        //! Default copy assignment
        PlaneDetectorGetInfoEXT& operator=(const PlaneDetectorGetInfoEXT& rhs) = default;
        //! Copy construct from raw
        PlaneDetectorGetInfoEXT(const XrPlaneDetectorGetInfoEXT& rhs) : PlaneDetectorGetInfoEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PlaneDetectorGetInfoEXT& operator=(const XrPlaneDetectorGetInfoEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPlaneDetectorGetInfoEXT &() const { return *reinterpret_cast<const XrPlaneDetectorGetInfoEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPlaneDetectorGetInfoEXT &() {
            return *reinterpret_cast<XrPlaneDetectorGetInfoEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrPlaneDetectorGetInfoEXT
        XrPlaneDetectorGetInfoEXT const* get() const noexcept { return reinterpret_cast<XrPlaneDetectorGetInfoEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPlaneDetectorGetInfoEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPlaneDetectorGetInfoEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PlaneDetectorGetInfoEXT{};next = oldNext;}
            return reinterpret_cast<XrPlaneDetectorGetInfoEXT*>(this);
        }
        Space baseSpace;
        Time time;
    };
     static_assert(sizeof(XrPlaneDetectorGetInfoEXT) == sizeof(PlaneDetectorGetInfoEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPlaneDetectorGetInfoEXT pointer to const from a PlaneDetectorGetInfoEXT reference to const.
 * @relates PlaneDetectorGetInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorGetInfoEXT const* get(PlaneDetectorGetInfoEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorGetInfoEXT as the address of a raw XrPlaneDetectorGetInfoEXT
 * @relates PlaneDetectorGetInfoEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorGetInfoEXT * put(PlaneDetectorGetInfoEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorLocationEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorLocationEXT>
 * @xrentity{XrPlaneDetectorLocationEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PlaneDetectorLocationEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 PlaneDetectorLocationEXT (
            void * next_ = nullptr)

: Parent(StructureType::PlaneDetectorLocationEXT
             , next_)
            {}

        //! Default copy constructor
        PlaneDetectorLocationEXT(const PlaneDetectorLocationEXT& rhs) = default;
        //! Default copy assignment
        PlaneDetectorLocationEXT& operator=(const PlaneDetectorLocationEXT& rhs) = default;
        //! Copy construct from raw
        PlaneDetectorLocationEXT(const XrPlaneDetectorLocationEXT& rhs) : PlaneDetectorLocationEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PlaneDetectorLocationEXT& operator=(const XrPlaneDetectorLocationEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPlaneDetectorLocationEXT &() const { return *reinterpret_cast<const XrPlaneDetectorLocationEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPlaneDetectorLocationEXT &() {
            return *reinterpret_cast<XrPlaneDetectorLocationEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrPlaneDetectorLocationEXT
        XrPlaneDetectorLocationEXT const* get() const noexcept { return reinterpret_cast<XrPlaneDetectorLocationEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPlaneDetectorLocationEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPlaneDetectorLocationEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PlaneDetectorLocationEXT{};next = oldNext;}
            return reinterpret_cast<XrPlaneDetectorLocationEXT*>(this);
        }
        uint64_t planeId;
        SpaceLocationFlags locationFlags;
        Posef pose;
        Extent2Df extents;
        PlaneDetectorOrientationEXT orientation;
        PlaneDetectorSemanticTypeEXT semanticType;
        uint32_t polygonBufferCount;
    };
     static_assert(sizeof(XrPlaneDetectorLocationEXT) == sizeof(PlaneDetectorLocationEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPlaneDetectorLocationEXT pointer to const from a PlaneDetectorLocationEXT reference to const.
 * @relates PlaneDetectorLocationEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorLocationEXT const* get(PlaneDetectorLocationEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorLocationEXT as the address of a raw XrPlaneDetectorLocationEXT
 * @relates PlaneDetectorLocationEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorLocationEXT * put(PlaneDetectorLocationEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorLocationsEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorLocationsEXT>
 * @xrentity{XrPlaneDetectorLocationsEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PlaneDetectorLocationsEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 PlaneDetectorLocationsEXT (
            void * next_ = nullptr)

: Parent(StructureType::PlaneDetectorLocationsEXT
             , next_)
            {}

        //! Default copy constructor
        PlaneDetectorLocationsEXT(const PlaneDetectorLocationsEXT& rhs) = default;
        //! Default copy assignment
        PlaneDetectorLocationsEXT& operator=(const PlaneDetectorLocationsEXT& rhs) = default;
        //! Copy construct from raw
        PlaneDetectorLocationsEXT(const XrPlaneDetectorLocationsEXT& rhs) : PlaneDetectorLocationsEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PlaneDetectorLocationsEXT& operator=(const XrPlaneDetectorLocationsEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPlaneDetectorLocationsEXT &() const { return *reinterpret_cast<const XrPlaneDetectorLocationsEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPlaneDetectorLocationsEXT &() {
            return *reinterpret_cast<XrPlaneDetectorLocationsEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrPlaneDetectorLocationsEXT
        XrPlaneDetectorLocationsEXT const* get() const noexcept { return reinterpret_cast<XrPlaneDetectorLocationsEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPlaneDetectorLocationsEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPlaneDetectorLocationsEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PlaneDetectorLocationsEXT{};next = oldNext;}
            return reinterpret_cast<XrPlaneDetectorLocationsEXT*>(this);
        }
        uint32_t planeLocationCapacityInput;
        uint32_t planeLocationCountOutput;
        PlaneDetectorLocationEXT* planeLocations;
    };
     static_assert(sizeof(XrPlaneDetectorLocationsEXT) == sizeof(PlaneDetectorLocationsEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPlaneDetectorLocationsEXT pointer to const from a PlaneDetectorLocationsEXT reference to const.
 * @relates PlaneDetectorLocationsEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorLocationsEXT const* get(PlaneDetectorLocationsEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorLocationsEXT as the address of a raw XrPlaneDetectorLocationsEXT
 * @relates PlaneDetectorLocationsEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorLocationsEXT * put(PlaneDetectorLocationsEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorPolygonBufferEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorPolygonBufferEXT>
 * @xrentity{XrPlaneDetectorPolygonBufferEXT}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS PlaneDetectorPolygonBufferEXT : public impl::OutputStructBase
    {
    private:
        using Parent = impl::OutputStructBase;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 PlaneDetectorPolygonBufferEXT (
            void * next_ = nullptr)

: Parent(StructureType::PlaneDetectorPolygonBufferEXT
             , next_)
            {}

        //! Default copy constructor
        PlaneDetectorPolygonBufferEXT(const PlaneDetectorPolygonBufferEXT& rhs) = default;
        //! Default copy assignment
        PlaneDetectorPolygonBufferEXT& operator=(const PlaneDetectorPolygonBufferEXT& rhs) = default;
        //! Copy construct from raw
        PlaneDetectorPolygonBufferEXT(const XrPlaneDetectorPolygonBufferEXT& rhs) : PlaneDetectorPolygonBufferEXT() {
            *put() = rhs;
        }
        //! Copy assign from raw
        PlaneDetectorPolygonBufferEXT& operator=(const XrPlaneDetectorPolygonBufferEXT& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrPlaneDetectorPolygonBufferEXT &() const { return *reinterpret_cast<const XrPlaneDetectorPolygonBufferEXT*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrPlaneDetectorPolygonBufferEXT &() {
            return *reinterpret_cast<XrPlaneDetectorPolygonBufferEXT*>(this);
        }

        //! Accessor for this as the address of a raw XrPlaneDetectorPolygonBufferEXT
        XrPlaneDetectorPolygonBufferEXT const* get() const noexcept { return reinterpret_cast<XrPlaneDetectorPolygonBufferEXT const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrPlaneDetectorPolygonBufferEXT.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrPlaneDetectorPolygonBufferEXT * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = PlaneDetectorPolygonBufferEXT{};next = oldNext;}
            return reinterpret_cast<XrPlaneDetectorPolygonBufferEXT*>(this);
        }
        uint32_t vertexCapacityInput;
        uint32_t vertexCountOutput;
        Vector2f* vertices;
    };
     static_assert(sizeof(XrPlaneDetectorPolygonBufferEXT) == sizeof(PlaneDetectorPolygonBufferEXT), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrPlaneDetectorPolygonBufferEXT pointer to const from a PlaneDetectorPolygonBufferEXT reference to const.
 * @relates PlaneDetectorPolygonBufferEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorPolygonBufferEXT const* get(PlaneDetectorPolygonBufferEXT const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorPolygonBufferEXT as the address of a raw XrPlaneDetectorPolygonBufferEXT
 * @relates PlaneDetectorPolygonBufferEXT
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrPlaneDetectorPolygonBufferEXT * put(PlaneDetectorPolygonBufferEXT &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_EXT_plane_detection































    #ifdef XR_ML_user_calibration
/*!
 * C++ projection of XrEventDataHeadsetFitChangedML
 * 
 * Provided by the `XR_ML_user_calibration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataHeadsetFitChangedML>
 * @xrentity{XrEventDataHeadsetFitChangedML}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataHeadsetFitChangedML : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataHeadsetFitChangedML (
            void * next_ = nullptr)

: Parent(StructureType::EventDataHeadsetFitChangedML
             , next_)
            {}

        //! Default copy constructor
        EventDataHeadsetFitChangedML(const EventDataHeadsetFitChangedML& rhs) = default;
        //! Default copy assignment
        EventDataHeadsetFitChangedML& operator=(const EventDataHeadsetFitChangedML& rhs) = default;
        //! Copy construct from raw
        EventDataHeadsetFitChangedML(const XrEventDataHeadsetFitChangedML& rhs) : EventDataHeadsetFitChangedML() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataHeadsetFitChangedML& operator=(const XrEventDataHeadsetFitChangedML& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataHeadsetFitChangedML &() const { return *reinterpret_cast<const XrEventDataHeadsetFitChangedML*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataHeadsetFitChangedML &() {
            return *reinterpret_cast<XrEventDataHeadsetFitChangedML*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataHeadsetFitChangedML
        XrEventDataHeadsetFitChangedML const* get() const noexcept { return reinterpret_cast<XrEventDataHeadsetFitChangedML const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataHeadsetFitChangedML.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataHeadsetFitChangedML * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataHeadsetFitChangedML{};next = oldNext;}
            return reinterpret_cast<XrEventDataHeadsetFitChangedML*>(this);
        }
        HeadsetFitStatusML status;
        Time time;
    };
     static_assert(sizeof(XrEventDataHeadsetFitChangedML) == sizeof(EventDataHeadsetFitChangedML), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataHeadsetFitChangedML pointer to const from a EventDataHeadsetFitChangedML reference to const.
 * @relates EventDataHeadsetFitChangedML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataHeadsetFitChangedML const* get(EventDataHeadsetFitChangedML const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataHeadsetFitChangedML as the address of a raw XrEventDataHeadsetFitChangedML
 * @relates EventDataHeadsetFitChangedML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataHeadsetFitChangedML * put(EventDataHeadsetFitChangedML &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataHeadsetFitChangedML as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataHeadsetFitChangedML
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataHeadsetFitChangedML const& h) {
        return h.get_base();
    }
#endif  // XR_ML_user_calibration































    #ifdef XR_ML_user_calibration
/*!
 * C++ projection of XrEventDataEyeCalibrationChangedML
 * 
 * Provided by the `XR_ML_user_calibration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataEyeCalibrationChangedML>
 * @xrentity{XrEventDataEyeCalibrationChangedML}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS EventDataEyeCalibrationChangedML : public EventDataBaseHeader
    {
    private:
        using Parent = EventDataBaseHeader;
    public:
        //! Empty constructor for a type that is marked as "returnonly"
                 EventDataEyeCalibrationChangedML (
            void * next_ = nullptr)

: Parent(StructureType::EventDataEyeCalibrationChangedML
             , next_)
            {}

        //! Default copy constructor
        EventDataEyeCalibrationChangedML(const EventDataEyeCalibrationChangedML& rhs) = default;
        //! Default copy assignment
        EventDataEyeCalibrationChangedML& operator=(const EventDataEyeCalibrationChangedML& rhs) = default;
        //! Copy construct from raw
        EventDataEyeCalibrationChangedML(const XrEventDataEyeCalibrationChangedML& rhs) : EventDataEyeCalibrationChangedML() {
            *put() = rhs;
        }
        //! Copy assign from raw
        EventDataEyeCalibrationChangedML& operator=(const XrEventDataEyeCalibrationChangedML& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrEventDataEyeCalibrationChangedML &() const { return *reinterpret_cast<const XrEventDataEyeCalibrationChangedML*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrEventDataEyeCalibrationChangedML &() {
            return *reinterpret_cast<XrEventDataEyeCalibrationChangedML*>(this);
        }

        //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
        XrEventDataBaseHeader const* get_base() const noexcept {
            return reinterpret_cast<XrEventDataBaseHeader const*>(this);
        }
        //! Accessor for this as the address of a raw XrEventDataEyeCalibrationChangedML
        XrEventDataEyeCalibrationChangedML const* get() const noexcept { return reinterpret_cast<XrEventDataEyeCalibrationChangedML const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrEventDataEyeCalibrationChangedML.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrEventDataEyeCalibrationChangedML * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = EventDataEyeCalibrationChangedML{};next = oldNext;}
            return reinterpret_cast<XrEventDataEyeCalibrationChangedML*>(this);
        }
        EyeCalibrationStatusML status;
    };
     static_assert(sizeof(XrEventDataEyeCalibrationChangedML) == sizeof(EventDataEyeCalibrationChangedML), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrEventDataEyeCalibrationChangedML pointer to const from a EventDataEyeCalibrationChangedML reference to const.
 * @relates EventDataEyeCalibrationChangedML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataEyeCalibrationChangedML const* get(EventDataEyeCalibrationChangedML const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataEyeCalibrationChangedML as the address of a raw XrEventDataEyeCalibrationChangedML
 * @relates EventDataEyeCalibrationChangedML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataEyeCalibrationChangedML * put(EventDataEyeCalibrationChangedML &s, bool clear = true) noexcept { return s.put(clear); }
/*!
 * @brief Free function accessor for a reference to const EventDataEyeCalibrationChangedML as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataEyeCalibrationChangedML
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataEyeCalibrationChangedML const& h) {
        return h.get_base();
    }
#endif  // XR_ML_user_calibration































    #ifdef XR_ML_user_calibration
/*!
 * C++ projection of XrUserCalibrationEnableEventsInfoML
 * 
 * Provided by the `XR_ML_user_calibration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUserCalibrationEnableEventsInfoML>
 * @xrentity{XrUserCalibrationEnableEventsInfoML}
 * @ingroup typedstructs
 */
    struct XR_MAY_ALIAS UserCalibrationEnableEventsInfoML : public impl::InputStructBase
    {
    private:
        using Parent = impl::InputStructBase;
    public:
        //! Constructor initializing all members.
                UserCalibrationEnableEventsInfoML (
 const Bool32& enabled_,  const void * next_ = nullptr                  )
: Parent(StructureType::UserCalibrationEnableEventsInfoML
, next_)
, enabled {enabled_}
        {
        }


        //! Default/empty constructor
                 UserCalibrationEnableEventsInfoML (
            const void * next_ = nullptr)

: Parent(StructureType::UserCalibrationEnableEventsInfoML
             , next_)
, enabled{false}
            {}

        //! Default copy constructor
        UserCalibrationEnableEventsInfoML(const UserCalibrationEnableEventsInfoML& rhs) = default;
        //! Default copy assignment
        UserCalibrationEnableEventsInfoML& operator=(const UserCalibrationEnableEventsInfoML& rhs) = default;
        //! Copy construct from raw
        UserCalibrationEnableEventsInfoML(const XrUserCalibrationEnableEventsInfoML& rhs) : UserCalibrationEnableEventsInfoML() {
            *put() = rhs;
        }
        //! Copy assign from raw
        UserCalibrationEnableEventsInfoML& operator=(const XrUserCalibrationEnableEventsInfoML& rhs) {
            if ((const void*) this == (const void *)&rhs) return *this;
            *put() = rhs;
            return *this;
        }
        //! Conversion operator to a reference to const of the original OpenXR type.
        operator const XrUserCalibrationEnableEventsInfoML &() const { return *reinterpret_cast<const XrUserCalibrationEnableEventsInfoML*>(this); }

        //! Conversion operator to a reference to the original OpenXR type.
        operator XrUserCalibrationEnableEventsInfoML &() {
            return *reinterpret_cast<XrUserCalibrationEnableEventsInfoML*>(this);
        }

        //! Accessor for this as the address of a raw XrUserCalibrationEnableEventsInfoML
        XrUserCalibrationEnableEventsInfoML const* get() const noexcept { return reinterpret_cast<XrUserCalibrationEnableEventsInfoML const *>(this); }

/*!
 * @brief Accessor for clearing and passing this as the address of a raw XrUserCalibrationEnableEventsInfoML.
 * 
 * Only the value of `next` is preserved by default. Pass false for the optional argument to skip clearing.
 */
        XrUserCalibrationEnableEventsInfoML * put(bool clear = true) noexcept {
            if (clear) {auto oldNext = next;*this = UserCalibrationEnableEventsInfoML{};next = oldNext;}
            return reinterpret_cast<XrUserCalibrationEnableEventsInfoML*>(this);
        }
        Bool32 enabled;
    };
     static_assert(sizeof(XrUserCalibrationEnableEventsInfoML) == sizeof(UserCalibrationEnableEventsInfoML), "Original type and wrapper have different size!"); 

/*!
 * @brief Free function for getting a raw XrUserCalibrationEnableEventsInfoML pointer to const from a UserCalibrationEnableEventsInfoML reference to const.
 * @relates UserCalibrationEnableEventsInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrUserCalibrationEnableEventsInfoML const* get(UserCalibrationEnableEventsInfoML const& s) {
        return s.get();
    }

/*!
 * @brief Free function accessor for clearing (by default) and passing UserCalibrationEnableEventsInfoML as the address of a raw XrUserCalibrationEnableEventsInfoML
 * @relates UserCalibrationEnableEventsInfoML
 * @ingroup utility_accessors
 */
    static OPENXR_HPP_INLINE XrUserCalibrationEnableEventsInfoML * put(UserCalibrationEnableEventsInfoML &s, bool clear = true) noexcept { return s.put(clear); }
#endif  // XR_ML_user_calibration
}  // namespace OPENXR_HPP_NAMESPACE
































#endif  // ifndef OPENXR_STRUCTS_HPP_

