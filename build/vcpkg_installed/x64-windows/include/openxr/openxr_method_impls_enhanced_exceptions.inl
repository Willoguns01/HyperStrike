// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************
































/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_METHOD_IMPLS_ENHANCED_EXCEPTIONS_INL_
#define OPENXR_METHOD_IMPLS_ENHANCED_EXCEPTIONS_INL_
/*!
 * @file
 * @brief Inline implementations - include @ref openxr_method_impls.hpp instead!
 *
 * Contains inline implementations of "enhanced mode" method wrappers whose signature is only available when exceptions are permitted.
 */


#ifdef OPENXR_HPP_DOXYGEN































#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#include "openxr_handles.hpp"
#endif

#ifndef OPENXR_HANDLES_HPP_
#error "This is not meant to be included on its own."
#endif

#if !defined(OPENXR_HPP_DISABLE_ENHANCED_MODE) && !defined(OPENXR_HPP_NO_EXCEPTIONS)

namespace OPENXR_HPP_NAMESPACE {



































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::getInstanceProcAddr (
    const char* name, PFN_xrVoidFunction* function, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetInstanceProcAddr(this->get(), name, function) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getInstanceProcAddr");
    }


    return;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector (
    Dispatch&& d)  {
    std::vector<ApiLayerProperties, Allocator> properties;
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return properties;
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrApiLayerProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return properties;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector (
    Allocator const& vectorAllocator, Dispatch&& d)  {
    std::vector<ApiLayerProperties, Allocator> properties{vectorAllocator};
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return properties;
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrApiLayerProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return properties;

}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector (
    const char* layerName, Dispatch&& d)  {
    std::vector<ExtensionProperties, Allocator> properties;
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return properties;
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrExtensionProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return properties;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector (
    const char* layerName, Allocator const& vectorAllocator, Dispatch&& d)  {
    std::vector<ExtensionProperties, Allocator> properties{vectorAllocator};
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return properties;
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrExtensionProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return properties;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Instance createInstance (
    const InstanceCreateInfo& createInfo, Dispatch&& d)  {
    Instance handle;
    Result result = static_cast<Result>( d.xrCreateInstance(createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::createInstance");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>> createInstanceUnique (
    const InstanceCreateInfo& createInfo, Dispatch&& d)  {
    Instance handle;
    Result result = static_cast<Result>( d.xrCreateInstance(createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::createInstanceUnique");
    }


    return UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyInstance(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::destroy");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE InstanceProperties Instance::getInstanceProperties (
    Dispatch&& d) const {
    InstanceProperties instanceProperties;
    Result result = static_cast<Result>( d.xrGetInstanceProperties(this->get(), OPENXR_HPP_NAMESPACE::put(instanceProperties)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getInstanceProperties");
    }


    return instanceProperties;
}





#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::resultToString (
    Result value, char buffer[XR_MAX_RESULT_STRING_SIZE], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrResultToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::resultToString");
    }


    return;
}


#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS




#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::structureTypeToString (
    StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrStructureTypeToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::structureTypeToString");
    }


    return;
}


#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS




































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SystemId Instance::getSystem (
    const SystemGetInfo& getInfo, Dispatch&& d) const {
    SystemId systemId;
    Result result = static_cast<Result>( d.xrGetSystem(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(systemId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getSystem");
    }


    return systemId;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SystemProperties Instance::getSystemProperties (
    SystemId systemId, Dispatch&& d) const {
    SystemProperties properties;
    Result result = static_cast<Result>( d.xrGetSystemProperties(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(properties)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getSystemProperties");
    }


    return properties;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<EnvironmentBlendMode, Allocator> Instance::enumerateEnvironmentBlendModesToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes;
        uint32_t environmentBlendModeCountOutput = 0;
    uint32_t environmentBlendModeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return environmentBlendModes;
    }
    do {
        environmentBlendModes.resize(environmentBlendModeCountOutput);
        environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
        result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
        environmentBlendModes.resize(environmentBlendModeCountOutput);
    } else environmentBlendModes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return environmentBlendModes;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<EnvironmentBlendMode, Allocator> Instance::enumerateEnvironmentBlendModesToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes{vectorAllocator};
        uint32_t environmentBlendModeCountOutput = 0;
    uint32_t environmentBlendModeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return environmentBlendModes;
    }
    do {
        environmentBlendModes.resize(environmentBlendModeCountOutput);
        environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
        result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
        environmentBlendModes.resize(environmentBlendModeCountOutput);
    } else environmentBlendModes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return environmentBlendModes;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Session Instance::createSession (
    const SessionCreateInfo& createInfo, Dispatch&& d) const {
    Session handle;
    Result result = static_cast<Result>( d.xrCreateSession(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createSession");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Session, impl::RemoveRefConst<Dispatch>> Instance::createSessionUnique (
    const SessionCreateInfo& createInfo, Dispatch&& d) const {
    Session handle;
    Result result = static_cast<Result>( d.xrCreateSession(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createSessionUnique");
    }


    return UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySession(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::destroy");
    }


    return;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReferenceSpaceType, Allocator> Session::enumerateReferenceSpacesToVector (
    Dispatch&& d) const {
    std::vector<ReferenceSpaceType, Allocator> spaces;
        uint32_t spaceCountOutput = 0;
    uint32_t spaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return spaces;
    }
    do {
        spaces.resize(spaceCountOutput);
        spaceCapacityInput = static_cast<uint32_t>(spaces.size());
        result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, reinterpret_cast<XrReferenceSpaceType*>(spaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
        spaces.resize(spaceCountOutput);
    } else spaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return spaces;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReferenceSpaceType, Allocator> Session::enumerateReferenceSpacesToVector (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ReferenceSpaceType, Allocator> spaces{vectorAllocator};
        uint32_t spaceCountOutput = 0;
    uint32_t spaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return spaces;
    }
    do {
        spaces.resize(spaceCountOutput);
        spaceCapacityInput = static_cast<uint32_t>(spaces.size());
        result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, reinterpret_cast<XrReferenceSpaceType*>(spaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
        spaces.resize(spaceCountOutput);
    } else spaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return spaces;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createReferenceSpace (
    const ReferenceSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createReferenceSpace");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createReferenceSpaceUnique (
    const ReferenceSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createReferenceSpaceUnique");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createActionSpace (
    const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createActionSpace");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createActionSpaceUnique (
    const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createActionSpaceUnique");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceLocation Space::locateSpace (
    Space baseSpace, Time time, Dispatch&& d) const {
    SpaceLocation location;
    Result result = static_cast<Result>( d.xrLocateSpace(this->get(), baseSpace.get(), time.get(), OPENXR_HPP_NAMESPACE::put(location)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::locateSpace");
    }


    return location;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Space::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySpace(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::destroy");
    }


    return;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationType, Allocator> Instance::enumerateViewConfigurationsToVector (
    SystemId systemId, Dispatch&& d) const {
    std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes;
        uint32_t viewConfigurationTypeCountOutput = 0;
    uint32_t viewConfigurationTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return viewConfigurationTypes;
    }
    do {
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
        viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    } else viewConfigurationTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return viewConfigurationTypes;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationType, Allocator> Instance::enumerateViewConfigurationsToVector (
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes{vectorAllocator};
        uint32_t viewConfigurationTypeCountOutput = 0;
    uint32_t viewConfigurationTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return viewConfigurationTypes;
    }
    do {
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
        viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    } else viewConfigurationTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return viewConfigurationTypes;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ViewConfigurationProperties Instance::getViewConfigurationProperties (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    ViewConfigurationProperties configurationProperties;
    Result result = static_cast<Result>( d.xrGetViewConfigurationProperties(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), OPENXR_HPP_NAMESPACE::put(configurationProperties)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getViewConfigurationProperties");
    }


    return configurationProperties;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationView, Allocator> Instance::enumerateViewConfigurationViewsToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    std::vector<ViewConfigurationView, Allocator> views;
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return views;
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, reinterpret_cast<XrViewConfigurationView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return views;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViewConfigurationView, Allocator> Instance::enumerateViewConfigurationViewsToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ViewConfigurationView, Allocator> views{vectorAllocator};
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return views;
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, reinterpret_cast<XrViewConfigurationView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return views;

}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<int64_t, Allocator> Session::enumerateSwapchainFormatsToVector (
    Dispatch&& d) const {
    std::vector<int64_t, Allocator> formats;
        uint32_t formatCountOutput = 0;
    uint32_t formatCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return formats;
    }
    do {
        formats.resize(formatCountOutput);
        formatCapacityInput = static_cast<uint32_t>(formats.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, reinterpret_cast<int64_t*>(formats.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
        formats.resize(formatCountOutput);
    } else formats.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return formats;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<int64_t, Allocator> Session::enumerateSwapchainFormatsToVector (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<int64_t, Allocator> formats{vectorAllocator};
        uint32_t formatCountOutput = 0;
    uint32_t formatCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return formats;
    }
    do {
        formats.resize(formatCountOutput);
        formatCapacityInput = static_cast<uint32_t>(formats.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, reinterpret_cast<int64_t*>(formats.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
        formats.resize(formatCountOutput);
    } else formats.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return formats;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Swapchain Session::createSwapchain (
    const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchain");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> Session::createSwapchainUnique (
    const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchainUnique");
    }


    return UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Swapchain::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySwapchain(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::destroy");
    }


    return;
}





































template <typename ResultItemType, typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ResultItemType, Allocator> Swapchain::enumerateSwapchainImagesToVector (
    Dispatch&& d) const {
    std::vector<ResultItemType, Allocator> images;
        uint32_t imageCountOutput = 0;
    uint32_t imageCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return images;
    }
    do {
        images.resize(imageCountOutput);
        imageCapacityInput = static_cast<uint32_t>(images.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
        images.resize(imageCountOutput);
    } else images.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return images;

}

template <typename ResultItemType, typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ResultItemType, Allocator> Swapchain::enumerateSwapchainImagesToVector (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ResultItemType, Allocator> images{vectorAllocator};
        uint32_t imageCountOutput = 0;
    uint32_t imageCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return images;
    }
    do {
        images.resize(imageCountOutput);
        imageCapacityInput = static_cast<uint32_t>(images.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
        images.resize(imageCountOutput);
    } else images.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return images;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE uint32_t Swapchain::acquireSwapchainImage (
    const SwapchainImageAcquireInfo& acquireInfo, Dispatch&& d) const {
    uint32_t index;
    Result result = static_cast<Result>( d.xrAcquireSwapchainImage(this->get(), acquireInfo.get(), &index) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::acquireSwapchainImage");
    }


    return index;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Swapchain::releaseSwapchainImage (
    const SwapchainImageReleaseInfo& releaseInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrReleaseSwapchainImage(this->get(), releaseInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::releaseSwapchainImage");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::beginSession (
    const SessionBeginInfo& beginInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrBeginSession(this->get(), beginInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::beginSession");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::endSession (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrEndSession(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::endSession");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::requestExitSession (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrRequestExitSession(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::requestExitSession");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FrameState Session::waitFrame (
    const FrameWaitInfo& frameWaitInfo, Dispatch&& d) const {
    FrameState frameState;
    Result result = static_cast<Result>( d.xrWaitFrame(this->get(), frameWaitInfo.get(), OPENXR_HPP_NAMESPACE::put(frameState)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::waitFrame");
    }


    return frameState;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::endFrame (
    const FrameEndInfo& frameEndInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrEndFrame(this->get(), frameEndInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::endFrame");
    }


    return;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<View, Allocator> Session::locateViewsToVector (
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Dispatch&& d) const {
    std::vector<View, Allocator> views;
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return views;
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, reinterpret_cast<XrView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return views;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<View, Allocator> Session::locateViewsToVector (
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<View, Allocator> views{vectorAllocator};
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return views;
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, reinterpret_cast<XrView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return views;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Path Instance::stringToPath (
    const char* pathString, Dispatch&& d) const {
    Path path;
    Result result = static_cast<Result>( d.xrStringToPath(this->get(), pathString, OPENXR_HPP_NAMESPACE::put(path)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::stringToPath");
    }


    return path;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::pathToString (
    Path path, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::pathToString (
    Path path, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionSet Instance::createActionSet (
    const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
    ActionSet handle;
    Result result = static_cast<Result>( d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createActionSet");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>> Instance::createActionSetUnique (
    const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
    ActionSet handle;
    Result result = static_cast<Result>( d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createActionSetUnique");
    }


    return UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void ActionSet::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyActionSet(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::ActionSet::destroy");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Action ActionSet::createAction (
    const ActionCreateInfo& createInfo, Dispatch&& d) const {
    Action handle;
    Result result = static_cast<Result>( d.xrCreateAction(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::ActionSet::createAction");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Action, impl::RemoveRefConst<Dispatch>> ActionSet::createActionUnique (
    const ActionCreateInfo& createInfo, Dispatch&& d) const {
    Action handle;
    Result result = static_cast<Result>( d.xrCreateAction(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::ActionSet::createActionUnique");
    }


    return UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Action::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyAction(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Action::destroy");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::suggestInteractionProfileBindings (
    const InteractionProfileSuggestedBinding& suggestedBindings, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSuggestInteractionProfileBindings(this->get(), suggestedBindings.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::suggestInteractionProfileBindings");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::attachSessionActionSets (
    const SessionActionSetsAttachInfo& attachInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrAttachSessionActionSets(this->get(), attachInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::attachSessionActionSets");
    }


    return;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE InteractionProfileState Session::getCurrentInteractionProfile (
    Path topLevelUserPath, Dispatch&& d) const {
    InteractionProfileState interactionProfile;
    Result result = static_cast<Result>( d.xrGetCurrentInteractionProfile(this->get(), topLevelUserPath.get(), OPENXR_HPP_NAMESPACE::put(interactionProfile)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getCurrentInteractionProfile");
    }


    return interactionProfile;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStateBoolean Session::getActionStateBoolean (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStateBoolean state;
    Result result = static_cast<Result>( d.xrGetActionStateBoolean(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStateBoolean");
    }


    return state;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStateFloat Session::getActionStateFloat (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStateFloat state;
    Result result = static_cast<Result>( d.xrGetActionStateFloat(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStateFloat");
    }


    return state;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStateVector2f Session::getActionStateVector2f (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStateVector2f state;
    Result result = static_cast<Result>( d.xrGetActionStateVector2f(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStateVector2f");
    }


    return state;
}





































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ActionStatePose Session::getActionStatePose (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStatePose state;
    Result result = static_cast<Result>( d.xrGetActionStatePose(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getActionStatePose");
    }


    return state;
}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<Path, Allocator> Session::enumerateBoundSourcesForActionToVector (
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Dispatch&& d) const {
    std::vector<Path, Allocator> sources;
        uint32_t sourceCountOutput = 0;
    uint32_t sourceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return sources;
    }
    do {
        sources.resize(sourceCountOutput);
        sourceCapacityInput = static_cast<uint32_t>(sources.size());
        result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, reinterpret_cast<XrPath*>(sources.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
        sources.resize(sourceCountOutput);
    } else sources.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return sources;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<Path, Allocator> Session::enumerateBoundSourcesForActionToVector (
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<Path, Allocator> sources{vectorAllocator};
        uint32_t sourceCountOutput = 0;
    uint32_t sourceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return sources;
    }
    do {
        sources.resize(sourceCountOutput);
        sourceCapacityInput = static_cast<uint32_t>(sources.size());
        result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, reinterpret_cast<XrPath*>(sources.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
        sources.resize(sourceCountOutput);
    } else sources.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return sources;

}





































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Session::getInputSourceLocalizedName (
    const InputSourceLocalizedNameGetInfo& getInfo, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Session::getInputSourceLocalizedName (
    const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}



#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setAndroidApplicationThreadKHR (
    AndroidThreadTypeKHR threadType, uint32_t threadId, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetAndroidApplicationThreadKHR(this->get(), OPENXR_HPP_NAMESPACE::get(threadType), threadId) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setAndroidApplicationThreadKHR");
    }


    return;
}


#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings
#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Swapchain Session::createSwapchainAndroidSurfaceKHR (
    const SwapchainCreateInfo& info, jobject* surface, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchainAndroidSurfaceKHR");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> Session::createSwapchainAndroidSurfaceUniqueKHR (
    const SwapchainCreateInfo& info, jobject* surface, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSwapchainAndroidSurfaceUniqueKHR");
    }


    return UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain
#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsOpenGLKHR Instance::getOpenGLGraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsOpenGLKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetOpenGLGraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getOpenGLGraphicsRequirementsKHR");
    }


    return graphicsRequirements;
}


#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsOpenGLESKHR Instance::getOpenGLESGraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsOpenGLESKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetOpenGLESGraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getOpenGLESGraphicsRequirementsKHR");
    }


    return graphicsRequirements;
}


#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanInstanceExtensionsKHR (
    SystemId systemId, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanInstanceExtensionsKHR (
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanDeviceExtensionsKHR (
    SystemId systemId, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE string_with_allocator<Allocator> Instance::getVulkanDeviceExtensionsKHR (
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return str;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return str;

}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VkPhysicalDevice Instance::getVulkanGraphicsDeviceKHR (
    SystemId systemId, VkInstance vkInstance, Dispatch&& d) const {
    VkPhysicalDevice vkPhysicalDevice;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsDeviceKHR(this->get(), systemId.get(), vkInstance, &vkPhysicalDevice) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsDeviceKHR");
    }


    return vkPhysicalDevice;
}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsVulkanKHR Instance::getVulkanGraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsVulkanKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsRequirementsKHR");
    }


    return graphicsRequirements;
}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsD3D11KHR Instance::getD3D11GraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsD3D11KHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetD3D11GraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getD3D11GraphicsRequirementsKHR");
    }


    return graphicsRequirements;
}


#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsD3D12KHR Instance::getD3D12GraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsD3D12KHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetD3D12GraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getD3D12GraphicsRequirementsKHR");
    }


    return graphicsRequirements;
}


#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_visibility_mask

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VisibilityMaskKHR Session::getVisibilityMaskKHR (
    ViewConfigurationType viewConfigurationType, uint32_t viewIndex, VisibilityMaskTypeKHR visibilityMaskType, Dispatch&& d) const {
    VisibilityMaskKHR visibilityMask;
    Result result = static_cast<Result>( d.xrGetVisibilityMaskKHR(this->get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewIndex, OPENXR_HPP_NAMESPACE::get(visibilityMaskType), OPENXR_HPP_NAMESPACE::put(visibilityMask)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getVisibilityMaskKHR");
    }


    return visibilityMask;
}


#endif  // XR_KHR_visibility_mask
#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Time Instance::convertWin32PerformanceCounterToTimeKHR (
    const LARGE_INTEGER* performanceCounter, Dispatch&& d) const {
    Time time;
    Result result = static_cast<Result>( d.xrConvertWin32PerformanceCounterToTimeKHR(this->get(), performanceCounter, OPENXR_HPP_NAMESPACE::put(time)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertWin32PerformanceCounterToTimeKHR");
    }


    return time;
}


#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time
#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE LARGE_INTEGER Instance::convertTimeToWin32PerformanceCounterKHR (
    Time time, Dispatch&& d) const {
    LARGE_INTEGER performanceCounter;
    Result result = static_cast<Result>( d.xrConvertTimeToWin32PerformanceCounterKHR(this->get(), time.get(), &performanceCounter) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertTimeToWin32PerformanceCounterKHR");
    }


    return performanceCounter;
}


#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time
#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Time Instance::convertTimespecTimeToTimeKHR (
    const struct timespec* timespecTime, Dispatch&& d) const {
    Time time;
    Result result = static_cast<Result>( d.xrConvertTimespecTimeToTimeKHR(this->get(), timespecTime, OPENXR_HPP_NAMESPACE::put(time)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertTimespecTimeToTimeKHR");
    }


    return time;
}


#endif // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time
#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE timespec Instance::convertTimeToTimespecTimeKHR (
    Time time, Dispatch&& d) const {
    timespec timespecTime;
    Result result = static_cast<Result>( d.xrConvertTimeToTimespecTimeKHR(this->get(), time.get(), &timespecTime) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::convertTimeToTimespecTimeKHR");
    }


    return timespecTime;
}


#endif // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time
#ifdef XR_KHR_loader_init

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void initializeLoaderKHR (
    const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo, Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrInitializeLoaderKHR(loaderInitInfo) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::initializeLoaderKHR");
    }


    return;
}


#endif  // XR_KHR_loader_init
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::createVulkanInstanceKHR (
    const VulkanInstanceCreateInfoKHR& createInfo, VkInstance* vulkanInstance, VkResult* vulkanResult, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrCreateVulkanInstanceKHR(this->get(), createInfo.get(), vulkanInstance, vulkanResult) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createVulkanInstanceKHR");
    }


    return;
}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::createVulkanDeviceKHR (
    const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice, VkResult* vulkanResult, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrCreateVulkanDeviceKHR(this->get(), createInfo.get(), vulkanDevice, vulkanResult) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createVulkanDeviceKHR");
    }


    return;
}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VkPhysicalDevice Instance::getVulkanGraphicsDevice2KHR (
    const VulkanGraphicsDeviceGetInfoKHR& getInfo, Dispatch&& d) const {
    VkPhysicalDevice vulkanPhysicalDevice;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsDevice2KHR(this->get(), getInfo.get(), &vulkanPhysicalDevice) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsDevice2KHR");
    }


    return vulkanPhysicalDevice;
}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GraphicsRequirementsVulkanKHR Instance::getVulkanGraphicsRequirements2KHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsVulkanKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsRequirements2KHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getVulkanGraphicsRequirements2KHR");
    }


    return graphicsRequirements;
}


#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_EXT_performance_settings

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::perfSettingsSetPerformanceLevelEXT (
    PerfSettingsDomainEXT domain, PerfSettingsLevelEXT level, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPerfSettingsSetPerformanceLevelEXT(this->get(), OPENXR_HPP_NAMESPACE::get(domain), OPENXR_HPP_NAMESPACE::get(level)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::perfSettingsSetPerformanceLevelEXT");
    }


    return;
}


#endif  // XR_EXT_performance_settings
#ifdef XR_EXT_thermal_query

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::thermalGetTemperatureTrendEXT (
    PerfSettingsDomainEXT domain, PerfSettingsNotificationLevelEXT& notificationLevel, float* tempHeadroom, float* tempSlope, Dispatch&& d) const {
    XrPerfSettingsNotificationLevelEXT notificationLevel_tmp;
    Result result = static_cast<Result>( d.xrThermalGetTemperatureTrendEXT(this->get(), OPENXR_HPP_NAMESPACE::get(domain), &notificationLevel_tmp, tempHeadroom, tempSlope) );
    notificationLevel = static_cast<PerfSettingsNotificationLevelEXT>(notificationLevel_tmp);
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::thermalGetTemperatureTrendEXT");
    }


    return;
}


#endif  // XR_EXT_thermal_query
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::setDebugUtilsObjectNameEXT (
    const DebugUtilsObjectNameInfoEXT& nameInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetDebugUtilsObjectNameEXT(this->get(), nameInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::setDebugUtilsObjectNameEXT");
    }


    return;
}


#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE DebugUtilsMessengerEXT Instance::createDebugUtilsMessengerEXT (
    const DebugUtilsMessengerCreateInfoEXT& createInfo, Dispatch&& d) const {
    DebugUtilsMessengerEXT handle;
    Result result = static_cast<Result>( d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createDebugUtilsMessengerEXT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>> Instance::createDebugUtilsMessengerUniqueEXT (
    const DebugUtilsMessengerCreateInfoEXT& createInfo, Dispatch&& d) const {
    DebugUtilsMessengerEXT handle;
    Result result = static_cast<Result>( d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::createDebugUtilsMessengerUniqueEXT");
    }


    return UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void DebugUtilsMessengerEXT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyDebugUtilsMessengerEXT(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::DebugUtilsMessengerEXT::destroy");
    }


    return;
}


#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::submitDebugUtilsMessageEXT (
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity, XrDebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT& callbackData, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSubmitDebugUtilsMessageEXT(this->get(), messageSeverity, messageTypes, callbackData.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::submitDebugUtilsMessageEXT");
    }


    return;
}


#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::sessionBeginDebugUtilsLabelRegionEXT (
    const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSessionBeginDebugUtilsLabelRegionEXT(this->get(), labelInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::sessionBeginDebugUtilsLabelRegionEXT");
    }


    return;
}


#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::sessionEndDebugUtilsLabelRegionEXT (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSessionEndDebugUtilsLabelRegionEXT(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::sessionEndDebugUtilsLabelRegionEXT");
    }


    return;
}


#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::sessionInsertDebugUtilsLabelEXT (
    const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSessionInsertDebugUtilsLabelEXT(this->get(), labelInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::sessionInsertDebugUtilsLabelEXT");
    }


    return;
}


#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpatialAnchorMSFT Session::createSpatialAnchorMSFT (
    const SpatialAnchorCreateInfoMSFT& createInfo, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorMSFT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>> Session::createSpatialAnchorUniqueMSFT (
    const SpatialAnchorCreateInfoMSFT& createInfo, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorUniqueMSFT");
    }


    return UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createSpatialAnchorSpaceMSFT (
    const SpatialAnchorSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorSpaceMSFT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createSpatialAnchorSpaceUniqueMSFT (
    const SpatialAnchorSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorSpaceUniqueMSFT");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpatialAnchorMSFT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySpatialAnchorMSFT(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::SpatialAnchorMSFT::destroy");
    }


    return;
}


#endif  // XR_MSFT_spatial_anchor
#ifdef XR_EXT_conformance_automation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceActiveEXT (
    Path interactionProfile, Path topLevelPath, XrBool32 isActive, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceActiveEXT(this->get(), interactionProfile.get(), topLevelPath.get(), isActive) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceActiveEXT");
    }


    return;
}


#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceStateBoolEXT (
    Path topLevelPath, Path inputSourcePath, XrBool32 state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceStateBoolEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), state) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceStateBoolEXT");
    }


    return;
}


#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceStateFloatEXT (
    Path topLevelPath, Path inputSourcePath, float state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceStateFloatEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), state) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceStateFloatEXT");
    }


    return;
}


#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceStateVector2fEXT (
    Path topLevelPath, Path inputSourcePath, XrVector2f state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceStateVector2fEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), state) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceStateVector2fEXT");
    }


    return;
}


#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_conformance_automation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setInputDeviceLocationEXT (
    Path topLevelPath, Path inputSourcePath, Space space, XrPosef pose, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceLocationEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), space.get(), pose) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setInputDeviceLocationEXT");
    }


    return;
}


#endif  // XR_EXT_conformance_automation
#ifdef XR_EXT_hand_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandTrackerEXT Session::createHandTrackerEXT (
    const HandTrackerCreateInfoEXT& createInfo, Dispatch&& d) const {
    HandTrackerEXT handle;
    Result result = static_cast<Result>( d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createHandTrackerEXT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>> Session::createHandTrackerUniqueEXT (
    const HandTrackerCreateInfoEXT& createInfo, Dispatch&& d) const {
    HandTrackerEXT handle;
    Result result = static_cast<Result>( d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createHandTrackerUniqueEXT");
    }


    return UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void HandTrackerEXT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyHandTrackerEXT(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::destroy");
    }


    return;
}


#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandJointLocationsEXT HandTrackerEXT::locateHandJointsEXT (
    const HandJointsLocateInfoEXT& locateInfo, Dispatch&& d) const {
    HandJointLocationsEXT locations;
    Result result = static_cast<Result>( d.xrLocateHandJointsEXT(this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(locations)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::locateHandJointsEXT");
    }


    return locations;
}


#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_hand_tracking_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space HandTrackerEXT::createHandMeshSpaceMSFT (
    const HandMeshSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::createHandMeshSpaceMSFT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> HandTrackerEXT::createHandMeshSpaceUniqueMSFT (
    const HandMeshSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::createHandMeshSpaceUniqueMSFT");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandMeshMSFT HandTrackerEXT::updateHandMeshMSFT (
    const HandMeshUpdateInfoMSFT& updateInfo, Dispatch&& d) const {
    HandMeshMSFT handMesh;
    Result result = static_cast<Result>( d.xrUpdateHandMeshMSFT(this->get(), updateInfo.get(), OPENXR_HPP_NAMESPACE::put(handMesh)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::updateHandMeshMSFT");
    }


    return handMesh;
}


#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpatialAnchorMSFT Session::createSpatialAnchorFromPerceptionAnchorMSFT (
    IUnknown* perceptionAnchor, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorFromPerceptionAnchorMSFT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>> Session::createSpatialAnchorFromPerceptionAnchorUniqueMSFT (
    IUnknown* perceptionAnchor, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorFromPerceptionAnchorUniqueMSFT");
    }


    return UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop
#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::tryGetPerceptionAnchorFromSpatialAnchorMSFT (
    SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(this->get(), anchor.get(), perceptionAnchor) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::tryGetPerceptionAnchorFromSpatialAnchorMSFT");
    }


    return;
}


#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop
#ifdef XR_MSFT_composition_layer_reprojection

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReprojectionModeMSFT, Allocator> Instance::enumerateReprojectionModesToVectorMSFT (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    std::vector<ReprojectionModeMSFT, Allocator> modes;
        uint32_t modeCountOutput = 0;
    uint32_t modeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return modes;
    }
    do {
        modes.resize(modeCountOutput);
        modeCapacityInput = static_cast<uint32_t>(modes.size());
        result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
        modes.resize(modeCountOutput);
    } else modes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return modes;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ReprojectionModeMSFT, Allocator> Instance::enumerateReprojectionModesToVectorMSFT (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ReprojectionModeMSFT, Allocator> modes{vectorAllocator};
        uint32_t modeCountOutput = 0;
    uint32_t modeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return modes;
    }
    do {
        modes.resize(modeCountOutput);
        modeCapacityInput = static_cast<uint32_t>(modes.size());
        result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
        modes.resize(modeCountOutput);
    } else modes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return modes;

}


#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_FB_swapchain_update_state

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Swapchain::updateSwapchainFB (
    const XrSwapchainStateBaseHeaderFB* state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrUpdateSwapchainFB(this->get(), state) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::updateSwapchainFB");
    }


    return;
}


#endif  // XR_FB_swapchain_update_state
#ifdef XR_FB_body_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE BodyTrackerFB Session::createBodyTrackerFB (
    const BodyTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    BodyTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateBodyTrackerFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createBodyTrackerFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<BodyTrackerFB, impl::RemoveRefConst<Dispatch>> Session::createBodyTrackerUniqueFB (
    const BodyTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    BodyTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateBodyTrackerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createBodyTrackerUniqueFB");
    }


    return UniqueHandle<BodyTrackerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void BodyTrackerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyBodyTrackerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::BodyTrackerFB::destroy");
    }


    return;
}


#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE BodyJointLocationsFB BodyTrackerFB::locateBodyJointsFB (
    const BodyJointsLocateInfoFB& locateInfo, Dispatch&& d) const {
    BodyJointLocationsFB locations;
    Result result = static_cast<Result>( d.xrLocateBodyJointsFB(this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(locations)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::BodyTrackerFB::locateBodyJointsFB");
    }


    return locations;
}


#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE BodySkeletonFB BodyTrackerFB::getBodySkeletonFB (
    Dispatch&& d) const {
    BodySkeletonFB skeleton;
    Result result = static_cast<Result>( d.xrGetBodySkeletonFB(this->get(), OPENXR_HPP_NAMESPACE::put(skeleton)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::BodyTrackerFB::getBodySkeletonFB");
    }


    return skeleton;
}


#endif  // XR_FB_body_tracking
#ifdef XR_FB_display_refresh_rate

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<float, Allocator> Session::enumerateDisplayRefreshRatesToVectorFB (
    Dispatch&& d) const {
    std::vector<float, Allocator> displayRefreshRates;
        uint32_t displayRefreshRateCountOutput = 0;
    uint32_t displayRefreshRateCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return displayRefreshRates;
    }
    do {
        displayRefreshRates.resize(displayRefreshRateCountOutput);
        displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
        result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, reinterpret_cast<float*>(displayRefreshRates.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
        displayRefreshRates.resize(displayRefreshRateCountOutput);
    } else displayRefreshRates.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return displayRefreshRates;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<float, Allocator> Session::enumerateDisplayRefreshRatesToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<float, Allocator> displayRefreshRates{vectorAllocator};
        uint32_t displayRefreshRateCountOutput = 0;
    uint32_t displayRefreshRateCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return displayRefreshRates;
    }
    do {
        displayRefreshRates.resize(displayRefreshRateCountOutput);
        displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
        result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, reinterpret_cast<float*>(displayRefreshRates.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
        displayRefreshRates.resize(displayRefreshRateCountOutput);
    } else displayRefreshRates.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return displayRefreshRates;

}


#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_display_refresh_rate

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE float Session::getDisplayRefreshRateFB (
    Dispatch&& d) const {
    float displayRefreshRate;
    Result result = static_cast<Result>( d.xrGetDisplayRefreshRateFB(this->get(), &displayRefreshRate) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getDisplayRefreshRateFB");
    }


    return displayRefreshRate;
}


#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_display_refresh_rate

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::requestDisplayRefreshRateFB (
    float displayRefreshRate, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrRequestDisplayRefreshRateFB(this->get(), displayRefreshRate) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::requestDisplayRefreshRateFB");
    }


    return;
}


#endif  // XR_FB_display_refresh_rate
#ifdef XR_HTCX_vive_tracker_interaction

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViveTrackerPathsHTCX, Allocator> Instance::enumerateViveTrackerPathsToVectorHTCX (
    Dispatch&& d) const {
    std::vector<ViveTrackerPathsHTCX, Allocator> paths;
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return paths;
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return paths;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ViveTrackerPathsHTCX, Allocator> Instance::enumerateViveTrackerPathsToVectorHTCX (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ViveTrackerPathsHTCX, Allocator> paths{vectorAllocator};
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return paths;
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return paths;

}


#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTC_facial_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FacialTrackerHTC Session::createFacialTrackerHTC (
    const FacialTrackerCreateInfoHTC& createInfo, Dispatch&& d) const {
    FacialTrackerHTC handle;
    Result result = static_cast<Result>( d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFacialTrackerHTC");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>> Session::createFacialTrackerUniqueHTC (
    const FacialTrackerCreateInfoHTC& createInfo, Dispatch&& d) const {
    FacialTrackerHTC handle;
    Result result = static_cast<Result>( d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFacialTrackerUniqueHTC");
    }


    return UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void FacialTrackerHTC::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyFacialTrackerHTC(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::FacialTrackerHTC::destroy");
    }


    return;
}


#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FacialExpressionsHTC FacialTrackerHTC::getFacialExpressionsHTC (
    Dispatch&& d) const {
    FacialExpressionsHTC facialExpressions;
    Result result = static_cast<Result>( d.xrGetFacialExpressionsHTC(this->get(), OPENXR_HPP_NAMESPACE::put(facialExpressions)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::FacialTrackerHTC::getFacialExpressionsHTC");
    }


    return facialExpressions;
}


#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_color_space

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ColorSpaceFB, Allocator> Session::enumerateColorSpacesToVectorFB (
    Dispatch&& d) const {
    std::vector<ColorSpaceFB, Allocator> colorSpaces;
        uint32_t colorSpaceCountOutput = 0;
    uint32_t colorSpaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return colorSpaces;
    }
    do {
        colorSpaces.resize(colorSpaceCountOutput);
        colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
        result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
        colorSpaces.resize(colorSpaceCountOutput);
    } else colorSpaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return colorSpaces;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ColorSpaceFB, Allocator> Session::enumerateColorSpacesToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ColorSpaceFB, Allocator> colorSpaces{vectorAllocator};
        uint32_t colorSpaceCountOutput = 0;
    uint32_t colorSpaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return colorSpaces;
    }
    do {
        colorSpaces.resize(colorSpaceCountOutput);
        colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
        result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
        colorSpaces.resize(colorSpaceCountOutput);
    } else colorSpaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return colorSpaces;

}


#endif  // XR_FB_color_space
#ifdef XR_FB_color_space

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setColorSpaceFB (
    ColorSpaceFB colorSpace, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetColorSpaceFB(this->get(), OPENXR_HPP_NAMESPACE::get(colorSpace)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setColorSpaceFB");
    }


    return;
}


#endif  // XR_FB_color_space
#ifdef XR_FB_hand_tracking_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE HandTrackingMeshFB HandTrackerEXT::getHandMeshFB (
    Dispatch&& d) const {
    HandTrackingMeshFB mesh;
    Result result = static_cast<Result>( d.xrGetHandMeshFB(this->get(), OPENXR_HPP_NAMESPACE::put(mesh)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::getHandMeshFB");
    }


    return mesh;
}


#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_spatial_entity

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::createSpatialAnchorFB (
    const SpatialAnchorCreateInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpatialAnchorFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UuidEXT Space::getSpaceUuidFB (
    Dispatch&& d) const {
    UuidEXT uuid;
    Result result = static_cast<Result>( d.xrGetSpaceUuidFB(this->get(), OPENXR_HPP_NAMESPACE::put(uuid)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::getSpaceUuidFB");
    }


    return uuid;
}


#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<SpaceComponentTypeFB, Allocator> Space::enumerateSpaceSupportedComponentsToVectorFB (
    Dispatch&& d) const {
    std::vector<SpaceComponentTypeFB, Allocator> componentTypes;
        uint32_t componentTypeCountOutput = 0;
    uint32_t componentTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || componentTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return componentTypes;
    }
    do {
        componentTypes.resize(componentTypeCountOutput);
        componentTypeCapacityInput = static_cast<uint32_t>(componentTypes.size());
        result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, reinterpret_cast<XrSpaceComponentTypeFB*>(componentTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(componentTypeCountOutput <= componentTypes.size());
        componentTypes.resize(componentTypeCountOutput);
    } else componentTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return componentTypes;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<SpaceComponentTypeFB, Allocator> Space::enumerateSpaceSupportedComponentsToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<SpaceComponentTypeFB, Allocator> componentTypes{vectorAllocator};
        uint32_t componentTypeCountOutput = 0;
    uint32_t componentTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || componentTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return componentTypes;
    }
    do {
        componentTypes.resize(componentTypeCountOutput);
        componentTypeCapacityInput = static_cast<uint32_t>(componentTypes.size());
        result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, reinterpret_cast<XrSpaceComponentTypeFB*>(componentTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(componentTypeCountOutput <= componentTypes.size());
        componentTypes.resize(componentTypeCountOutput);
    } else componentTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return componentTypes;

}


#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Space::setSpaceComponentStatusFB (
    const SpaceComponentStatusSetInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrSetSpaceComponentStatusFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::setSpaceComponentStatusFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceComponentStatusFB Space::getSpaceComponentStatusFB (
    SpaceComponentTypeFB componentType, Dispatch&& d) const {
    SpaceComponentStatusFB status;
    Result result = static_cast<Result>( d.xrGetSpaceComponentStatusFB(this->get(), OPENXR_HPP_NAMESPACE::get(componentType), OPENXR_HPP_NAMESPACE::put(status)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Space::getSpaceComponentStatusFB");
    }


    return status;
}


#endif  // XR_FB_spatial_entity
#ifdef XR_FB_foveation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FoveationProfileFB Session::createFoveationProfileFB (
    const FoveationProfileCreateInfoFB& createInfo, Dispatch&& d) const {
    FoveationProfileFB handle;
    Result result = static_cast<Result>( d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFoveationProfileFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>> Session::createFoveationProfileUniqueFB (
    const FoveationProfileCreateInfoFB& createInfo, Dispatch&& d) const {
    FoveationProfileFB handle;
    Result result = static_cast<Result>( d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFoveationProfileUniqueFB");
    }


    return UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_foveation
#ifdef XR_FB_foveation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void FoveationProfileFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyFoveationProfileFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::FoveationProfileFB::destroy");
    }


    return;
}


#endif  // XR_FB_foveation
#ifdef XR_FB_keyboard_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE KeyboardTrackingDescriptionFB Session::querySystemTrackedKeyboardFB (
    const KeyboardTrackingQueryFB& queryInfo, Dispatch&& d) const {
    KeyboardTrackingDescriptionFB keyboard;
    Result result = static_cast<Result>( d.xrQuerySystemTrackedKeyboardFB(this->get(), queryInfo.get(), OPENXR_HPP_NAMESPACE::put(keyboard)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::querySystemTrackedKeyboardFB");
    }


    return keyboard;
}


#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createKeyboardSpaceFB (
    const KeyboardSpaceCreateInfoFB& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createKeyboardSpaceFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createKeyboardSpaceUniqueFB (
    const KeyboardSpaceCreateInfoFB& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createKeyboardSpaceUniqueFB");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE TriangleMeshFB Session::createTriangleMeshFB (
    const TriangleMeshCreateInfoFB& createInfo, Dispatch&& d) const {
    TriangleMeshFB handle;
    Result result = static_cast<Result>( d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createTriangleMeshFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>> Session::createTriangleMeshUniqueFB (
    const TriangleMeshCreateInfoFB& createInfo, Dispatch&& d) const {
    TriangleMeshFB handle;
    Result result = static_cast<Result>( d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createTriangleMeshUniqueFB");
    }


    return UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyTriangleMeshFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::destroy");
    }


    return;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshGetVertexBufferFB (
    XrVector3f** outVertexBuffer, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshGetVertexBufferFB(this->get(), outVertexBuffer) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshGetVertexBufferFB");
    }


    return;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshGetIndexBufferFB (
    uint32_t** outIndexBuffer, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshGetIndexBufferFB(this->get(), outIndexBuffer) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshGetIndexBufferFB");
    }


    return;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshBeginUpdateFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshBeginUpdateFB(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshBeginUpdateFB");
    }


    return;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshEndUpdateFB (
    uint32_t vertexCount, uint32_t triangleCount, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshEndUpdateFB(this->get(), vertexCount, triangleCount) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshEndUpdateFB");
    }


    return;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE uint32_t TriangleMeshFB::triangleMeshBeginVertexBufferUpdateFB (
    Dispatch&& d) const {
    uint32_t outVertexCount;
    Result result = static_cast<Result>( d.xrTriangleMeshBeginVertexBufferUpdateFB(this->get(), &outVertexCount) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshBeginVertexBufferUpdateFB");
    }


    return outVertexCount;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_triangle_mesh

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void TriangleMeshFB::triangleMeshEndVertexBufferUpdateFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshEndVertexBufferUpdateFB(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::TriangleMeshFB::triangleMeshEndVertexBufferUpdateFB");
    }


    return;
}


#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughFB Session::createPassthroughFB (
    const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>> Session::createPassthroughUniqueFB (
    const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughUniqueFB");
    }


    return UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::destroy");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughFB::passthroughStartFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughStartFB(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::passthroughStartFB");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughFB::passthroughPauseFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughPauseFB(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::passthroughPauseFB");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughLayerFB Session::createPassthroughLayerFB (
    const PassthroughLayerCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughLayerFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughLayerFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>> Session::createPassthroughLayerUniqueFB (
    const PassthroughLayerCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughLayerFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughLayerUniqueFB");
    }


    return UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughLayerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::destroy");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerPauseFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerPauseFB(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerPauseFB");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerResumeFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerResumeFB(this->get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerResumeFB");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerSetStyleFB (
    const PassthroughStyleFB& style, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerSetStyleFB(this->get(), style.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerSetStyleFB");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE GeometryInstanceFB Session::createGeometryInstanceFB (
    const GeometryInstanceCreateInfoFB& createInfo, Dispatch&& d) const {
    GeometryInstanceFB handle;
    Result result = static_cast<Result>( d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createGeometryInstanceFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>> Session::createGeometryInstanceUniqueFB (
    const GeometryInstanceCreateInfoFB& createInfo, Dispatch&& d) const {
    GeometryInstanceFB handle;
    Result result = static_cast<Result>( d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createGeometryInstanceUniqueFB");
    }


    return UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void GeometryInstanceFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyGeometryInstanceFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::GeometryInstanceFB::destroy");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void GeometryInstanceFB::geometryInstanceSetTransformFB (
    const GeometryInstanceTransformFB& transformation, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGeometryInstanceSetTransformFB(this->get(), transformation.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::GeometryInstanceFB::geometryInstanceSetTransformFB");
    }


    return;
}


#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<RenderModelPathInfoFB, Allocator> Session::enumerateRenderModelPathsToVectorFB (
    Dispatch&& d) const {
    std::vector<RenderModelPathInfoFB, Allocator> paths;
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return paths;
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return paths;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<RenderModelPathInfoFB, Allocator> Session::enumerateRenderModelPathsToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<RenderModelPathInfoFB, Allocator> paths{vectorAllocator};
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return paths;
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return paths;

}


#endif  // XR_FB_render_model
#ifdef XR_VARJO_environment_depth_estimation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setEnvironmentDepthEstimationVARJO (
    XrBool32 enabled, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetEnvironmentDepthEstimationVARJO(this->get(), enabled) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setEnvironmentDepthEstimationVARJO");
    }


    return;
}


#endif  // XR_VARJO_environment_depth_estimation
#ifdef XR_VARJO_marker_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setMarkerTrackingVARJO (
    XrBool32 enabled, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetMarkerTrackingVARJO(this->get(), enabled) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setMarkerTrackingVARJO");
    }


    return;
}


#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setMarkerTrackingTimeoutVARJO (
    uint64_t markerId, Duration timeout, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetMarkerTrackingTimeoutVARJO(this->get(), markerId, timeout.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setMarkerTrackingTimeoutVARJO");
    }


    return;
}


#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setMarkerTrackingPredictionVARJO (
    uint64_t markerId, XrBool32 enable, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetMarkerTrackingPredictionVARJO(this->get(), markerId, enable) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setMarkerTrackingPredictionVARJO");
    }


    return;
}


#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Extent2Df Session::getMarkerSizeVARJO (
    uint64_t markerId, Dispatch&& d) const {
    Extent2Df size;
    Result result = static_cast<Result>( d.xrGetMarkerSizeVARJO(this->get(), markerId, OPENXR_HPP_NAMESPACE::put(size)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getMarkerSizeVARJO");
    }


    return size;
}


#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createMarkerSpaceVARJO (
    const MarkerSpaceCreateInfoVARJO& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createMarkerSpaceVARJO");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createMarkerSpaceUniqueVARJO (
    const MarkerSpaceCreateInfoVARJO& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createMarkerSpaceUniqueVARJO");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_view_offset

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setViewOffsetVARJO (
    float offset, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetViewOffsetVARJO(this->get(), offset) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setViewOffsetVARJO");
    }


    return;
}


#endif  // XR_VARJO_view_offset
#ifdef XR_ML_compat
#if defined(XR_USE_PLATFORM_ML)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createSpaceFromCoordinateFrameUIDML (
    const CoordinateSpaceCreateInfoML& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpaceFromCoordinateFrameUIDML(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpaceFromCoordinateFrameUIDML");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createSpaceFromCoordinateFrameUIDUniqueML (
    const CoordinateSpaceCreateInfoML& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpaceFromCoordinateFrameUIDML(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpaceFromCoordinateFrameUIDUniqueML");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif // defined(XR_USE_PLATFORM_ML)
#endif  // XR_ML_compat
#ifdef XR_MSFT_scene_marker

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<uint8_t, Allocator> SceneMSFT::getSceneMarkerRawDataToVectorMSFT (
    const UuidMSFT& markerId, Dispatch&& d) const {
    std::vector<uint8_t, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return buffer;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<uint8_t*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return buffer;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<uint8_t, Allocator> SceneMSFT::getSceneMarkerRawDataToVectorMSFT (
    const UuidMSFT& markerId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<uint8_t, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return buffer;
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<uint8_t*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return buffer;

}


#endif  // XR_MSFT_scene_marker
#ifdef XR_FB_spatial_entity_query

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::querySpacesFB (
    const XrSpaceQueryInfoBaseHeaderFB* info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrQuerySpacesFB(this->get(), info, OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::querySpacesFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceQueryResultsFB Session::retrieveSpaceQueryResultsFB (
    AsyncRequestIdFB requestId, Dispatch&& d) const {
    SpaceQueryResultsFB results;
    Result result = static_cast<Result>( d.xrRetrieveSpaceQueryResultsFB(this->get(), requestId.get(), OPENXR_HPP_NAMESPACE::put(results)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::retrieveSpaceQueryResultsFB");
    }


    return results;
}


#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_storage

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::saveSpaceFB (
    const SpaceSaveInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrSaveSpaceFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::saveSpaceFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::eraseSpaceFB (
    const SpaceEraseInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrEraseSpaceFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::eraseSpaceFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity_storage
#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::getAudioOutputDeviceGuidOculus (
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetAudioOutputDeviceGuidOculus(this->get(), buffer) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getAudioOutputDeviceGuidOculus");
    }


    return;
}


#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid
#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::getAudioInputDeviceGuidOculus (
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetAudioInputDeviceGuidOculus(this->get(), buffer) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::getAudioInputDeviceGuidOculus");
    }


    return;
}


#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid
#ifdef XR_FB_spatial_entity_sharing

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::shareSpacesFB (
    const SpaceShareInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrShareSpacesFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::shareSpacesFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_scene

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Rect2Df Session::getSpaceBoundingBox2DFB (
    Space space, Dispatch&& d) const {
    Rect2Df boundingBox2DOutput;
    Result result = static_cast<Result>( d.xrGetSpaceBoundingBox2DFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(boundingBox2DOutput)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getSpaceBoundingBox2DFB");
    }


    return boundingBox2DOutput;
}


#endif  // XR_FB_scene
#ifdef XR_FB_scene

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Rect3DfFB Session::getSpaceBoundingBox3DFB (
    Space space, Dispatch&& d) const {
    Rect3DfFB boundingBox3DOutput;
    Result result = static_cast<Result>( d.xrGetSpaceBoundingBox3DFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(boundingBox3DOutput)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getSpaceBoundingBox3DFB");
    }


    return boundingBox3DOutput;
}


#endif  // XR_FB_scene
#ifdef XR_FB_scene

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SemanticLabelsFB Session::getSpaceSemanticLabelsFB (
    Space space, Dispatch&& d) const {
    SemanticLabelsFB semanticLabelsOutput;
    Result result = static_cast<Result>( d.xrGetSpaceSemanticLabelsFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(semanticLabelsOutput)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getSpaceSemanticLabelsFB");
    }


    return semanticLabelsOutput;
}


#endif  // XR_FB_scene
#ifdef XR_FB_scene

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Boundary2DFB Session::getSpaceBoundary2DFB (
    Space space, Dispatch&& d) const {
    Boundary2DFB boundary2DOutput;
    Result result = static_cast<Result>( d.xrGetSpaceBoundary2DFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(boundary2DOutput)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getSpaceBoundary2DFB");
    }


    return boundary2DOutput;
}


#endif  // XR_FB_scene
#ifdef XR_FB_scene

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE RoomLayoutFB Session::getSpaceRoomLayoutFB (
    Space space, Dispatch&& d) const {
    RoomLayoutFB roomLayoutOutput;
    Result result = static_cast<Result>( d.xrGetSpaceRoomLayoutFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(roomLayoutOutput)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getSpaceRoomLayoutFB");
    }


    return roomLayoutOutput;
}


#endif  // XR_FB_scene
#ifdef XR_ALMALENCE_digital_lens_control

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setDigitalLensControlALMALENCE (
    const DigitalLensControlALMALENCE& digitalLensControl, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetDigitalLensControlALMALENCE(this->get(), digitalLensControl.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setDigitalLensControlALMALENCE");
    }


    return;
}


#endif  // XR_ALMALENCE_digital_lens_control
#ifdef XR_FB_scene_capture

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::requestSceneCaptureFB (
    const SceneCaptureRequestInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrRequestSceneCaptureFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::requestSceneCaptureFB");
    }


    return requestId;
}


#endif  // XR_FB_scene_capture
#ifdef XR_FB_spatial_entity_container

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceContainerFB Session::getSpaceContainerFB (
    Space space, Dispatch&& d) const {
    SpaceContainerFB spaceContainerOutput;
    Result result = static_cast<Result>( d.xrGetSpaceContainerFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(spaceContainerOutput)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getSpaceContainerFB");
    }


    return spaceContainerOutput;
}


#endif  // XR_FB_spatial_entity_container
#ifdef XR_META_foveation_eye_tracked

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FoveationEyeTrackedStateMETA Session::getFoveationEyeTrackedStateMETA (
    Dispatch&& d) const {
    FoveationEyeTrackedStateMETA foveationState;
    Result result = static_cast<Result>( d.xrGetFoveationEyeTrackedStateMETA(this->get(), OPENXR_HPP_NAMESPACE::put(foveationState)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getFoveationEyeTrackedStateMETA");
    }


    return foveationState;
}


#endif  // XR_META_foveation_eye_tracked
#ifdef XR_FB_face_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FaceTrackerFB Session::createFaceTrackerFB (
    const FaceTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    FaceTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateFaceTrackerFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFaceTrackerFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<FaceTrackerFB, impl::RemoveRefConst<Dispatch>> Session::createFaceTrackerUniqueFB (
    const FaceTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    FaceTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateFaceTrackerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createFaceTrackerUniqueFB");
    }


    return UniqueHandle<FaceTrackerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void FaceTrackerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyFaceTrackerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::FaceTrackerFB::destroy");
    }


    return;
}


#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE FaceExpressionWeightsFB FaceTrackerFB::getFaceExpressionWeightsFB (
    const FaceExpressionInfoFB& expressionInfo, Dispatch&& d) const {
    FaceExpressionWeightsFB expressionWeights;
    Result result = static_cast<Result>( d.xrGetFaceExpressionWeightsFB(this->get(), expressionInfo.get(), OPENXR_HPP_NAMESPACE::put(expressionWeights)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::FaceTrackerFB::getFaceExpressionWeightsFB");
    }


    return expressionWeights;
}


#endif  // XR_FB_face_tracking
#ifdef XR_FB_eye_tracking_social

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE EyeTrackerFB Session::createEyeTrackerFB (
    const EyeTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    EyeTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateEyeTrackerFB(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createEyeTrackerFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<EyeTrackerFB, impl::RemoveRefConst<Dispatch>> Session::createEyeTrackerUniqueFB (
    const EyeTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    EyeTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateEyeTrackerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createEyeTrackerUniqueFB");
    }


    return UniqueHandle<EyeTrackerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void EyeTrackerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyEyeTrackerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::EyeTrackerFB::destroy");
    }


    return;
}


#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE EyeGazesFB EyeTrackerFB::getEyeGazesFB (
    const EyeGazesInfoFB& gazeInfo, Dispatch&& d) const {
    EyeGazesFB eyeGazes;
    Result result = static_cast<Result>( d.xrGetEyeGazesFB(this->get(), gazeInfo.get(), OPENXR_HPP_NAMESPACE::put(eyeGazes)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::EyeTrackerFB::getEyeGazesFB");
    }


    return eyeGazes;
}


#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_passthrough_keyboard_hands

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughLayerFB::passthroughLayerSetKeyboardHandsIntensityFB (
    const PassthroughKeyboardHandsIntensityFB& intensity, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerSetKeyboardHandsIntensityFB(this->get(), intensity.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughLayerFB::passthroughLayerSetKeyboardHandsIntensityFB");
    }


    return;
}


#endif  // XR_FB_passthrough_keyboard_hands
#ifdef XR_FB_haptic_pcm

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE DevicePcmSampleRateGetInfoFB Session::getDeviceSampleRateFB (
    const HapticActionInfo& hapticActionInfo, Dispatch&& d) const {
    DevicePcmSampleRateGetInfoFB deviceSampleRate;
    Result result = static_cast<Result>( d.xrGetDeviceSampleRateFB(this->get(), hapticActionInfo.get(), &deviceSampleRate) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getDeviceSampleRateFB");
    }


    return deviceSampleRate;
}


#endif  // XR_FB_haptic_pcm
#ifdef XR_META_passthrough_preferences

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughPreferencesMETA Session::getPassthroughPreferencesMETA (
    Dispatch&& d) const {
    PassthroughPreferencesMETA preferences;
    Result result = static_cast<Result>( d.xrGetPassthroughPreferencesMETA(this->get(), OPENXR_HPP_NAMESPACE::put(preferences)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getPassthroughPreferencesMETA");
    }


    return preferences;
}


#endif  // XR_META_passthrough_preferences
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VirtualKeyboardMETA Session::createVirtualKeyboardMETA (
    const VirtualKeyboardCreateInfoMETA& createInfo, Dispatch&& d) const {
    VirtualKeyboardMETA handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardMETA(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createVirtualKeyboardMETA");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<VirtualKeyboardMETA, impl::RemoveRefConst<Dispatch>> Session::createVirtualKeyboardUniqueMETA (
    const VirtualKeyboardCreateInfoMETA& createInfo, Dispatch&& d) const {
    VirtualKeyboardMETA handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardMETA(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createVirtualKeyboardUniqueMETA");
    }


    return UniqueHandle<VirtualKeyboardMETA, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void VirtualKeyboardMETA::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyVirtualKeyboardMETA(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::destroy");
    }


    return;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Space Session::createVirtualKeyboardSpaceMETA (
    VirtualKeyboardMETA keyboard, const VirtualKeyboardSpaceCreateInfoMETA& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardSpaceMETA(this->get(), keyboard.get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createVirtualKeyboardSpaceMETA");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> Session::createVirtualKeyboardSpaceUniqueMETA (
    VirtualKeyboardMETA keyboard, const VirtualKeyboardSpaceCreateInfoMETA& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardSpaceMETA(this->get(), keyboard.get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createVirtualKeyboardSpaceUniqueMETA");
    }


    return UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void VirtualKeyboardMETA::suggestVirtualKeyboardLocationMETA (
    const VirtualKeyboardLocationInfoMETA& locationInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSuggestVirtualKeyboardLocationMETA(this->get(), locationInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::suggestVirtualKeyboardLocationMETA");
    }


    return;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE float VirtualKeyboardMETA::getVirtualKeyboardScaleMETA (
    Dispatch&& d) const {
    float scale;
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardScaleMETA(this->get(), &scale) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::getVirtualKeyboardScaleMETA");
    }


    return scale;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void VirtualKeyboardMETA::setVirtualKeyboardModelVisibilityMETA (
    const VirtualKeyboardModelVisibilitySetInfoMETA& modelVisibility, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetVirtualKeyboardModelVisibilityMETA(this->get(), modelVisibility.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::setVirtualKeyboardModelVisibilityMETA");
    }


    return;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VirtualKeyboardModelAnimationStatesMETA VirtualKeyboardMETA::getVirtualKeyboardModelAnimationStatesMETA (
    Dispatch&& d) const {
    VirtualKeyboardModelAnimationStatesMETA animationStates;
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardModelAnimationStatesMETA(this->get(), OPENXR_HPP_NAMESPACE::put(animationStates)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::getVirtualKeyboardModelAnimationStatesMETA");
    }


    return animationStates;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<uint64_t, Allocator> VirtualKeyboardMETA::getVirtualKeyboardDirtyTexturesToVectorMETA (
    Dispatch&& d) const {
    std::vector<uint64_t, Allocator> textureIds;
        uint32_t textureIdCountOutput = 0;
    uint32_t textureIdCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || textureIdCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return textureIds;
    }
    do {
        textureIds.resize(textureIdCountOutput);
        textureIdCapacityInput = static_cast<uint32_t>(textureIds.size());
        result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, reinterpret_cast<uint64_t*>(textureIds.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(textureIdCountOutput <= textureIds.size());
        textureIds.resize(textureIdCountOutput);
    } else textureIds.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return textureIds;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<uint64_t, Allocator> VirtualKeyboardMETA::getVirtualKeyboardDirtyTexturesToVectorMETA (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<uint64_t, Allocator> textureIds{vectorAllocator};
        uint32_t textureIdCountOutput = 0;
    uint32_t textureIdCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || textureIdCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return textureIds;
    }
    do {
        textureIds.resize(textureIdCountOutput);
        textureIdCapacityInput = static_cast<uint32_t>(textureIds.size());
        result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, reinterpret_cast<uint64_t*>(textureIds.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(textureIdCountOutput <= textureIds.size());
        textureIds.resize(textureIdCountOutput);
    } else textureIds.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return textureIds;

}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE VirtualKeyboardTextureDataMETA VirtualKeyboardMETA::getVirtualKeyboardTextureDataMETA (
    uint64_t textureId, Dispatch&& d) const {
    VirtualKeyboardTextureDataMETA textureData;
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardTextureDataMETA(this->get(), textureId, OPENXR_HPP_NAMESPACE::put(textureData)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::getVirtualKeyboardTextureDataMETA");
    }


    return textureData;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Posef VirtualKeyboardMETA::sendVirtualKeyboardInputMETA (
    const VirtualKeyboardInputInfoMETA& info, Dispatch&& d) const {
    Posef interactorRootPose;
    Result result = static_cast<Result>( d.xrSendVirtualKeyboardInputMETA(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(interactorRootPose)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::sendVirtualKeyboardInputMETA");
    }


    return interactorRootPose;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void VirtualKeyboardMETA::changeVirtualKeyboardTextContextMETA (
    const VirtualKeyboardTextContextChangeInfoMETA& changeInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrChangeVirtualKeyboardTextContextMETA(this->get(), changeInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::VirtualKeyboardMETA::changeVirtualKeyboardTextContextMETA");
    }


    return;
}


#endif  // XR_META_virtual_keyboard
#ifdef XR_OCULUS_external_camera

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ExternalCameraOCULUS, Allocator> Session::enumerateExternalCamerasToVectorOCULUS (
    Dispatch&& d) const {
    std::vector<ExternalCameraOCULUS, Allocator> cameras;
        uint32_t cameraCountOutput = 0;
    uint32_t cameraCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || cameraCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return cameras;
    }
    do {
        cameras.resize(cameraCountOutput);
        cameraCapacityInput = static_cast<uint32_t>(cameras.size());
        result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, reinterpret_cast<XrExternalCameraOCULUS*>(cameras.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(cameraCountOutput <= cameras.size());
        cameras.resize(cameraCountOutput);
    } else cameras.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return cameras;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<ExternalCameraOCULUS, Allocator> Session::enumerateExternalCamerasToVectorOCULUS (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ExternalCameraOCULUS, Allocator> cameras{vectorAllocator};
        uint32_t cameraCountOutput = 0;
    uint32_t cameraCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || cameraCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return cameras;
    }
    do {
        cameras.resize(cameraCountOutput);
        cameraCapacityInput = static_cast<uint32_t>(cameras.size());
        result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, reinterpret_cast<XrExternalCameraOCULUS*>(cameras.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(cameraCountOutput <= cameras.size());
        cameras.resize(cameraCountOutput);
    } else cameras.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return cameras;

}


#endif  // XR_OCULUS_external_camera
#ifdef XR_META_performance_metrics

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<Path, Allocator> Instance::enumeratePerformanceMetricsCounterPathsToVectorMETA (
    Dispatch&& d) const {
    std::vector<Path, Allocator> counterPaths;
        uint32_t counterPathCountOutput = 0;
    uint32_t counterPathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || counterPathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return counterPaths;
    }
    do {
        counterPaths.resize(counterPathCountOutput);
        counterPathCapacityInput = static_cast<uint32_t>(counterPaths.size());
        result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, reinterpret_cast<XrPath*>(counterPaths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(counterPathCountOutput <= counterPaths.size());
        counterPaths.resize(counterPathCountOutput);
    } else counterPaths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return counterPaths;

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE std::vector<Path, Allocator> Instance::enumeratePerformanceMetricsCounterPathsToVectorMETA (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<Path, Allocator> counterPaths{vectorAllocator};
        uint32_t counterPathCountOutput = 0;
    uint32_t counterPathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || counterPathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return counterPaths;
    }
    do {
        counterPaths.resize(counterPathCountOutput);
        counterPathCapacityInput = static_cast<uint32_t>(counterPaths.size());
        result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, reinterpret_cast<XrPath*>(counterPaths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(counterPathCountOutput <= counterPaths.size());
        counterPaths.resize(counterPathCountOutput);
    } else counterPaths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return counterPaths;

}


#endif  // XR_META_performance_metrics
#ifdef XR_META_performance_metrics

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setPerformanceMetricsStateMETA (
    const PerformanceMetricsStateMETA& state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetPerformanceMetricsStateMETA(this->get(), state.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setPerformanceMetricsStateMETA");
    }


    return;
}


#endif  // XR_META_performance_metrics
#ifdef XR_META_performance_metrics

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PerformanceMetricsStateMETA Session::getPerformanceMetricsStateMETA (
    Dispatch&& d) const {
    PerformanceMetricsStateMETA state;
    Result result = static_cast<Result>( d.xrGetPerformanceMetricsStateMETA(this->get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getPerformanceMetricsStateMETA");
    }


    return state;
}


#endif  // XR_META_performance_metrics
#ifdef XR_META_performance_metrics

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PerformanceMetricsCounterMETA Session::queryPerformanceMetricsCounterMETA (
    Path counterPath, Dispatch&& d) const {
    PerformanceMetricsCounterMETA counter;
    Result result = static_cast<Result>( d.xrQueryPerformanceMetricsCounterMETA(this->get(), counterPath.get(), OPENXR_HPP_NAMESPACE::put(counter)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::queryPerformanceMetricsCounterMETA");
    }


    return counter;
}


#endif  // XR_META_performance_metrics
#ifdef XR_FB_spatial_entity_storage_batch

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE AsyncRequestIdFB Session::saveSpaceListFB (
    const SpaceListSaveInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrSaveSpaceListFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::saveSpaceListFB");
    }


    return requestId;
}


#endif  // XR_FB_spatial_entity_storage_batch
#ifdef XR_FB_spatial_entity_user

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceUserFB Session::createSpaceUserFB (
    const SpaceUserCreateInfoFB& info, Dispatch&& d) const {
    SpaceUserFB handle;
    Result result = static_cast<Result>( d.xrCreateSpaceUserFB(this->get(), info.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpaceUserFB");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<SpaceUserFB, impl::RemoveRefConst<Dispatch>> Session::createSpaceUserUniqueFB (
    const SpaceUserCreateInfoFB& info, Dispatch&& d) const {
    SpaceUserFB handle;
    Result result = static_cast<Result>( d.xrCreateSpaceUserFB(this->get(), info.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createSpaceUserUniqueFB");
    }


    return UniqueHandle<SpaceUserFB, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_FB_spatial_entity_user
#ifdef XR_FB_spatial_entity_user

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE SpaceUserIdFB SpaceUserFB::getSpaceUserIdFB (
    Dispatch&& d) const {
    SpaceUserIdFB userId;
    Result result = static_cast<Result>( d.xrGetSpaceUserIdFB(this->get(), &userId) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::SpaceUserFB::getSpaceUserIdFB");
    }


    return userId;
}


#endif  // XR_FB_spatial_entity_user
#ifdef XR_FB_spatial_entity_user

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void SpaceUserFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySpaceUserFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::SpaceUserFB::destroy");
    }


    return;
}


#endif  // XR_FB_spatial_entity_user
#ifdef XR_META_passthrough_color_lut

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughColorLutMETA PassthroughFB::createPassthroughColorLutMETA (
    const PassthroughColorLutCreateInfoMETA& createInfo, Dispatch&& d) const {
    PassthroughColorLutMETA handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughColorLutMETA(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::createPassthroughColorLutMETA");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PassthroughColorLutMETA, impl::RemoveRefConst<Dispatch>> PassthroughFB::createPassthroughColorLutUniqueMETA (
    const PassthroughColorLutCreateInfoMETA& createInfo, Dispatch&& d) const {
    PassthroughColorLutMETA handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughColorLutMETA(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughFB::createPassthroughColorLutUniqueMETA");
    }


    return UniqueHandle<PassthroughColorLutMETA, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughColorLutMETA::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughColorLutMETA(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughColorLutMETA::destroy");
    }


    return;
}


#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughColorLutMETA::updatePassthroughColorLutMETA (
    const PassthroughColorLutUpdateInfoMETA& updateInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrUpdatePassthroughColorLutMETA(this->get(), updateInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughColorLutMETA::updatePassthroughColorLutMETA");
    }


    return;
}


#endif  // XR_META_passthrough_color_lut
#ifdef XR_QCOM_tracking_optimization_settings

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::setTrackingOptimizationSettingsHintQCOM (
    TrackingOptimizationSettingsDomainQCOM domain, TrackingOptimizationSettingsHintQCOM hint, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetTrackingOptimizationSettingsHintQCOM(this->get(), OPENXR_HPP_NAMESPACE::get(domain), OPENXR_HPP_NAMESPACE::get(hint)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::setTrackingOptimizationSettingsHintQCOM");
    }


    return;
}


#endif  // XR_QCOM_tracking_optimization_settings
#ifdef XR_HTC_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PassthroughHTC Session::createPassthroughHTC (
    const PassthroughCreateInfoHTC& createInfo, Dispatch&& d) const {
    PassthroughHTC handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughHTC(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughHTC");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PassthroughHTC, impl::RemoveRefConst<Dispatch>> Session::createPassthroughUniqueHTC (
    const PassthroughCreateInfoHTC& createInfo, Dispatch&& d) const {
    PassthroughHTC handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughHTC(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPassthroughUniqueHTC");
    }


    return UniqueHandle<PassthroughHTC, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PassthroughHTC::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughHTC(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PassthroughHTC::destroy");
    }


    return;
}


#endif  // XR_HTC_passthrough
#ifdef XR_HTC_foveation

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Session::applyFoveationHTC (
    const FoveationApplyInfoHTC& applyInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrApplyFoveationHTC(this->get(), applyInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::applyFoveationHTC");
    }


    return;
}


#endif  // XR_HTC_foveation
#ifdef XR_EXT_plane_detection

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PlaneDetectorEXT Session::createPlaneDetectorEXT (
    const PlaneDetectorCreateInfoEXT& createInfo, Dispatch&& d) const {
    PlaneDetectorEXT handle;
    Result result = static_cast<Result>( d.xrCreatePlaneDetectorEXT(this->get(), createInfo.get(), handle.put()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPlaneDetectorEXT");
    }


    return handle;
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE UniqueHandle<PlaneDetectorEXT, impl::RemoveRefConst<Dispatch>> Session::createPlaneDetectorUniqueEXT (
    const PlaneDetectorCreateInfoEXT& createInfo, Dispatch&& d) const {
    PlaneDetectorEXT handle;
    Result result = static_cast<Result>( d.xrCreatePlaneDetectorEXT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::createPlaneDetectorUniqueEXT");
    }


    return UniqueHandle<PlaneDetectorEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter);
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE


#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PlaneDetectorEXT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPlaneDetectorEXT(this->get()) );
    val_ = XR_NULL_HANDLE;
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PlaneDetectorEXT::destroy");
    }


    return;
}


#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void PlaneDetectorEXT::beginPlaneDetectionEXT (
    const PlaneDetectorBeginInfoEXT& beginInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrBeginPlaneDetectionEXT(this->get(), beginInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PlaneDetectorEXT::beginPlaneDetectionEXT");
    }


    return;
}


#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PlaneDetectionStateEXT PlaneDetectorEXT::getPlaneDetectionStateEXT (
    Dispatch&& d) const {
    XrPlaneDetectionStateEXT state_tmp;
    PlaneDetectionStateEXT state;
    Result result = static_cast<Result>( d.xrGetPlaneDetectionStateEXT(this->get(), &state_tmp) );
    state = static_cast<PlaneDetectionStateEXT>(state_tmp);
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PlaneDetectorEXT::getPlaneDetectionStateEXT");
    }


    return state;
}


#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PlaneDetectorLocationsEXT PlaneDetectorEXT::getPlaneDetectionsEXT (
    const PlaneDetectorGetInfoEXT& info, Dispatch&& d) const {
    PlaneDetectorLocationsEXT locations;
    Result result = static_cast<Result>( d.xrGetPlaneDetectionsEXT(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(locations)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PlaneDetectorEXT::getPlaneDetectionsEXT");
    }


    return locations;
}


#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE PlaneDetectorPolygonBufferEXT PlaneDetectorEXT::getPlanePolygonBufferEXT (
    uint64_t planeId, uint32_t polygonBufferIndex, Dispatch&& d) const {
    PlaneDetectorPolygonBufferEXT polygonBuffer;
    Result result = static_cast<Result>( d.xrGetPlanePolygonBufferEXT(this->get(), planeId, polygonBufferIndex, OPENXR_HPP_NAMESPACE::put(polygonBuffer)) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::PlaneDetectorEXT::getPlanePolygonBufferEXT");
    }


    return polygonBuffer;
}


#endif  // XR_EXT_plane_detection
#ifdef XR_ML_user_calibration

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE void Instance::enableUserCalibrationEventsML (
    const UserCalibrationEnableEventsInfoML& enableInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrEnableUserCalibrationEventsML(this->get(), enableInfo.get()) );
    
            if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::enableUserCalibrationEventsML");
    }


    return;
}


#endif  // XR_ML_user_calibration
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE
































#endif  // ifndef OPENXR_METHOD_IMPLS_ENHANCED_EXCEPTIONS_INL_

