// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************
































/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_ENUMS_HPP_
#define OPENXR_ENUMS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR enum types.
 *
 * Does not include the flags (bitmasks).
 *
 * @see openxr_flags.hpp
 * @ingroup enums
 */

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

#include <string>

// Fix name collisions from noisy includes
#ifdef Success
#undef Success
#endif
#ifdef None
#undef None
#endif
































#if !defined(OPENXR_HPP_INLINE)
#if defined(__clang___)
#if __has_attribute(always_inline)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#else
#define OPENXR_HPP_INLINE inline
#endif
#elif defined(__GNUC__)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#elif defined(_MSC_VER)
#define OPENXR_HPP_INLINE inline
#else
#define OPENXR_HPP_INLINE inline
#endif
#endif  // !OPENXR_HPP_INLINE

#if !defined(OPENXR_HPP_CONSTEXPR)
#if defined(_MSC_VER) && (_MSC_VER <= 1800)
#define OPENXR_HPP_CONSTEXPR
#else
#define OPENXR_HPP_CONSTEXPR constexpr
#endif
#endif  // !OPENXR_HPP_CONSTEXPR

#if !defined(OPENXR_HPP_SWITCH_CONSTEXPR)
//! @todo set this to constexpr in c++14
#define OPENXR_HPP_SWITCH_CONSTEXPR
#endif  // !OPENXR_HPP_SWITCH_CONSTEXPR































#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {
/*!
 * @defgroup enums Enumerations
 * @brief C++ enum classes corresponding to OpenXR C enumerations, plus associated utility functions.
 * @ingroup wrappers
 *
 * All enumerations have three utility functions defined:
 *
 * - get() - returns the raw C enum value
 * - to_string_literal() - returns a const char* containing the C++ name
 * - to_string() - wraps to_string_literal(), returning a std::string
 *
 * They all should be accessible via argument-dependent lookup, meaning you should not need to explicitly specify the namespace.
 * @{
 */


































/*!
 * @brief Enum class for XrResult
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrResult>
 * 
 * @see failed(), succeeded(), unqualifiedSuccess()
 * @xrentity{XrResult}
 */
enum class Result: int32_t {
    
    Success = XR_SUCCESS,
    
    
    TimeoutExpired = XR_TIMEOUT_EXPIRED,
    
    
    SessionLossPending = XR_SESSION_LOSS_PENDING,
    
    
    EventUnavailable = XR_EVENT_UNAVAILABLE,
    
    
    SpaceBoundsUnavailable = XR_SPACE_BOUNDS_UNAVAILABLE,
    
    
    SessionNotFocused = XR_SESSION_NOT_FOCUSED,
    
    
    FrameDiscarded = XR_FRAME_DISCARDED,
    
    
    ErrorValidationFailure = XR_ERROR_VALIDATION_FAILURE,
    
    
    ErrorRuntimeFailure = XR_ERROR_RUNTIME_FAILURE,
    
    
    ErrorOutOfMemory = XR_ERROR_OUT_OF_MEMORY,
    
    
    ErrorAPIVersionUnsupported = XR_ERROR_API_VERSION_UNSUPPORTED,
    
    
    ErrorInitializationFailed = XR_ERROR_INITIALIZATION_FAILED,
    
    
    ErrorFunctionUnsupported = XR_ERROR_FUNCTION_UNSUPPORTED,
    
    
    ErrorFeatureUnsupported = XR_ERROR_FEATURE_UNSUPPORTED,
    
    
    ErrorExtensionNotPresent = XR_ERROR_EXTENSION_NOT_PRESENT,
    
    
    ErrorLimitReached = XR_ERROR_LIMIT_REACHED,
    
    
    ErrorSizeInsufficient = XR_ERROR_SIZE_INSUFFICIENT,
    
    
    ErrorHandleInvalid = XR_ERROR_HANDLE_INVALID,
    
    
    ErrorInstanceLost = XR_ERROR_INSTANCE_LOST,
    
    
    ErrorSessionRunning = XR_ERROR_SESSION_RUNNING,
    
    
    ErrorSessionNotRunning = XR_ERROR_SESSION_NOT_RUNNING,
    
    
    ErrorSessionLost = XR_ERROR_SESSION_LOST,
    
    
    ErrorSystemInvalid = XR_ERROR_SYSTEM_INVALID,
    
    
    ErrorPathInvalid = XR_ERROR_PATH_INVALID,
    
    
    ErrorPathCountExceeded = XR_ERROR_PATH_COUNT_EXCEEDED,
    
    
    ErrorPathFormatInvalid = XR_ERROR_PATH_FORMAT_INVALID,
    
    
    ErrorPathUnsupported = XR_ERROR_PATH_UNSUPPORTED,
    
    
    ErrorLayerInvalid = XR_ERROR_LAYER_INVALID,
    
    
    ErrorLayerLimitExceeded = XR_ERROR_LAYER_LIMIT_EXCEEDED,
    
    
    ErrorSwapchainRectInvalid = XR_ERROR_SWAPCHAIN_RECT_INVALID,
    
    
    ErrorSwapchainFormatUnsupported = XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED,
    
    
    ErrorActionTypeMismatch = XR_ERROR_ACTION_TYPE_MISMATCH,
    
    
    ErrorSessionNotReady = XR_ERROR_SESSION_NOT_READY,
    
    
    ErrorSessionNotStopping = XR_ERROR_SESSION_NOT_STOPPING,
    
    
    ErrorTimeInvalid = XR_ERROR_TIME_INVALID,
    
    
    ErrorReferenceSpaceUnsupported = XR_ERROR_REFERENCE_SPACE_UNSUPPORTED,
    
    
    ErrorFileAccessError = XR_ERROR_FILE_ACCESS_ERROR,
    
    
    ErrorFileContentsInvalid = XR_ERROR_FILE_CONTENTS_INVALID,
    
    
    ErrorFormFactorUnsupported = XR_ERROR_FORM_FACTOR_UNSUPPORTED,
    
    
    ErrorFormFactorUnavailable = XR_ERROR_FORM_FACTOR_UNAVAILABLE,
    
    
    ErrorAPILayerNotPresent = XR_ERROR_API_LAYER_NOT_PRESENT,
    
    
    ErrorCallOrderInvalid = XR_ERROR_CALL_ORDER_INVALID,
    
    
    ErrorGraphicsDeviceInvalid = XR_ERROR_GRAPHICS_DEVICE_INVALID,
    
    
    ErrorPoseInvalid = XR_ERROR_POSE_INVALID,
    
    
    ErrorIndexOutOfRange = XR_ERROR_INDEX_OUT_OF_RANGE,
    
    
    ErrorViewConfigurationTypeUnsupported = XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,
    
    
    ErrorEnvironmentBlendModeUnsupported = XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED,
    
    
    ErrorNameDuplicated = XR_ERROR_NAME_DUPLICATED,
    
    
    ErrorNameInvalid = XR_ERROR_NAME_INVALID,
    
    
    ErrorActionsetNotAttached = XR_ERROR_ACTIONSET_NOT_ATTACHED,
    
    
    ErrorActionsetsAlreadyAttached = XR_ERROR_ACTIONSETS_ALREADY_ATTACHED,
    
    
    ErrorLocalizedNameDuplicated = XR_ERROR_LOCALIZED_NAME_DUPLICATED,
    
    
    ErrorLocalizedNameInvalid = XR_ERROR_LOCALIZED_NAME_INVALID,
    
    
    ErrorGraphicsRequirementsCallMissing = XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING,
    
    
    ErrorRuntimeUnavailable = XR_ERROR_RUNTIME_UNAVAILABLE,
    
    #ifdef XR_KHR_android_thread_settings
    ErrorAndroidThreadSettingsIdInvalidKHR = XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR,
    #endif  // XR_KHR_android_thread_settings
    #ifdef XR_KHR_android_thread_settings
    ErrorAndroidThreadSettingsFailureKHR = XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR,
    #endif  // XR_KHR_android_thread_settings
    #ifdef XR_MSFT_spatial_anchor
    ErrorCreateSpatialAnchorFailedMSFT = XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT,
    #endif  // XR_MSFT_spatial_anchor
    #ifdef XR_MSFT_secondary_view_configuration
    ErrorSecondaryViewConfigurationTypeNotEnabledMSFT = XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_controller_model
    ErrorControllerModelKeyInvalidMSFT = XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT,
    #endif  // XR_MSFT_controller_model
    #ifdef XR_MSFT_composition_layer_reprojection
    ErrorReprojectionModeUnsupportedMSFT = XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT,
    #endif  // XR_MSFT_composition_layer_reprojection
    #ifdef XR_MSFT_scene_understanding
    ErrorComputeNewSceneNotCompletedMSFT = XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ErrorSceneComponentIdInvalidMSFT = XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ErrorSceneComponentTypeMismatchMSFT = XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ErrorSceneMeshBufferIdInvalidMSFT = XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ErrorSceneComputeFeatureIncompatibleMSFT = XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ErrorSceneComputeConsistencyMismatchMSFT = XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_FB_display_refresh_rate
    ErrorDisplayRefreshRateUnsupportedFB = XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB,
    #endif  // XR_FB_display_refresh_rate
    #ifdef XR_FB_color_space
    ErrorColorSpaceUnsupportedFB = XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB,
    #endif  // XR_FB_color_space
    #ifdef XR_FB_spatial_entity
    ErrorSpaceComponentNotSupportedFB = XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    ErrorSpaceComponentNotEnabledFB = XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    ErrorSpaceComponentStatusPendingFB = XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    ErrorSpaceComponentStatusAlreadySetFB = XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_passthrough
    ErrorUnexpectedStatePassthroughFB = XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    ErrorFeatureAlreadyCreatedPassthroughFB = XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    ErrorFeatureRequiredPassthroughFB = XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    ErrorNotPermittedPassthroughFB = XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    ErrorInsufficientResourcesPassthroughFB = XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    ErrorUnknownPassthroughFB = XR_ERROR_UNKNOWN_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_render_model
    ErrorRenderModelKeyInvalidFB = XR_ERROR_RENDER_MODEL_KEY_INVALID_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_FB_render_model
    RenderModelUnavailableFB = XR_RENDER_MODEL_UNAVAILABLE_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_VARJO_marker_tracking
    ErrorMarkerNotTrackedVARJO = XR_ERROR_MARKER_NOT_TRACKED_VARJO,
    #endif  // XR_VARJO_marker_tracking
    #ifdef XR_VARJO_marker_tracking
    ErrorMarkerIdInvalidVARJO = XR_ERROR_MARKER_ID_INVALID_VARJO,
    #endif  // XR_VARJO_marker_tracking
    #ifdef XR_MSFT_spatial_anchor_persistence
    ErrorSpatialAnchorNameNotFoundMSFT = XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT,
    #endif  // XR_MSFT_spatial_anchor_persistence
    #ifdef XR_MSFT_spatial_anchor_persistence
    ErrorSpatialAnchorNameInvalidMSFT = XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT,
    #endif  // XR_MSFT_spatial_anchor_persistence
    #ifdef XR_MSFT_scene_marker
    SceneMarkerDataNotStringMSFT = XR_SCENE_MARKER_DATA_NOT_STRING_MSFT,
    #endif  // XR_MSFT_scene_marker
    #ifdef XR_FB_spatial_entity_sharing
    ErrorSpaceMappingInsufficientFB = XR_ERROR_SPACE_MAPPING_INSUFFICIENT_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_FB_spatial_entity_sharing
    ErrorSpaceLocalizationFailedFB = XR_ERROR_SPACE_LOCALIZATION_FAILED_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_FB_spatial_entity_sharing
    ErrorSpaceNetworkTimeoutFB = XR_ERROR_SPACE_NETWORK_TIMEOUT_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_FB_spatial_entity_sharing
    ErrorSpaceNetworkRequestFailedFB = XR_ERROR_SPACE_NETWORK_REQUEST_FAILED_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_FB_spatial_entity_sharing
    ErrorSpaceCloudStorageDisabledFB = XR_ERROR_SPACE_CLOUD_STORAGE_DISABLED_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_META_passthrough_color_lut
    ErrorPassthroughColorLutBufferSizeMismatchMETA = XR_ERROR_PASSTHROUGH_COLOR_LUT_BUFFER_SIZE_MISMATCH_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_QCOM_tracking_optimization_settings
    ErrorHintAlreadySetQCOM = XR_ERROR_HINT_ALREADY_SET_QCOM,
    #endif  // XR_QCOM_tracking_optimization_settings
    #ifdef XR_EXT_plane_detection
    ErrorSpaceNotLocatableEXT = XR_ERROR_SPACE_NOT_LOCATABLE_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    ErrorPlaneDetectionPermissionDeniedEXT = XR_ERROR_PLANE_DETECTION_PERMISSION_DENIED_EXT,
    #endif  // XR_EXT_plane_detection
};
 static_assert(sizeof(Result) == sizeof(XrResult), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrResult value from a Result.
 * 
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrResult get(Result const& v) {
    return static_cast<XrResult>(v);
}

/*!
 * @brief Free function for retrieving the string name of a Result value as a const char *.
 * 
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(Result value) {
    switch (value) {
            
        case Result::Success:
            return "Success";
            
            
        case Result::TimeoutExpired:
            return "TimeoutExpired";
            
            
        case Result::SessionLossPending:
            return "SessionLossPending";
            
            
        case Result::EventUnavailable:
            return "EventUnavailable";
            
            
        case Result::SpaceBoundsUnavailable:
            return "SpaceBoundsUnavailable";
            
            
        case Result::SessionNotFocused:
            return "SessionNotFocused";
            
            
        case Result::FrameDiscarded:
            return "FrameDiscarded";
            
            
        case Result::ErrorValidationFailure:
            return "ErrorValidationFailure";
            
            
        case Result::ErrorRuntimeFailure:
            return "ErrorRuntimeFailure";
            
            
        case Result::ErrorOutOfMemory:
            return "ErrorOutOfMemory";
            
            
        case Result::ErrorAPIVersionUnsupported:
            return "ErrorAPIVersionUnsupported";
            
            
        case Result::ErrorInitializationFailed:
            return "ErrorInitializationFailed";
            
            
        case Result::ErrorFunctionUnsupported:
            return "ErrorFunctionUnsupported";
            
            
        case Result::ErrorFeatureUnsupported:
            return "ErrorFeatureUnsupported";
            
            
        case Result::ErrorExtensionNotPresent:
            return "ErrorExtensionNotPresent";
            
            
        case Result::ErrorLimitReached:
            return "ErrorLimitReached";
            
            
        case Result::ErrorSizeInsufficient:
            return "ErrorSizeInsufficient";
            
            
        case Result::ErrorHandleInvalid:
            return "ErrorHandleInvalid";
            
            
        case Result::ErrorInstanceLost:
            return "ErrorInstanceLost";
            
            
        case Result::ErrorSessionRunning:
            return "ErrorSessionRunning";
            
            
        case Result::ErrorSessionNotRunning:
            return "ErrorSessionNotRunning";
            
            
        case Result::ErrorSessionLost:
            return "ErrorSessionLost";
            
            
        case Result::ErrorSystemInvalid:
            return "ErrorSystemInvalid";
            
            
        case Result::ErrorPathInvalid:
            return "ErrorPathInvalid";
            
            
        case Result::ErrorPathCountExceeded:
            return "ErrorPathCountExceeded";
            
            
        case Result::ErrorPathFormatInvalid:
            return "ErrorPathFormatInvalid";
            
            
        case Result::ErrorPathUnsupported:
            return "ErrorPathUnsupported";
            
            
        case Result::ErrorLayerInvalid:
            return "ErrorLayerInvalid";
            
            
        case Result::ErrorLayerLimitExceeded:
            return "ErrorLayerLimitExceeded";
            
            
        case Result::ErrorSwapchainRectInvalid:
            return "ErrorSwapchainRectInvalid";
            
            
        case Result::ErrorSwapchainFormatUnsupported:
            return "ErrorSwapchainFormatUnsupported";
            
            
        case Result::ErrorActionTypeMismatch:
            return "ErrorActionTypeMismatch";
            
            
        case Result::ErrorSessionNotReady:
            return "ErrorSessionNotReady";
            
            
        case Result::ErrorSessionNotStopping:
            return "ErrorSessionNotStopping";
            
            
        case Result::ErrorTimeInvalid:
            return "ErrorTimeInvalid";
            
            
        case Result::ErrorReferenceSpaceUnsupported:
            return "ErrorReferenceSpaceUnsupported";
            
            
        case Result::ErrorFileAccessError:
            return "ErrorFileAccessError";
            
            
        case Result::ErrorFileContentsInvalid:
            return "ErrorFileContentsInvalid";
            
            
        case Result::ErrorFormFactorUnsupported:
            return "ErrorFormFactorUnsupported";
            
            
        case Result::ErrorFormFactorUnavailable:
            return "ErrorFormFactorUnavailable";
            
            
        case Result::ErrorAPILayerNotPresent:
            return "ErrorAPILayerNotPresent";
            
            
        case Result::ErrorCallOrderInvalid:
            return "ErrorCallOrderInvalid";
            
            
        case Result::ErrorGraphicsDeviceInvalid:
            return "ErrorGraphicsDeviceInvalid";
            
            
        case Result::ErrorPoseInvalid:
            return "ErrorPoseInvalid";
            
            
        case Result::ErrorIndexOutOfRange:
            return "ErrorIndexOutOfRange";
            
            
        case Result::ErrorViewConfigurationTypeUnsupported:
            return "ErrorViewConfigurationTypeUnsupported";
            
            
        case Result::ErrorEnvironmentBlendModeUnsupported:
            return "ErrorEnvironmentBlendModeUnsupported";
            
            
        case Result::ErrorNameDuplicated:
            return "ErrorNameDuplicated";
            
            
        case Result::ErrorNameInvalid:
            return "ErrorNameInvalid";
            
            
        case Result::ErrorActionsetNotAttached:
            return "ErrorActionsetNotAttached";
            
            
        case Result::ErrorActionsetsAlreadyAttached:
            return "ErrorActionsetsAlreadyAttached";
            
            
        case Result::ErrorLocalizedNameDuplicated:
            return "ErrorLocalizedNameDuplicated";
            
            
        case Result::ErrorLocalizedNameInvalid:
            return "ErrorLocalizedNameInvalid";
            
            
        case Result::ErrorGraphicsRequirementsCallMissing:
            return "ErrorGraphicsRequirementsCallMissing";
            
            
        case Result::ErrorRuntimeUnavailable:
            return "ErrorRuntimeUnavailable";
            
            #ifdef XR_KHR_android_thread_settings
        case Result::ErrorAndroidThreadSettingsIdInvalidKHR:
            return "ErrorAndroidThreadSettingsIdInvalidKHR";
            #endif  // XR_KHR_android_thread_settings
            #ifdef XR_KHR_android_thread_settings
        case Result::ErrorAndroidThreadSettingsFailureKHR:
            return "ErrorAndroidThreadSettingsFailureKHR";
            #endif  // XR_KHR_android_thread_settings
            #ifdef XR_MSFT_spatial_anchor
        case Result::ErrorCreateSpatialAnchorFailedMSFT:
            return "ErrorCreateSpatialAnchorFailedMSFT";
            #endif  // XR_MSFT_spatial_anchor
            #ifdef XR_MSFT_secondary_view_configuration
        case Result::ErrorSecondaryViewConfigurationTypeNotEnabledMSFT:
            return "ErrorSecondaryViewConfigurationTypeNotEnabledMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_controller_model
        case Result::ErrorControllerModelKeyInvalidMSFT:
            return "ErrorControllerModelKeyInvalidMSFT";
            #endif  // XR_MSFT_controller_model
            #ifdef XR_MSFT_composition_layer_reprojection
        case Result::ErrorReprojectionModeUnsupportedMSFT:
            return "ErrorReprojectionModeUnsupportedMSFT";
            #endif  // XR_MSFT_composition_layer_reprojection
            #ifdef XR_MSFT_scene_understanding
        case Result::ErrorComputeNewSceneNotCompletedMSFT:
            return "ErrorComputeNewSceneNotCompletedMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case Result::ErrorSceneComponentIdInvalidMSFT:
            return "ErrorSceneComponentIdInvalidMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case Result::ErrorSceneComponentTypeMismatchMSFT:
            return "ErrorSceneComponentTypeMismatchMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case Result::ErrorSceneMeshBufferIdInvalidMSFT:
            return "ErrorSceneMeshBufferIdInvalidMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case Result::ErrorSceneComputeFeatureIncompatibleMSFT:
            return "ErrorSceneComputeFeatureIncompatibleMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case Result::ErrorSceneComputeConsistencyMismatchMSFT:
            return "ErrorSceneComputeConsistencyMismatchMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_FB_display_refresh_rate
        case Result::ErrorDisplayRefreshRateUnsupportedFB:
            return "ErrorDisplayRefreshRateUnsupportedFB";
            #endif  // XR_FB_display_refresh_rate
            #ifdef XR_FB_color_space
        case Result::ErrorColorSpaceUnsupportedFB:
            return "ErrorColorSpaceUnsupportedFB";
            #endif  // XR_FB_color_space
            #ifdef XR_FB_spatial_entity
        case Result::ErrorSpaceComponentNotSupportedFB:
            return "ErrorSpaceComponentNotSupportedFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case Result::ErrorSpaceComponentNotEnabledFB:
            return "ErrorSpaceComponentNotEnabledFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case Result::ErrorSpaceComponentStatusPendingFB:
            return "ErrorSpaceComponentStatusPendingFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case Result::ErrorSpaceComponentStatusAlreadySetFB:
            return "ErrorSpaceComponentStatusAlreadySetFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_passthrough
        case Result::ErrorUnexpectedStatePassthroughFB:
            return "ErrorUnexpectedStatePassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case Result::ErrorFeatureAlreadyCreatedPassthroughFB:
            return "ErrorFeatureAlreadyCreatedPassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case Result::ErrorFeatureRequiredPassthroughFB:
            return "ErrorFeatureRequiredPassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case Result::ErrorNotPermittedPassthroughFB:
            return "ErrorNotPermittedPassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case Result::ErrorInsufficientResourcesPassthroughFB:
            return "ErrorInsufficientResourcesPassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case Result::ErrorUnknownPassthroughFB:
            return "ErrorUnknownPassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_render_model
        case Result::ErrorRenderModelKeyInvalidFB:
            return "ErrorRenderModelKeyInvalidFB";
            #endif  // XR_FB_render_model
            #ifdef XR_FB_render_model
        case Result::RenderModelUnavailableFB:
            return "RenderModelUnavailableFB";
            #endif  // XR_FB_render_model
            #ifdef XR_VARJO_marker_tracking
        case Result::ErrorMarkerNotTrackedVARJO:
            return "ErrorMarkerNotTrackedVARJO";
            #endif  // XR_VARJO_marker_tracking
            #ifdef XR_VARJO_marker_tracking
        case Result::ErrorMarkerIdInvalidVARJO:
            return "ErrorMarkerIdInvalidVARJO";
            #endif  // XR_VARJO_marker_tracking
            #ifdef XR_MSFT_spatial_anchor_persistence
        case Result::ErrorSpatialAnchorNameNotFoundMSFT:
            return "ErrorSpatialAnchorNameNotFoundMSFT";
            #endif  // XR_MSFT_spatial_anchor_persistence
            #ifdef XR_MSFT_spatial_anchor_persistence
        case Result::ErrorSpatialAnchorNameInvalidMSFT:
            return "ErrorSpatialAnchorNameInvalidMSFT";
            #endif  // XR_MSFT_spatial_anchor_persistence
            #ifdef XR_MSFT_scene_marker
        case Result::SceneMarkerDataNotStringMSFT:
            return "SceneMarkerDataNotStringMSFT";
            #endif  // XR_MSFT_scene_marker
            #ifdef XR_FB_spatial_entity_sharing
        case Result::ErrorSpaceMappingInsufficientFB:
            return "ErrorSpaceMappingInsufficientFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_FB_spatial_entity_sharing
        case Result::ErrorSpaceLocalizationFailedFB:
            return "ErrorSpaceLocalizationFailedFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_FB_spatial_entity_sharing
        case Result::ErrorSpaceNetworkTimeoutFB:
            return "ErrorSpaceNetworkTimeoutFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_FB_spatial_entity_sharing
        case Result::ErrorSpaceNetworkRequestFailedFB:
            return "ErrorSpaceNetworkRequestFailedFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_FB_spatial_entity_sharing
        case Result::ErrorSpaceCloudStorageDisabledFB:
            return "ErrorSpaceCloudStorageDisabledFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_META_passthrough_color_lut
        case Result::ErrorPassthroughColorLutBufferSizeMismatchMETA:
            return "ErrorPassthroughColorLutBufferSizeMismatchMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_QCOM_tracking_optimization_settings
        case Result::ErrorHintAlreadySetQCOM:
            return "ErrorHintAlreadySetQCOM";
            #endif  // XR_QCOM_tracking_optimization_settings
            #ifdef XR_EXT_plane_detection
        case Result::ErrorSpaceNotLocatableEXT:
            return "ErrorSpaceNotLocatableEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case Result::ErrorPlaneDetectionPermissionDeniedEXT:
            return "ErrorPlaneDetectionPermissionDeniedEXT";
            #endif  // XR_EXT_plane_detection
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a Result value as a std::string.
 * 
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(Result value) {
    return {to_string_literal(value)};
}
//! @}

/*!
 * @defgroup result_helpers Result helper free functions
 * @brief C++ projections of the XrResult-checking function-style macros as constexpr functions.
 * @ingroup enums
 * @{
 */
/*!
 * @brief Return true if the Result is negative, indicating a failure.
 * Equivalent of XR_FAILED().
 * @found_by_adl
 * @see Result
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_FAILED>
 * @xrentity{XR_FAILED}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool failed(Result v) { return static_cast<int>(v) < 0; }

/*!
 * @brief Return true if the result is non-negative, indicating a success or non-error result.
 * Equivalent of XR_SUCCEEDED().
 * @found_by_adl
 * @see Result
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_SUCCEEDED>
 * @xrentity{XR_SUCCEEDED}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool succeeded(Result v) { return static_cast<int>(v) >= 0; }

/*!
 * @brief Return true if the result is exactly equal to Result::Success.
 * Equivalent of XR_UNQUALIFIED_SUCCESS().
 * @found_by_adl
 * @see Result
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_UNQUALIFIED_SUCCESS>
 * @xrentity{XR_UNQUALIFIED_SUCCESS}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool unqualifiedSuccess(Result v) { return v == Result::Success; }
//! @}

/*!
 * @brief `<` comparison between Result and integer, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Result lhs, int rhs) {
    return get(lhs)<rhs;
}

/*!
 * @brief `<` comparison between integer and Result, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(int lhs, Result rhs) {
    return lhs<get(rhs);
}

/*!
 * @brief `>` comparison between Result and integer, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Result lhs, int rhs) {
    return get(lhs)>rhs;
}

/*!
 * @brief `>` comparison between integer and Result, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(int lhs, Result rhs) {
    return lhs>get(rhs);
}

/*!
 * @brief `<=` comparison between Result and integer, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Result lhs, int rhs) {
    return get(lhs)<=rhs;
}

/*!
 * @brief `<=` comparison between integer and Result, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(int lhs, Result rhs) {
    return lhs<=get(rhs);
}

/*!
 * @brief `>=` comparison between Result and integer, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Result lhs, int rhs) {
    return get(lhs)>=rhs;
}

/*!
 * @brief `>=` comparison between integer and Result, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(int lhs, Result rhs) {
    return lhs>=get(rhs);
}

/*!
 * @brief `==` comparison between Result and integer, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Result lhs, int rhs) {
    return get(lhs)==rhs;
}

/*!
 * @brief `==` comparison between integer and Result, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(int lhs, Result rhs) {
    return lhs==get(rhs);
}

/*!
 * @brief `!=` comparison between Result and integer, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Result lhs, int rhs) {
    return get(lhs)!=rhs;
}

/*!
 * @brief `!=` comparison between integer and Result, for compatibility with the XR_ function-type macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(int lhs, Result rhs) {
    return lhs!=get(rhs);
}




































/*!
 * @brief Enum class for XrStructureType
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrStructureType>
 * 
 * @xrentity{XrStructureType}
 */
enum class StructureType: int32_t {
    
    Unknown = XR_TYPE_UNKNOWN,
    
    
    APILayerProperties = XR_TYPE_API_LAYER_PROPERTIES,
    
    
    ExtensionProperties = XR_TYPE_EXTENSION_PROPERTIES,
    
    
    InstanceCreateInfo = XR_TYPE_INSTANCE_CREATE_INFO,
    
    
    SystemGetInfo = XR_TYPE_SYSTEM_GET_INFO,
    
    
    SystemProperties = XR_TYPE_SYSTEM_PROPERTIES,
    
    
    ViewLocateInfo = XR_TYPE_VIEW_LOCATE_INFO,
    
    
    View = XR_TYPE_VIEW,
    
    
    SessionCreateInfo = XR_TYPE_SESSION_CREATE_INFO,
    
    
    SwapchainCreateInfo = XR_TYPE_SWAPCHAIN_CREATE_INFO,
    
    
    SessionBeginInfo = XR_TYPE_SESSION_BEGIN_INFO,
    
    
    ViewState = XR_TYPE_VIEW_STATE,
    
    
    FrameEndInfo = XR_TYPE_FRAME_END_INFO,
    
    
    HapticVibration = XR_TYPE_HAPTIC_VIBRATION,
    
    
    EventDataBuffer = XR_TYPE_EVENT_DATA_BUFFER,
    
    
    EventDataInstanceLossPending = XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING,
    
    
    EventDataSessionStateChanged = XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED,
    
    
    ActionStateBoolean = XR_TYPE_ACTION_STATE_BOOLEAN,
    
    
    ActionStateFloat = XR_TYPE_ACTION_STATE_FLOAT,
    
    
    ActionStateVector2F = XR_TYPE_ACTION_STATE_VECTOR2F,
    
    
    ActionStatePose = XR_TYPE_ACTION_STATE_POSE,
    
    
    ActionSetCreateInfo = XR_TYPE_ACTION_SET_CREATE_INFO,
    
    
    ActionCreateInfo = XR_TYPE_ACTION_CREATE_INFO,
    
    
    InstanceProperties = XR_TYPE_INSTANCE_PROPERTIES,
    
    
    FrameWaitInfo = XR_TYPE_FRAME_WAIT_INFO,
    
    
    CompositionLayerProjection = XR_TYPE_COMPOSITION_LAYER_PROJECTION,
    
    
    CompositionLayerQuad = XR_TYPE_COMPOSITION_LAYER_QUAD,
    
    
    ReferenceSpaceCreateInfo = XR_TYPE_REFERENCE_SPACE_CREATE_INFO,
    
    
    ActionSpaceCreateInfo = XR_TYPE_ACTION_SPACE_CREATE_INFO,
    
    
    EventDataReferenceSpaceChangePending = XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING,
    
    
    ViewConfigurationView = XR_TYPE_VIEW_CONFIGURATION_VIEW,
    
    
    SpaceLocation = XR_TYPE_SPACE_LOCATION,
    
    
    SpaceVelocity = XR_TYPE_SPACE_VELOCITY,
    
    
    FrameState = XR_TYPE_FRAME_STATE,
    
    
    ViewConfigurationProperties = XR_TYPE_VIEW_CONFIGURATION_PROPERTIES,
    
    
    FrameBeginInfo = XR_TYPE_FRAME_BEGIN_INFO,
    
    
    CompositionLayerProjectionView = XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW,
    
    
    EventDataEventsLost = XR_TYPE_EVENT_DATA_EVENTS_LOST,
    
    
    InteractionProfileSuggestedBinding = XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING,
    
    
    EventDataInteractionProfileChanged = XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED,
    
    
    InteractionProfileState = XR_TYPE_INTERACTION_PROFILE_STATE,
    
    
    SwapchainImageAcquireInfo = XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO,
    
    
    SwapchainImageWaitInfo = XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO,
    
    
    SwapchainImageReleaseInfo = XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO,
    
    
    ActionStateGetInfo = XR_TYPE_ACTION_STATE_GET_INFO,
    
    
    HapticActionInfo = XR_TYPE_HAPTIC_ACTION_INFO,
    
    
    SessionActionSetsAttachInfo = XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO,
    
    
    ActionsSyncInfo = XR_TYPE_ACTIONS_SYNC_INFO,
    
    
    BoundSourcesForActionEnumerateInfo = XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO,
    
    
    InputSourceLocalizedNameGetInfo = XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO,
    
    #ifdef XR_KHR_composition_layer_cube
    CompositionLayerCubeKHR = XR_TYPE_COMPOSITION_LAYER_CUBE_KHR,
    #endif  // XR_KHR_composition_layer_cube
    #ifdef XR_KHR_android_create_instance
    InstanceCreateInfoAndroidKHR = XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR,
    #endif  // XR_KHR_android_create_instance
    #ifdef XR_KHR_composition_layer_depth
    CompositionLayerDepthInfoKHR = XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR,
    #endif  // XR_KHR_composition_layer_depth
    #ifdef XR_KHR_vulkan_swapchain_format_list
    VulkanSwapchainFormatListCreateInfoKHR = XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR,
    #endif  // XR_KHR_vulkan_swapchain_format_list
    #ifdef XR_EXT_performance_settings
    EventDataPerfSettingsEXT = XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT,
    #endif  // XR_EXT_performance_settings
    #ifdef XR_KHR_composition_layer_cylinder
    CompositionLayerCylinderKHR = XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR,
    #endif  // XR_KHR_composition_layer_cylinder
    #ifdef XR_KHR_composition_layer_equirect
    CompositionLayerEquirectKHR = XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR,
    #endif  // XR_KHR_composition_layer_equirect
    #ifdef XR_EXT_debug_utils
    DebugUtilsObjectNameInfoEXT = XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    #endif  // XR_EXT_debug_utils
    #ifdef XR_EXT_debug_utils
    DebugUtilsMessengerCallbackDataEXT = XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    #endif  // XR_EXT_debug_utils
    #ifdef XR_EXT_debug_utils
    DebugUtilsMessengerCreateInfoEXT = XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    #endif  // XR_EXT_debug_utils
    #ifdef XR_EXT_debug_utils
    DebugUtilsLabelEXT = XR_TYPE_DEBUG_UTILS_LABEL_EXT,
    #endif  // XR_EXT_debug_utils
    #ifdef XR_KHR_opengl_enable
    GraphicsBindingOpenGLWin32KHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR,
    #endif  // XR_KHR_opengl_enable
    #ifdef XR_KHR_opengl_enable
    GraphicsBindingOpenGLXlibKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR,
    #endif  // XR_KHR_opengl_enable
    #ifdef XR_KHR_opengl_enable
    GraphicsBindingOpenGLXcbKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR,
    #endif  // XR_KHR_opengl_enable
    #ifdef XR_KHR_opengl_enable
    GraphicsBindingOpenGLWaylandKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR,
    #endif  // XR_KHR_opengl_enable
    #ifdef XR_KHR_opengl_enable
    SwapchainImageOpenGLKHR = XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR,
    #endif  // XR_KHR_opengl_enable
    #ifdef XR_KHR_opengl_enable
    GraphicsRequirementsOpenGLKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR,
    #endif  // XR_KHR_opengl_enable
    #ifdef XR_KHR_opengl_es_enable
    GraphicsBindingOpenGLESAndroidKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR,
    #endif  // XR_KHR_opengl_es_enable
    #ifdef XR_KHR_opengl_es_enable
    SwapchainImageOpenGLESKHR = XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR,
    #endif  // XR_KHR_opengl_es_enable
    #ifdef XR_KHR_opengl_es_enable
    GraphicsRequirementsOpenGLESKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR,
    #endif  // XR_KHR_opengl_es_enable
    #ifdef XR_KHR_vulkan_enable
    GraphicsBindingVulkanKHR = XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR,
    #endif  // XR_KHR_vulkan_enable
    #ifdef XR_KHR_vulkan_enable
    SwapchainImageVulkanKHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR,
    #endif  // XR_KHR_vulkan_enable
    #ifdef XR_KHR_vulkan_enable
    GraphicsRequirementsVulkanKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR,
    #endif  // XR_KHR_vulkan_enable
    #ifdef XR_KHR_D3D11_enable
    GraphicsBindingD3D11KHR = XR_TYPE_GRAPHICS_BINDING_D3D11_KHR,
    #endif  // XR_KHR_D3D11_enable
    #ifdef XR_KHR_D3D11_enable
    SwapchainImageD3D11KHR = XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR,
    #endif  // XR_KHR_D3D11_enable
    #ifdef XR_KHR_D3D11_enable
    GraphicsRequirementsD3D11KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR,
    #endif  // XR_KHR_D3D11_enable
    #ifdef XR_KHR_D3D12_enable
    GraphicsBindingD3D12KHR = XR_TYPE_GRAPHICS_BINDING_D3D12_KHR,
    #endif  // XR_KHR_D3D12_enable
    #ifdef XR_KHR_D3D12_enable
    SwapchainImageD3D12KHR = XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR,
    #endif  // XR_KHR_D3D12_enable
    #ifdef XR_KHR_D3D12_enable
    GraphicsRequirementsD3D12KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR,
    #endif  // XR_KHR_D3D12_enable
    #ifdef XR_EXT_eye_gaze_interaction
    SystemEyeGazeInteractionPropertiesEXT = XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT,
    #endif  // XR_EXT_eye_gaze_interaction
    #ifdef XR_EXT_eye_gaze_interaction
    EyeGazeSampleTimeEXT = XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT,
    #endif  // XR_EXT_eye_gaze_interaction
    #ifdef XR_KHR_visibility_mask
    VisibilityMaskKHR = XR_TYPE_VISIBILITY_MASK_KHR,
    #endif  // XR_KHR_visibility_mask
    #ifdef XR_KHR_visibility_mask
    EventDataVisibilityMaskChangedKHR = XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR,
    #endif  // XR_KHR_visibility_mask
    #ifdef XR_EXTX_overlay
    SessionCreateInfoOverlayEXTX = XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX,
    #endif  // XR_EXTX_overlay
    #ifdef XR_EXTX_overlay
    EventDataMainSessionVisibilityChangedEXTX = XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX,
    #endif  // XR_EXTX_overlay
    #ifdef XR_KHR_composition_layer_color_scale_bias
    CompositionLayerColorScaleBiasKHR = XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR,
    #endif  // XR_KHR_composition_layer_color_scale_bias
    #ifdef XR_MSFT_spatial_anchor
    SpatialAnchorCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_spatial_anchor
    #ifdef XR_MSFT_spatial_anchor
    SpatialAnchorSpaceCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_spatial_anchor
    #ifdef XR_FB_composition_layer_image_layout
    CompositionLayerImageLayoutFB = XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB,
    #endif  // XR_FB_composition_layer_image_layout
    #ifdef XR_FB_composition_layer_alpha_blend
    CompositionLayerAlphaBlendFB = XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB,
    #endif  // XR_FB_composition_layer_alpha_blend
    #ifdef XR_EXT_view_configuration_depth_range
    ViewConfigurationDepthRangeEXT = XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT,
    #endif  // XR_EXT_view_configuration_depth_range
    #ifdef XR_MNDX_egl_enable
    GraphicsBindingEGLMNDX = XR_TYPE_GRAPHICS_BINDING_EGL_MNDX,
    #endif  // XR_MNDX_egl_enable
    #ifdef XR_MSFT_spatial_graph_bridge
    SpatialGraphNodeSpaceCreateInfoMSFT = XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_spatial_graph_bridge
    #ifdef XR_MSFT_spatial_graph_bridge
    SpatialGraphStaticNodeBindingCreateInfoMSFT = XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_spatial_graph_bridge
    #ifdef XR_MSFT_spatial_graph_bridge
    SpatialGraphNodeBindingPropertiesGetInfoMSFT = XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT,
    #endif  // XR_MSFT_spatial_graph_bridge
    #ifdef XR_MSFT_spatial_graph_bridge
    SpatialGraphNodeBindingPropertiesMSFT = XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT,
    #endif  // XR_MSFT_spatial_graph_bridge
    #ifdef XR_EXT_hand_tracking
    SystemHandTrackingPropertiesEXT = XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT,
    #endif  // XR_EXT_hand_tracking
    #ifdef XR_EXT_hand_tracking
    HandTrackerCreateInfoEXT = XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT,
    #endif  // XR_EXT_hand_tracking
    #ifdef XR_EXT_hand_tracking
    HandJointsLocateInfoEXT = XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT,
    #endif  // XR_EXT_hand_tracking
    #ifdef XR_EXT_hand_tracking
    HandJointLocationsEXT = XR_TYPE_HAND_JOINT_LOCATIONS_EXT,
    #endif  // XR_EXT_hand_tracking
    #ifdef XR_EXT_hand_tracking
    HandJointVelocitiesEXT = XR_TYPE_HAND_JOINT_VELOCITIES_EXT,
    #endif  // XR_EXT_hand_tracking
    #ifdef XR_MSFT_hand_tracking_mesh
    SystemHandTrackingMeshPropertiesMSFT = XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT,
    #endif  // XR_MSFT_hand_tracking_mesh
    #ifdef XR_MSFT_hand_tracking_mesh
    HandMeshSpaceCreateInfoMSFT = XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_hand_tracking_mesh
    #ifdef XR_MSFT_hand_tracking_mesh
    HandMeshUpdateInfoMSFT = XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT,
    #endif  // XR_MSFT_hand_tracking_mesh
    #ifdef XR_MSFT_hand_tracking_mesh
    HandMeshMSFT = XR_TYPE_HAND_MESH_MSFT,
    #endif  // XR_MSFT_hand_tracking_mesh
    #ifdef XR_MSFT_hand_tracking_mesh
    HandPoseTypeInfoMSFT = XR_TYPE_HAND_POSE_TYPE_INFO_MSFT,
    #endif  // XR_MSFT_hand_tracking_mesh
    #ifdef XR_MSFT_secondary_view_configuration
    SecondaryViewConfigurationSessionBeginInfoMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_secondary_view_configuration
    SecondaryViewConfigurationStateMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_secondary_view_configuration
    SecondaryViewConfigurationFrameStateMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_secondary_view_configuration
    SecondaryViewConfigurationFrameEndInfoMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_secondary_view_configuration
    SecondaryViewConfigurationLayerInfoMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_secondary_view_configuration
    SecondaryViewConfigurationSwapchainCreateInfoMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_secondary_view_configuration
    #ifdef XR_MSFT_controller_model
    ControllerModelKeyStateMSFT = XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT,
    #endif  // XR_MSFT_controller_model
    #ifdef XR_MSFT_controller_model
    ControllerModelNodePropertiesMSFT = XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT,
    #endif  // XR_MSFT_controller_model
    #ifdef XR_MSFT_controller_model
    ControllerModelPropertiesMSFT = XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT,
    #endif  // XR_MSFT_controller_model
    #ifdef XR_MSFT_controller_model
    ControllerModelNodeStateMSFT = XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT,
    #endif  // XR_MSFT_controller_model
    #ifdef XR_MSFT_controller_model
    ControllerModelStateMSFT = XR_TYPE_CONTROLLER_MODEL_STATE_MSFT,
    #endif  // XR_MSFT_controller_model
    #ifdef XR_EPIC_view_configuration_fov
    ViewConfigurationViewFovEPIC = XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC,
    #endif  // XR_EPIC_view_configuration_fov
    #ifdef XR_MSFT_holographic_window_attachment
    HolographicWindowAttachmentMSFT = XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT,
    #endif  // XR_MSFT_holographic_window_attachment
    #ifdef XR_MSFT_composition_layer_reprojection
    CompositionLayerReprojectionInfoMSFT = XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT,
    #endif  // XR_MSFT_composition_layer_reprojection
    #ifdef XR_MSFT_composition_layer_reprojection
    CompositionLayerReprojectionPlaneOverrideMSFT = XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT,
    #endif  // XR_MSFT_composition_layer_reprojection
    #ifdef XR_FB_android_surface_swapchain_create
    AndroidSurfaceSwapchainCreateInfoFB = XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB,
    #endif  // XR_FB_android_surface_swapchain_create
    #ifdef XR_FB_composition_layer_secure_content
    CompositionLayerSecureContentFB = XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB,
    #endif  // XR_FB_composition_layer_secure_content
    #ifdef XR_FB_body_tracking
    BodyTrackerCreateInfoFB = XR_TYPE_BODY_TRACKER_CREATE_INFO_FB,
    #endif  // XR_FB_body_tracking
    #ifdef XR_FB_body_tracking
    BodyJointsLocateInfoFB = XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB,
    #endif  // XR_FB_body_tracking
    #ifdef XR_FB_body_tracking
    SystemBodyTrackingPropertiesFB = XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB,
    #endif  // XR_FB_body_tracking
    #ifdef XR_FB_body_tracking
    BodyJointLocationsFB = XR_TYPE_BODY_JOINT_LOCATIONS_FB,
    #endif  // XR_FB_body_tracking
    #ifdef XR_FB_body_tracking
    BodySkeletonFB = XR_TYPE_BODY_SKELETON_FB,
    #endif  // XR_FB_body_tracking
    #ifdef XR_EXT_dpad_binding
    InteractionProfileDpadBindingEXT = XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT,
    #endif  // XR_EXT_dpad_binding
    #ifdef XR_VALVE_analog_threshold
    InteractionProfileAnalogThresholdVALVE = XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE,
    #endif  // XR_VALVE_analog_threshold
    #ifdef XR_EXT_hand_joints_motion_range
    HandJointsMotionRangeInfoEXT = XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT,
    #endif  // XR_EXT_hand_joints_motion_range
    #ifdef XR_KHR_loader_init_android
    LoaderInitInfoAndroidKHR = XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR,
    #endif  // XR_KHR_loader_init_android
    #ifdef XR_KHR_vulkan_enable2
    VulkanInstanceCreateInfoKHR = XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR,
    #endif  // XR_KHR_vulkan_enable2
    #ifdef XR_KHR_vulkan_enable2
    VulkanDeviceCreateInfoKHR = XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR,
    #endif  // XR_KHR_vulkan_enable2
    #ifdef XR_KHR_vulkan_enable2
    VulkanGraphicsDeviceGetInfoKHR = XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR,
    #endif  // XR_KHR_vulkan_enable2
    #ifdef XR_KHR_vulkan_enable2
    GraphicsBindingVulkan2KHR = XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR,
    #endif  // XR_KHR_vulkan_enable2
    #ifdef XR_KHR_vulkan_enable2
    SwapchainImageVulkan2KHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN2_KHR,
    #endif  // XR_KHR_vulkan_enable2
    #ifdef XR_KHR_vulkan_enable2
    GraphicsRequirementsVulkan2KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN2_KHR,
    #endif  // XR_KHR_vulkan_enable2
    #ifdef XR_KHR_composition_layer_equirect2
    CompositionLayerEquirect2KHR = XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR,
    #endif  // XR_KHR_composition_layer_equirect2
    #ifdef XR_MSFT_scene_understanding
    SceneObserverCreateInfoMSFT = XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneCreateInfoMSFT = XR_TYPE_SCENE_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    NewSceneComputeInfoMSFT = XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    VisualMeshComputeLodInfoMSFT = XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneComponentsMSFT = XR_TYPE_SCENE_COMPONENTS_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneComponentsGetInfoMSFT = XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneComponentLocationsMSFT = XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneComponentsLocateInfoMSFT = XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneObjectsMSFT = XR_TYPE_SCENE_OBJECTS_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneComponentParentFilterInfoMSFT = XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneObjectTypesFilterInfoMSFT = XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ScenePlanesMSFT = XR_TYPE_SCENE_PLANES_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    ScenePlaneAlignmentFilterInfoMSFT = XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMeshesMSFT = XR_TYPE_SCENE_MESHES_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMeshBuffersGetInfoMSFT = XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMeshBuffersMSFT = XR_TYPE_SCENE_MESH_BUFFERS_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMeshVertexBufferMSFT = XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMeshIndicesUint32MSFT = XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMeshIndicesUint16MSFT = XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding_serialization
    SerializedSceneFragmentDataGetInfoMSFT = XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding_serialization
    #ifdef XR_MSFT_scene_understanding_serialization
    SceneDeserializeInfoMSFT = XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT,
    #endif  // XR_MSFT_scene_understanding_serialization
    #ifdef XR_FB_display_refresh_rate
    EventDataDisplayRefreshRateChangedFB = XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB,
    #endif  // XR_FB_display_refresh_rate
    #ifdef XR_HTCX_vive_tracker_interaction
    ViveTrackerPathsHTCX = XR_TYPE_VIVE_TRACKER_PATHS_HTCX,
    #endif  // XR_HTCX_vive_tracker_interaction
    #ifdef XR_HTCX_vive_tracker_interaction
    EventDataViveTrackerConnectedHTCX = XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX,
    #endif  // XR_HTCX_vive_tracker_interaction
    #ifdef XR_HTC_facial_tracking
    SystemFacialTrackingPropertiesHTC = XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC,
    #endif  // XR_HTC_facial_tracking
    #ifdef XR_HTC_facial_tracking
    FacialTrackerCreateInfoHTC = XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC,
    #endif  // XR_HTC_facial_tracking
    #ifdef XR_HTC_facial_tracking
    FacialExpressionsHTC = XR_TYPE_FACIAL_EXPRESSIONS_HTC,
    #endif  // XR_HTC_facial_tracking
    #ifdef XR_FB_color_space
    SystemColorSpacePropertiesFB = XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB,
    #endif  // XR_FB_color_space
    #ifdef XR_FB_hand_tracking_mesh
    HandTrackingMeshFB = XR_TYPE_HAND_TRACKING_MESH_FB,
    #endif  // XR_FB_hand_tracking_mesh
    #ifdef XR_FB_hand_tracking_mesh
    HandTrackingScaleFB = XR_TYPE_HAND_TRACKING_SCALE_FB,
    #endif  // XR_FB_hand_tracking_mesh
    #ifdef XR_FB_hand_tracking_aim
    HandTrackingAimStateFB = XR_TYPE_HAND_TRACKING_AIM_STATE_FB,
    #endif  // XR_FB_hand_tracking_aim
    #ifdef XR_FB_hand_tracking_capsules
    HandTrackingCapsulesStateFB = XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB,
    #endif  // XR_FB_hand_tracking_capsules
    #ifdef XR_FB_spatial_entity
    SystemSpatialEntityPropertiesFB = XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    SpatialAnchorCreateInfoFB = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    SpaceComponentStatusSetInfoFB = XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    SpaceComponentStatusFB = XR_TYPE_SPACE_COMPONENT_STATUS_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    EventDataSpatialAnchorCreateCompleteFB = XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_spatial_entity
    EventDataSpaceSetStatusCompleteFB = XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity
    #ifdef XR_FB_foveation
    FoveationProfileCreateInfoFB = XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB,
    #endif  // XR_FB_foveation
    #ifdef XR_FB_foveation
    SwapchainCreateInfoFoveationFB = XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB,
    #endif  // XR_FB_foveation
    #ifdef XR_FB_foveation
    SwapchainStateFoveationFB = XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB,
    #endif  // XR_FB_foveation
    #ifdef XR_FB_foveation_configuration
    FoveationLevelProfileCreateInfoFB = XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB,
    #endif  // XR_FB_foveation_configuration
    #ifdef XR_FB_keyboard_tracking
    KeyboardSpaceCreateInfoFB = XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB,
    #endif  // XR_FB_keyboard_tracking
    #ifdef XR_FB_keyboard_tracking
    KeyboardTrackingQueryFB = XR_TYPE_KEYBOARD_TRACKING_QUERY_FB,
    #endif  // XR_FB_keyboard_tracking
    #ifdef XR_FB_keyboard_tracking
    SystemKeyboardTrackingPropertiesFB = XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB,
    #endif  // XR_FB_keyboard_tracking
    #ifdef XR_FB_triangle_mesh
    TriangleMeshCreateInfoFB = XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB,
    #endif  // XR_FB_triangle_mesh
    #ifdef XR_FB_passthrough
    SystemPassthroughPropertiesFB = XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughCreateInfoFB = XR_TYPE_PASSTHROUGH_CREATE_INFO_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughLayerCreateInfoFB = XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    CompositionLayerPassthroughFB = XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    GeometryInstanceCreateInfoFB = XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    GeometryInstanceTransformFB = XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    SystemPassthroughProperties2FB = XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughStyleFB = XR_TYPE_PASSTHROUGH_STYLE_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughColorMapMonoToRgbaFB = XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughColorMapMonoToMonoFB = XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughBrightnessContrastSaturationFB = XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    EventDataPassthroughStateChangedFB = XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_render_model
    RenderModelPathInfoFB = XR_TYPE_RENDER_MODEL_PATH_INFO_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_FB_render_model
    RenderModelPropertiesFB = XR_TYPE_RENDER_MODEL_PROPERTIES_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_FB_render_model
    RenderModelBufferFB = XR_TYPE_RENDER_MODEL_BUFFER_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_FB_render_model
    RenderModelLoadInfoFB = XR_TYPE_RENDER_MODEL_LOAD_INFO_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_FB_render_model
    SystemRenderModelPropertiesFB = XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_FB_render_model
    RenderModelCapabilitiesRequestFB = XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB,
    #endif  // XR_FB_render_model
    #ifdef XR_KHR_binding_modification
    BindingModificationsKHR = XR_TYPE_BINDING_MODIFICATIONS_KHR,
    #endif  // XR_KHR_binding_modification
    #ifdef XR_VARJO_foveated_rendering
    ViewLocateFoveatedRenderingVARJO = XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO,
    #endif  // XR_VARJO_foveated_rendering
    #ifdef XR_VARJO_foveated_rendering
    FoveatedViewConfigurationViewVARJO = XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO,
    #endif  // XR_VARJO_foveated_rendering
    #ifdef XR_VARJO_foveated_rendering
    SystemFoveatedRenderingPropertiesVARJO = XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO,
    #endif  // XR_VARJO_foveated_rendering
    #ifdef XR_VARJO_composition_layer_depth_test
    CompositionLayerDepthTestVARJO = XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO,
    #endif  // XR_VARJO_composition_layer_depth_test
    #ifdef XR_VARJO_marker_tracking
    SystemMarkerTrackingPropertiesVARJO = XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO,
    #endif  // XR_VARJO_marker_tracking
    #ifdef XR_VARJO_marker_tracking
    EventDataMarkerTrackingUpdateVARJO = XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO,
    #endif  // XR_VARJO_marker_tracking
    #ifdef XR_VARJO_marker_tracking
    MarkerSpaceCreateInfoVARJO = XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO,
    #endif  // XR_VARJO_marker_tracking
    #ifdef XR_ML_frame_end_info
    FrameEndInfoML = XR_TYPE_FRAME_END_INFO_ML,
    #endif  // XR_ML_frame_end_info
    #ifdef XR_ML_global_dimmer
    GlobalDimmerFrameEndInfoML = XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML,
    #endif  // XR_ML_global_dimmer
    #ifdef XR_ML_compat
    CoordinateSpaceCreateInfoML = XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML,
    #endif  // XR_ML_compat
    #ifdef XR_ML_user_calibration
    EventDataHeadsetFitChangedML = XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML,
    #endif  // XR_ML_user_calibration
    #ifdef XR_ML_user_calibration
    EventDataEyeCalibrationChangedML = XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML,
    #endif  // XR_ML_user_calibration
    #ifdef XR_ML_user_calibration
    UserCalibrationEnableEventsInfoML = XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML,
    #endif  // XR_ML_user_calibration
    #ifdef XR_MSFT_spatial_anchor_persistence
    SpatialAnchorPersistenceInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT,
    #endif  // XR_MSFT_spatial_anchor_persistence
    #ifdef XR_MSFT_spatial_anchor_persistence
    SpatialAnchorFromPersistedAnchorCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT,
    #endif  // XR_MSFT_spatial_anchor_persistence
    #ifdef XR_MSFT_scene_marker
    SceneMarkersMSFT = XR_TYPE_SCENE_MARKERS_MSFT,
    #endif  // XR_MSFT_scene_marker
    #ifdef XR_MSFT_scene_marker
    SceneMarkerTypeFilterMSFT = XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT,
    #endif  // XR_MSFT_scene_marker
    #ifdef XR_MSFT_scene_marker
    SceneMarkerQrCodesMSFT = XR_TYPE_SCENE_MARKER_QR_CODES_MSFT,
    #endif  // XR_MSFT_scene_marker
    #ifdef XR_FB_spatial_entity_query
    SpaceQueryInfoFB = XR_TYPE_SPACE_QUERY_INFO_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_query
    SpaceQueryResultsFB = XR_TYPE_SPACE_QUERY_RESULTS_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_query
    SpaceStorageLocationFilterInfoFB = XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_query
    SpaceUuidFilterInfoFB = XR_TYPE_SPACE_UUID_FILTER_INFO_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_query
    SpaceComponentFilterInfoFB = XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_query
    EventDataSpaceQueryResultsAvailableFB = XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_query
    EventDataSpaceQueryCompleteFB = XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity_query
    #ifdef XR_FB_spatial_entity_storage
    SpaceSaveInfoFB = XR_TYPE_SPACE_SAVE_INFO_FB,
    #endif  // XR_FB_spatial_entity_storage
    #ifdef XR_FB_spatial_entity_storage
    SpaceEraseInfoFB = XR_TYPE_SPACE_ERASE_INFO_FB,
    #endif  // XR_FB_spatial_entity_storage
    #ifdef XR_FB_spatial_entity_storage
    EventDataSpaceSaveCompleteFB = XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity_storage
    #ifdef XR_FB_spatial_entity_storage
    EventDataSpaceEraseCompleteFB = XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity_storage
    #ifdef XR_FB_foveation_vulkan
    SwapchainImageFoveationVulkanFB = XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB,
    #endif  // XR_FB_foveation_vulkan
    #ifdef XR_FB_swapchain_update_state_android_surface
    SwapchainStateAndroidSurfaceDimensionsFB = XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB,
    #endif  // XR_FB_swapchain_update_state_android_surface
    #ifdef XR_FB_swapchain_update_state_opengl_es
    SwapchainStateSamplerOpenGLESFB = XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB,
    #endif  // XR_FB_swapchain_update_state_opengl_es
    #ifdef XR_FB_swapchain_update_state_vulkan
    SwapchainStateSamplerVulkanFB = XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB,
    #endif  // XR_FB_swapchain_update_state_vulkan
    #ifdef XR_FB_spatial_entity_sharing
    SpaceShareInfoFB = XR_TYPE_SPACE_SHARE_INFO_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_FB_spatial_entity_sharing
    EventDataSpaceShareCompleteFB = XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity_sharing
    #ifdef XR_FB_space_warp
    CompositionLayerSpaceWarpInfoFB = XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB,
    #endif  // XR_FB_space_warp
    #ifdef XR_FB_space_warp
    SystemSpaceWarpPropertiesFB = XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB,
    #endif  // XR_FB_space_warp
    #ifdef XR_FB_haptic_amplitude_envelope
    HapticAmplitudeEnvelopeVibrationFB = XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB,
    #endif  // XR_FB_haptic_amplitude_envelope
    #ifdef XR_FB_scene
    SemanticLabelsFB = XR_TYPE_SEMANTIC_LABELS_FB,
    #endif  // XR_FB_scene
    #ifdef XR_FB_scene
    RoomLayoutFB = XR_TYPE_ROOM_LAYOUT_FB,
    #endif  // XR_FB_scene
    #ifdef XR_FB_scene
    Boundary2DFB = XR_TYPE_BOUNDARY_2D_FB,
    #endif  // XR_FB_scene
    #ifdef XR_FB_scene
    SemanticLabelsSupportInfoFB = XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB,
    #endif  // XR_FB_scene
    #ifdef XR_ALMALENCE_digital_lens_control
    DigitalLensControlALMALENCE = XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE,
    #endif  // XR_ALMALENCE_digital_lens_control
    #ifdef XR_FB_scene_capture
    EventDataSceneCaptureCompleteFB = XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB,
    #endif  // XR_FB_scene_capture
    #ifdef XR_FB_scene_capture
    SceneCaptureRequestInfoFB = XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB,
    #endif  // XR_FB_scene_capture
    #ifdef XR_FB_spatial_entity_container
    SpaceContainerFB = XR_TYPE_SPACE_CONTAINER_FB,
    #endif  // XR_FB_spatial_entity_container
    #ifdef XR_META_foveation_eye_tracked
    FoveationEyeTrackedProfileCreateInfoMETA = XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META,
    #endif  // XR_META_foveation_eye_tracked
    #ifdef XR_META_foveation_eye_tracked
    FoveationEyeTrackedStateMETA = XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META,
    #endif  // XR_META_foveation_eye_tracked
    #ifdef XR_META_foveation_eye_tracked
    SystemFoveationEyeTrackedPropertiesMETA = XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META,
    #endif  // XR_META_foveation_eye_tracked
    #ifdef XR_FB_face_tracking
    SystemFaceTrackingPropertiesFB = XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB,
    #endif  // XR_FB_face_tracking
    #ifdef XR_FB_face_tracking
    FaceTrackerCreateInfoFB = XR_TYPE_FACE_TRACKER_CREATE_INFO_FB,
    #endif  // XR_FB_face_tracking
    #ifdef XR_FB_face_tracking
    FaceExpressionInfoFB = XR_TYPE_FACE_EXPRESSION_INFO_FB,
    #endif  // XR_FB_face_tracking
    #ifdef XR_FB_face_tracking
    FaceExpressionWeightsFB = XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB,
    #endif  // XR_FB_face_tracking
    #ifdef XR_FB_eye_tracking_social
    EyeTrackerCreateInfoFB = XR_TYPE_EYE_TRACKER_CREATE_INFO_FB,
    #endif  // XR_FB_eye_tracking_social
    #ifdef XR_FB_eye_tracking_social
    EyeGazesInfoFB = XR_TYPE_EYE_GAZES_INFO_FB,
    #endif  // XR_FB_eye_tracking_social
    #ifdef XR_FB_eye_tracking_social
    EyeGazesFB = XR_TYPE_EYE_GAZES_FB,
    #endif  // XR_FB_eye_tracking_social
    #ifdef XR_FB_eye_tracking_social
    SystemEyeTrackingPropertiesFB = XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB,
    #endif  // XR_FB_eye_tracking_social
    #ifdef XR_FB_passthrough_keyboard_hands
    PassthroughKeyboardHandsIntensityFB = XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB,
    #endif  // XR_FB_passthrough_keyboard_hands
    #ifdef XR_FB_composition_layer_settings
    CompositionLayerSettingsFB = XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB,
    #endif  // XR_FB_composition_layer_settings
    #ifdef XR_FB_haptic_pcm
    HapticPcmVibrationFB = XR_TYPE_HAPTIC_PCM_VIBRATION_FB,
    #endif  // XR_FB_haptic_pcm
    #ifdef XR_FB_haptic_pcm
    DevicePcmSampleRateStateFB = XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB,
    #endif  // XR_FB_haptic_pcm
    #ifdef XR_FB_haptic_pcm
    DevicePcmSampleRateGetInfoFB = XR_TYPE_DEVICE_PCM_SAMPLE_RATE_GET_INFO_FB,
    #endif  // XR_FB_haptic_pcm
    #ifdef XR_FB_composition_layer_depth_test
    CompositionLayerDepthTestFB = XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB,
    #endif  // XR_FB_composition_layer_depth_test
    #ifdef XR_META_local_dimming
    LocalDimmingFrameEndInfoMETA = XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META,
    #endif  // XR_META_local_dimming
    #ifdef XR_META_passthrough_preferences
    PassthroughPreferencesMETA = XR_TYPE_PASSTHROUGH_PREFERENCES_META,
    #endif  // XR_META_passthrough_preferences
    #ifdef XR_META_virtual_keyboard
    SystemVirtualKeyboardPropertiesMETA = XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardCreateInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardSpaceCreateInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardLocationInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardModelVisibilitySetInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardAnimationStateMETA = XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardModelAnimationStatesMETA = XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardTextureDataMETA = XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardInputInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardTextContextChangeInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    EventDataVirtualKeyboardCommitTextMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    EventDataVirtualKeyboardBackspaceMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    EventDataVirtualKeyboardEnterMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    EventDataVirtualKeyboardShownMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_META_virtual_keyboard
    EventDataVirtualKeyboardHiddenMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_OCULUS_external_camera
    ExternalCameraOCULUS = XR_TYPE_EXTERNAL_CAMERA_OCULUS,
    #endif  // XR_OCULUS_external_camera
    #ifdef XR_META_vulkan_swapchain_create_info
    VulkanSwapchainCreateInfoMETA = XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META,
    #endif  // XR_META_vulkan_swapchain_create_info
    #ifdef XR_META_performance_metrics
    PerformanceMetricsStateMETA = XR_TYPE_PERFORMANCE_METRICS_STATE_META,
    #endif  // XR_META_performance_metrics
    #ifdef XR_META_performance_metrics
    PerformanceMetricsCounterMETA = XR_TYPE_PERFORMANCE_METRICS_COUNTER_META,
    #endif  // XR_META_performance_metrics
    #ifdef XR_FB_spatial_entity_storage_batch
    SpaceListSaveInfoFB = XR_TYPE_SPACE_LIST_SAVE_INFO_FB,
    #endif  // XR_FB_spatial_entity_storage_batch
    #ifdef XR_FB_spatial_entity_storage_batch
    EventDataSpaceListSaveCompleteFB = XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB,
    #endif  // XR_FB_spatial_entity_storage_batch
    #ifdef XR_FB_spatial_entity_user
    SpaceUserCreateInfoFB = XR_TYPE_SPACE_USER_CREATE_INFO_FB,
    #endif  // XR_FB_spatial_entity_user
    #ifdef XR_META_headset_id
    SystemHeadsetIdPropertiesMETA = XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META,
    #endif  // XR_META_headset_id
    #ifdef XR_META_passthrough_color_lut
    SystemPassthroughColorLutPropertiesMETA = XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_META_passthrough_color_lut
    PassthroughColorLutCreateInfoMETA = XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_META_passthrough_color_lut
    PassthroughColorLutUpdateInfoMETA = XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_META_passthrough_color_lut
    PassthroughColorMapLutMETA = XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_META_passthrough_color_lut
    PassthroughColorMapInterpolatedLutMETA = XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_HTC_passthrough
    PassthroughCreateInfoHTC = XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC,
    #endif  // XR_HTC_passthrough
    #ifdef XR_HTC_passthrough
    PassthroughColorHTC = XR_TYPE_PASSTHROUGH_COLOR_HTC,
    #endif  // XR_HTC_passthrough
    #ifdef XR_HTC_passthrough
    PassthroughMeshTransformInfoHTC = XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC,
    #endif  // XR_HTC_passthrough
    #ifdef XR_HTC_passthrough
    CompositionLayerPassthroughHTC = XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC,
    #endif  // XR_HTC_passthrough
    #ifdef XR_HTC_foveation
    FoveationApplyInfoHTC = XR_TYPE_FOVEATION_APPLY_INFO_HTC,
    #endif  // XR_HTC_foveation
    #ifdef XR_HTC_foveation
    FoveationDynamicModeInfoHTC = XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC,
    #endif  // XR_HTC_foveation
    #ifdef XR_HTC_foveation
    FoveationCustomModeInfoHTC = XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC,
    #endif  // XR_HTC_foveation
    #ifdef XR_EXT_active_action_set_priority
    ActiveActionSetPrioritiesEXT = XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT,
    #endif  // XR_EXT_active_action_set_priority
    #ifdef XR_MNDX_force_feedback_curl
    SystemForceFeedbackCurlPropertiesMNDX = XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX,
    #endif  // XR_MNDX_force_feedback_curl
    #ifdef XR_MNDX_force_feedback_curl
    ForceFeedbackCurlApplyLocationsMNDX = XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX,
    #endif  // XR_MNDX_force_feedback_curl
    #ifdef XR_EXT_hand_tracking_data_source
    HandTrackingDataSourceInfoEXT = XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT,
    #endif  // XR_EXT_hand_tracking_data_source
    #ifdef XR_EXT_hand_tracking_data_source
    HandTrackingDataSourceStateEXT = XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT,
    #endif  // XR_EXT_hand_tracking_data_source
    #ifdef XR_EXT_plane_detection
    PlaneDetectorCreateInfoEXT = XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    PlaneDetectorBeginInfoEXT = XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    PlaneDetectorGetInfoEXT = XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    PlaneDetectorLocationsEXT = XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    PlaneDetectorLocationEXT = XR_TYPE_PLANE_DETECTOR_LOCATION_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    PlaneDetectorPolygonBufferEXT = XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT,
    #endif  // XR_EXT_plane_detection
    #ifdef XR_EXT_plane_detection
    SystemPlaneDetectionPropertiesEXT = XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT,
    #endif  // XR_EXT_plane_detection
};
 static_assert(sizeof(StructureType) == sizeof(XrStructureType), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrStructureType value from a StructureType.
 * 
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrStructureType get(StructureType const& v) {
    return static_cast<XrStructureType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a StructureType value as a const char *.
 * 
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(StructureType value) {
    switch (value) {
            
        case StructureType::Unknown:
            return "Unknown";
            
            
        case StructureType::APILayerProperties:
            return "APILayerProperties";
            
            
        case StructureType::ExtensionProperties:
            return "ExtensionProperties";
            
            
        case StructureType::InstanceCreateInfo:
            return "InstanceCreateInfo";
            
            
        case StructureType::SystemGetInfo:
            return "SystemGetInfo";
            
            
        case StructureType::SystemProperties:
            return "SystemProperties";
            
            
        case StructureType::ViewLocateInfo:
            return "ViewLocateInfo";
            
            
        case StructureType::View:
            return "View";
            
            
        case StructureType::SessionCreateInfo:
            return "SessionCreateInfo";
            
            
        case StructureType::SwapchainCreateInfo:
            return "SwapchainCreateInfo";
            
            
        case StructureType::SessionBeginInfo:
            return "SessionBeginInfo";
            
            
        case StructureType::ViewState:
            return "ViewState";
            
            
        case StructureType::FrameEndInfo:
            return "FrameEndInfo";
            
            
        case StructureType::HapticVibration:
            return "HapticVibration";
            
            
        case StructureType::EventDataBuffer:
            return "EventDataBuffer";
            
            
        case StructureType::EventDataInstanceLossPending:
            return "EventDataInstanceLossPending";
            
            
        case StructureType::EventDataSessionStateChanged:
            return "EventDataSessionStateChanged";
            
            
        case StructureType::ActionStateBoolean:
            return "ActionStateBoolean";
            
            
        case StructureType::ActionStateFloat:
            return "ActionStateFloat";
            
            
        case StructureType::ActionStateVector2F:
            return "ActionStateVector2F";
            
            
        case StructureType::ActionStatePose:
            return "ActionStatePose";
            
            
        case StructureType::ActionSetCreateInfo:
            return "ActionSetCreateInfo";
            
            
        case StructureType::ActionCreateInfo:
            return "ActionCreateInfo";
            
            
        case StructureType::InstanceProperties:
            return "InstanceProperties";
            
            
        case StructureType::FrameWaitInfo:
            return "FrameWaitInfo";
            
            
        case StructureType::CompositionLayerProjection:
            return "CompositionLayerProjection";
            
            
        case StructureType::CompositionLayerQuad:
            return "CompositionLayerQuad";
            
            
        case StructureType::ReferenceSpaceCreateInfo:
            return "ReferenceSpaceCreateInfo";
            
            
        case StructureType::ActionSpaceCreateInfo:
            return "ActionSpaceCreateInfo";
            
            
        case StructureType::EventDataReferenceSpaceChangePending:
            return "EventDataReferenceSpaceChangePending";
            
            
        case StructureType::ViewConfigurationView:
            return "ViewConfigurationView";
            
            
        case StructureType::SpaceLocation:
            return "SpaceLocation";
            
            
        case StructureType::SpaceVelocity:
            return "SpaceVelocity";
            
            
        case StructureType::FrameState:
            return "FrameState";
            
            
        case StructureType::ViewConfigurationProperties:
            return "ViewConfigurationProperties";
            
            
        case StructureType::FrameBeginInfo:
            return "FrameBeginInfo";
            
            
        case StructureType::CompositionLayerProjectionView:
            return "CompositionLayerProjectionView";
            
            
        case StructureType::EventDataEventsLost:
            return "EventDataEventsLost";
            
            
        case StructureType::InteractionProfileSuggestedBinding:
            return "InteractionProfileSuggestedBinding";
            
            
        case StructureType::EventDataInteractionProfileChanged:
            return "EventDataInteractionProfileChanged";
            
            
        case StructureType::InteractionProfileState:
            return "InteractionProfileState";
            
            
        case StructureType::SwapchainImageAcquireInfo:
            return "SwapchainImageAcquireInfo";
            
            
        case StructureType::SwapchainImageWaitInfo:
            return "SwapchainImageWaitInfo";
            
            
        case StructureType::SwapchainImageReleaseInfo:
            return "SwapchainImageReleaseInfo";
            
            
        case StructureType::ActionStateGetInfo:
            return "ActionStateGetInfo";
            
            
        case StructureType::HapticActionInfo:
            return "HapticActionInfo";
            
            
        case StructureType::SessionActionSetsAttachInfo:
            return "SessionActionSetsAttachInfo";
            
            
        case StructureType::ActionsSyncInfo:
            return "ActionsSyncInfo";
            
            
        case StructureType::BoundSourcesForActionEnumerateInfo:
            return "BoundSourcesForActionEnumerateInfo";
            
            
        case StructureType::InputSourceLocalizedNameGetInfo:
            return "InputSourceLocalizedNameGetInfo";
            
            #ifdef XR_KHR_composition_layer_cube
        case StructureType::CompositionLayerCubeKHR:
            return "CompositionLayerCubeKHR";
            #endif  // XR_KHR_composition_layer_cube
            #ifdef XR_KHR_android_create_instance
        case StructureType::InstanceCreateInfoAndroidKHR:
            return "InstanceCreateInfoAndroidKHR";
            #endif  // XR_KHR_android_create_instance
            #ifdef XR_KHR_composition_layer_depth
        case StructureType::CompositionLayerDepthInfoKHR:
            return "CompositionLayerDepthInfoKHR";
            #endif  // XR_KHR_composition_layer_depth
            #ifdef XR_KHR_vulkan_swapchain_format_list
        case StructureType::VulkanSwapchainFormatListCreateInfoKHR:
            return "VulkanSwapchainFormatListCreateInfoKHR";
            #endif  // XR_KHR_vulkan_swapchain_format_list
            #ifdef XR_EXT_performance_settings
        case StructureType::EventDataPerfSettingsEXT:
            return "EventDataPerfSettingsEXT";
            #endif  // XR_EXT_performance_settings
            #ifdef XR_KHR_composition_layer_cylinder
        case StructureType::CompositionLayerCylinderKHR:
            return "CompositionLayerCylinderKHR";
            #endif  // XR_KHR_composition_layer_cylinder
            #ifdef XR_KHR_composition_layer_equirect
        case StructureType::CompositionLayerEquirectKHR:
            return "CompositionLayerEquirectKHR";
            #endif  // XR_KHR_composition_layer_equirect
            #ifdef XR_EXT_debug_utils
        case StructureType::DebugUtilsObjectNameInfoEXT:
            return "DebugUtilsObjectNameInfoEXT";
            #endif  // XR_EXT_debug_utils
            #ifdef XR_EXT_debug_utils
        case StructureType::DebugUtilsMessengerCallbackDataEXT:
            return "DebugUtilsMessengerCallbackDataEXT";
            #endif  // XR_EXT_debug_utils
            #ifdef XR_EXT_debug_utils
        case StructureType::DebugUtilsMessengerCreateInfoEXT:
            return "DebugUtilsMessengerCreateInfoEXT";
            #endif  // XR_EXT_debug_utils
            #ifdef XR_EXT_debug_utils
        case StructureType::DebugUtilsLabelEXT:
            return "DebugUtilsLabelEXT";
            #endif  // XR_EXT_debug_utils
            #ifdef XR_KHR_opengl_enable
        case StructureType::GraphicsBindingOpenGLWin32KHR:
            return "GraphicsBindingOpenGLWin32KHR";
            #endif  // XR_KHR_opengl_enable
            #ifdef XR_KHR_opengl_enable
        case StructureType::GraphicsBindingOpenGLXlibKHR:
            return "GraphicsBindingOpenGLXlibKHR";
            #endif  // XR_KHR_opengl_enable
            #ifdef XR_KHR_opengl_enable
        case StructureType::GraphicsBindingOpenGLXcbKHR:
            return "GraphicsBindingOpenGLXcbKHR";
            #endif  // XR_KHR_opengl_enable
            #ifdef XR_KHR_opengl_enable
        case StructureType::GraphicsBindingOpenGLWaylandKHR:
            return "GraphicsBindingOpenGLWaylandKHR";
            #endif  // XR_KHR_opengl_enable
            #ifdef XR_KHR_opengl_enable
        case StructureType::SwapchainImageOpenGLKHR:
            return "SwapchainImageOpenGLKHR";
            #endif  // XR_KHR_opengl_enable
            #ifdef XR_KHR_opengl_enable
        case StructureType::GraphicsRequirementsOpenGLKHR:
            return "GraphicsRequirementsOpenGLKHR";
            #endif  // XR_KHR_opengl_enable
            #ifdef XR_KHR_opengl_es_enable
        case StructureType::GraphicsBindingOpenGLESAndroidKHR:
            return "GraphicsBindingOpenGLESAndroidKHR";
            #endif  // XR_KHR_opengl_es_enable
            #ifdef XR_KHR_opengl_es_enable
        case StructureType::SwapchainImageOpenGLESKHR:
            return "SwapchainImageOpenGLESKHR";
            #endif  // XR_KHR_opengl_es_enable
            #ifdef XR_KHR_opengl_es_enable
        case StructureType::GraphicsRequirementsOpenGLESKHR:
            return "GraphicsRequirementsOpenGLESKHR";
            #endif  // XR_KHR_opengl_es_enable
            #ifdef XR_KHR_vulkan_enable
        case StructureType::GraphicsBindingVulkanKHR:
            return "GraphicsBindingVulkanKHR";
            #endif  // XR_KHR_vulkan_enable
            #ifdef XR_KHR_vulkan_enable
        case StructureType::SwapchainImageVulkanKHR:
            return "SwapchainImageVulkanKHR";
            #endif  // XR_KHR_vulkan_enable
            #ifdef XR_KHR_vulkan_enable
        case StructureType::GraphicsRequirementsVulkanKHR:
            return "GraphicsRequirementsVulkanKHR";
            #endif  // XR_KHR_vulkan_enable
            #ifdef XR_KHR_D3D11_enable
        case StructureType::GraphicsBindingD3D11KHR:
            return "GraphicsBindingD3D11KHR";
            #endif  // XR_KHR_D3D11_enable
            #ifdef XR_KHR_D3D11_enable
        case StructureType::SwapchainImageD3D11KHR:
            return "SwapchainImageD3D11KHR";
            #endif  // XR_KHR_D3D11_enable
            #ifdef XR_KHR_D3D11_enable
        case StructureType::GraphicsRequirementsD3D11KHR:
            return "GraphicsRequirementsD3D11KHR";
            #endif  // XR_KHR_D3D11_enable
            #ifdef XR_KHR_D3D12_enable
        case StructureType::GraphicsBindingD3D12KHR:
            return "GraphicsBindingD3D12KHR";
            #endif  // XR_KHR_D3D12_enable
            #ifdef XR_KHR_D3D12_enable
        case StructureType::SwapchainImageD3D12KHR:
            return "SwapchainImageD3D12KHR";
            #endif  // XR_KHR_D3D12_enable
            #ifdef XR_KHR_D3D12_enable
        case StructureType::GraphicsRequirementsD3D12KHR:
            return "GraphicsRequirementsD3D12KHR";
            #endif  // XR_KHR_D3D12_enable
            #ifdef XR_EXT_eye_gaze_interaction
        case StructureType::SystemEyeGazeInteractionPropertiesEXT:
            return "SystemEyeGazeInteractionPropertiesEXT";
            #endif  // XR_EXT_eye_gaze_interaction
            #ifdef XR_EXT_eye_gaze_interaction
        case StructureType::EyeGazeSampleTimeEXT:
            return "EyeGazeSampleTimeEXT";
            #endif  // XR_EXT_eye_gaze_interaction
            #ifdef XR_KHR_visibility_mask
        case StructureType::VisibilityMaskKHR:
            return "VisibilityMaskKHR";
            #endif  // XR_KHR_visibility_mask
            #ifdef XR_KHR_visibility_mask
        case StructureType::EventDataVisibilityMaskChangedKHR:
            return "EventDataVisibilityMaskChangedKHR";
            #endif  // XR_KHR_visibility_mask
            #ifdef XR_EXTX_overlay
        case StructureType::SessionCreateInfoOverlayEXTX:
            return "SessionCreateInfoOverlayEXTX";
            #endif  // XR_EXTX_overlay
            #ifdef XR_EXTX_overlay
        case StructureType::EventDataMainSessionVisibilityChangedEXTX:
            return "EventDataMainSessionVisibilityChangedEXTX";
            #endif  // XR_EXTX_overlay
            #ifdef XR_KHR_composition_layer_color_scale_bias
        case StructureType::CompositionLayerColorScaleBiasKHR:
            return "CompositionLayerColorScaleBiasKHR";
            #endif  // XR_KHR_composition_layer_color_scale_bias
            #ifdef XR_MSFT_spatial_anchor
        case StructureType::SpatialAnchorCreateInfoMSFT:
            return "SpatialAnchorCreateInfoMSFT";
            #endif  // XR_MSFT_spatial_anchor
            #ifdef XR_MSFT_spatial_anchor
        case StructureType::SpatialAnchorSpaceCreateInfoMSFT:
            return "SpatialAnchorSpaceCreateInfoMSFT";
            #endif  // XR_MSFT_spatial_anchor
            #ifdef XR_FB_composition_layer_image_layout
        case StructureType::CompositionLayerImageLayoutFB:
            return "CompositionLayerImageLayoutFB";
            #endif  // XR_FB_composition_layer_image_layout
            #ifdef XR_FB_composition_layer_alpha_blend
        case StructureType::CompositionLayerAlphaBlendFB:
            return "CompositionLayerAlphaBlendFB";
            #endif  // XR_FB_composition_layer_alpha_blend
            #ifdef XR_EXT_view_configuration_depth_range
        case StructureType::ViewConfigurationDepthRangeEXT:
            return "ViewConfigurationDepthRangeEXT";
            #endif  // XR_EXT_view_configuration_depth_range
            #ifdef XR_MNDX_egl_enable
        case StructureType::GraphicsBindingEGLMNDX:
            return "GraphicsBindingEGLMNDX";
            #endif  // XR_MNDX_egl_enable
            #ifdef XR_MSFT_spatial_graph_bridge
        case StructureType::SpatialGraphNodeSpaceCreateInfoMSFT:
            return "SpatialGraphNodeSpaceCreateInfoMSFT";
            #endif  // XR_MSFT_spatial_graph_bridge
            #ifdef XR_MSFT_spatial_graph_bridge
        case StructureType::SpatialGraphStaticNodeBindingCreateInfoMSFT:
            return "SpatialGraphStaticNodeBindingCreateInfoMSFT";
            #endif  // XR_MSFT_spatial_graph_bridge
            #ifdef XR_MSFT_spatial_graph_bridge
        case StructureType::SpatialGraphNodeBindingPropertiesGetInfoMSFT:
            return "SpatialGraphNodeBindingPropertiesGetInfoMSFT";
            #endif  // XR_MSFT_spatial_graph_bridge
            #ifdef XR_MSFT_spatial_graph_bridge
        case StructureType::SpatialGraphNodeBindingPropertiesMSFT:
            return "SpatialGraphNodeBindingPropertiesMSFT";
            #endif  // XR_MSFT_spatial_graph_bridge
            #ifdef XR_EXT_hand_tracking
        case StructureType::SystemHandTrackingPropertiesEXT:
            return "SystemHandTrackingPropertiesEXT";
            #endif  // XR_EXT_hand_tracking
            #ifdef XR_EXT_hand_tracking
        case StructureType::HandTrackerCreateInfoEXT:
            return "HandTrackerCreateInfoEXT";
            #endif  // XR_EXT_hand_tracking
            #ifdef XR_EXT_hand_tracking
        case StructureType::HandJointsLocateInfoEXT:
            return "HandJointsLocateInfoEXT";
            #endif  // XR_EXT_hand_tracking
            #ifdef XR_EXT_hand_tracking
        case StructureType::HandJointLocationsEXT:
            return "HandJointLocationsEXT";
            #endif  // XR_EXT_hand_tracking
            #ifdef XR_EXT_hand_tracking
        case StructureType::HandJointVelocitiesEXT:
            return "HandJointVelocitiesEXT";
            #endif  // XR_EXT_hand_tracking
            #ifdef XR_MSFT_hand_tracking_mesh
        case StructureType::SystemHandTrackingMeshPropertiesMSFT:
            return "SystemHandTrackingMeshPropertiesMSFT";
            #endif  // XR_MSFT_hand_tracking_mesh
            #ifdef XR_MSFT_hand_tracking_mesh
        case StructureType::HandMeshSpaceCreateInfoMSFT:
            return "HandMeshSpaceCreateInfoMSFT";
            #endif  // XR_MSFT_hand_tracking_mesh
            #ifdef XR_MSFT_hand_tracking_mesh
        case StructureType::HandMeshUpdateInfoMSFT:
            return "HandMeshUpdateInfoMSFT";
            #endif  // XR_MSFT_hand_tracking_mesh
            #ifdef XR_MSFT_hand_tracking_mesh
        case StructureType::HandMeshMSFT:
            return "HandMeshMSFT";
            #endif  // XR_MSFT_hand_tracking_mesh
            #ifdef XR_MSFT_hand_tracking_mesh
        case StructureType::HandPoseTypeInfoMSFT:
            return "HandPoseTypeInfoMSFT";
            #endif  // XR_MSFT_hand_tracking_mesh
            #ifdef XR_MSFT_secondary_view_configuration
        case StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT:
            return "SecondaryViewConfigurationSessionBeginInfoMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_secondary_view_configuration
        case StructureType::SecondaryViewConfigurationStateMSFT:
            return "SecondaryViewConfigurationStateMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_secondary_view_configuration
        case StructureType::SecondaryViewConfigurationFrameStateMSFT:
            return "SecondaryViewConfigurationFrameStateMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_secondary_view_configuration
        case StructureType::SecondaryViewConfigurationFrameEndInfoMSFT:
            return "SecondaryViewConfigurationFrameEndInfoMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_secondary_view_configuration
        case StructureType::SecondaryViewConfigurationLayerInfoMSFT:
            return "SecondaryViewConfigurationLayerInfoMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_secondary_view_configuration
        case StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT:
            return "SecondaryViewConfigurationSwapchainCreateInfoMSFT";
            #endif  // XR_MSFT_secondary_view_configuration
            #ifdef XR_MSFT_controller_model
        case StructureType::ControllerModelKeyStateMSFT:
            return "ControllerModelKeyStateMSFT";
            #endif  // XR_MSFT_controller_model
            #ifdef XR_MSFT_controller_model
        case StructureType::ControllerModelNodePropertiesMSFT:
            return "ControllerModelNodePropertiesMSFT";
            #endif  // XR_MSFT_controller_model
            #ifdef XR_MSFT_controller_model
        case StructureType::ControllerModelPropertiesMSFT:
            return "ControllerModelPropertiesMSFT";
            #endif  // XR_MSFT_controller_model
            #ifdef XR_MSFT_controller_model
        case StructureType::ControllerModelNodeStateMSFT:
            return "ControllerModelNodeStateMSFT";
            #endif  // XR_MSFT_controller_model
            #ifdef XR_MSFT_controller_model
        case StructureType::ControllerModelStateMSFT:
            return "ControllerModelStateMSFT";
            #endif  // XR_MSFT_controller_model
            #ifdef XR_EPIC_view_configuration_fov
        case StructureType::ViewConfigurationViewFovEPIC:
            return "ViewConfigurationViewFovEPIC";
            #endif  // XR_EPIC_view_configuration_fov
            #ifdef XR_MSFT_holographic_window_attachment
        case StructureType::HolographicWindowAttachmentMSFT:
            return "HolographicWindowAttachmentMSFT";
            #endif  // XR_MSFT_holographic_window_attachment
            #ifdef XR_MSFT_composition_layer_reprojection
        case StructureType::CompositionLayerReprojectionInfoMSFT:
            return "CompositionLayerReprojectionInfoMSFT";
            #endif  // XR_MSFT_composition_layer_reprojection
            #ifdef XR_MSFT_composition_layer_reprojection
        case StructureType::CompositionLayerReprojectionPlaneOverrideMSFT:
            return "CompositionLayerReprojectionPlaneOverrideMSFT";
            #endif  // XR_MSFT_composition_layer_reprojection
            #ifdef XR_FB_android_surface_swapchain_create
        case StructureType::AndroidSurfaceSwapchainCreateInfoFB:
            return "AndroidSurfaceSwapchainCreateInfoFB";
            #endif  // XR_FB_android_surface_swapchain_create
            #ifdef XR_FB_composition_layer_secure_content
        case StructureType::CompositionLayerSecureContentFB:
            return "CompositionLayerSecureContentFB";
            #endif  // XR_FB_composition_layer_secure_content
            #ifdef XR_FB_body_tracking
        case StructureType::BodyTrackerCreateInfoFB:
            return "BodyTrackerCreateInfoFB";
            #endif  // XR_FB_body_tracking
            #ifdef XR_FB_body_tracking
        case StructureType::BodyJointsLocateInfoFB:
            return "BodyJointsLocateInfoFB";
            #endif  // XR_FB_body_tracking
            #ifdef XR_FB_body_tracking
        case StructureType::SystemBodyTrackingPropertiesFB:
            return "SystemBodyTrackingPropertiesFB";
            #endif  // XR_FB_body_tracking
            #ifdef XR_FB_body_tracking
        case StructureType::BodyJointLocationsFB:
            return "BodyJointLocationsFB";
            #endif  // XR_FB_body_tracking
            #ifdef XR_FB_body_tracking
        case StructureType::BodySkeletonFB:
            return "BodySkeletonFB";
            #endif  // XR_FB_body_tracking
            #ifdef XR_EXT_dpad_binding
        case StructureType::InteractionProfileDpadBindingEXT:
            return "InteractionProfileDpadBindingEXT";
            #endif  // XR_EXT_dpad_binding
            #ifdef XR_VALVE_analog_threshold
        case StructureType::InteractionProfileAnalogThresholdVALVE:
            return "InteractionProfileAnalogThresholdVALVE";
            #endif  // XR_VALVE_analog_threshold
            #ifdef XR_EXT_hand_joints_motion_range
        case StructureType::HandJointsMotionRangeInfoEXT:
            return "HandJointsMotionRangeInfoEXT";
            #endif  // XR_EXT_hand_joints_motion_range
            #ifdef XR_KHR_loader_init_android
        case StructureType::LoaderInitInfoAndroidKHR:
            return "LoaderInitInfoAndroidKHR";
            #endif  // XR_KHR_loader_init_android
            #ifdef XR_KHR_vulkan_enable2
        case StructureType::VulkanInstanceCreateInfoKHR:
            return "VulkanInstanceCreateInfoKHR";
            #endif  // XR_KHR_vulkan_enable2
            #ifdef XR_KHR_vulkan_enable2
        case StructureType::VulkanDeviceCreateInfoKHR:
            return "VulkanDeviceCreateInfoKHR";
            #endif  // XR_KHR_vulkan_enable2
            #ifdef XR_KHR_vulkan_enable2
        case StructureType::VulkanGraphicsDeviceGetInfoKHR:
            return "VulkanGraphicsDeviceGetInfoKHR";
            #endif  // XR_KHR_vulkan_enable2
        // GraphicsBindingVulkan2KHR is an alias for GraphicsBindingVulkanKHR
        // SwapchainImageVulkan2KHR is an alias for SwapchainImageVulkanKHR
        // GraphicsRequirementsVulkan2KHR is an alias for GraphicsRequirementsVulkanKHR
            #ifdef XR_KHR_composition_layer_equirect2
        case StructureType::CompositionLayerEquirect2KHR:
            return "CompositionLayerEquirect2KHR";
            #endif  // XR_KHR_composition_layer_equirect2
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneObserverCreateInfoMSFT:
            return "SceneObserverCreateInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneCreateInfoMSFT:
            return "SceneCreateInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::NewSceneComputeInfoMSFT:
            return "NewSceneComputeInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::VisualMeshComputeLodInfoMSFT:
            return "VisualMeshComputeLodInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneComponentsMSFT:
            return "SceneComponentsMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneComponentsGetInfoMSFT:
            return "SceneComponentsGetInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneComponentLocationsMSFT:
            return "SceneComponentLocationsMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneComponentsLocateInfoMSFT:
            return "SceneComponentsLocateInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneObjectsMSFT:
            return "SceneObjectsMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneComponentParentFilterInfoMSFT:
            return "SceneComponentParentFilterInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneObjectTypesFilterInfoMSFT:
            return "SceneObjectTypesFilterInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::ScenePlanesMSFT:
            return "ScenePlanesMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::ScenePlaneAlignmentFilterInfoMSFT:
            return "ScenePlaneAlignmentFilterInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneMeshesMSFT:
            return "SceneMeshesMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneMeshBuffersGetInfoMSFT:
            return "SceneMeshBuffersGetInfoMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneMeshBuffersMSFT:
            return "SceneMeshBuffersMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneMeshVertexBufferMSFT:
            return "SceneMeshVertexBufferMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneMeshIndicesUint32MSFT:
            return "SceneMeshIndicesUint32MSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case StructureType::SceneMeshIndicesUint16MSFT:
            return "SceneMeshIndicesUint16MSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding_serialization
        case StructureType::SerializedSceneFragmentDataGetInfoMSFT:
            return "SerializedSceneFragmentDataGetInfoMSFT";
            #endif  // XR_MSFT_scene_understanding_serialization
            #ifdef XR_MSFT_scene_understanding_serialization
        case StructureType::SceneDeserializeInfoMSFT:
            return "SceneDeserializeInfoMSFT";
            #endif  // XR_MSFT_scene_understanding_serialization
            #ifdef XR_FB_display_refresh_rate
        case StructureType::EventDataDisplayRefreshRateChangedFB:
            return "EventDataDisplayRefreshRateChangedFB";
            #endif  // XR_FB_display_refresh_rate
            #ifdef XR_HTCX_vive_tracker_interaction
        case StructureType::ViveTrackerPathsHTCX:
            return "ViveTrackerPathsHTCX";
            #endif  // XR_HTCX_vive_tracker_interaction
            #ifdef XR_HTCX_vive_tracker_interaction
        case StructureType::EventDataViveTrackerConnectedHTCX:
            return "EventDataViveTrackerConnectedHTCX";
            #endif  // XR_HTCX_vive_tracker_interaction
            #ifdef XR_HTC_facial_tracking
        case StructureType::SystemFacialTrackingPropertiesHTC:
            return "SystemFacialTrackingPropertiesHTC";
            #endif  // XR_HTC_facial_tracking
            #ifdef XR_HTC_facial_tracking
        case StructureType::FacialTrackerCreateInfoHTC:
            return "FacialTrackerCreateInfoHTC";
            #endif  // XR_HTC_facial_tracking
            #ifdef XR_HTC_facial_tracking
        case StructureType::FacialExpressionsHTC:
            return "FacialExpressionsHTC";
            #endif  // XR_HTC_facial_tracking
            #ifdef XR_FB_color_space
        case StructureType::SystemColorSpacePropertiesFB:
            return "SystemColorSpacePropertiesFB";
            #endif  // XR_FB_color_space
            #ifdef XR_FB_hand_tracking_mesh
        case StructureType::HandTrackingMeshFB:
            return "HandTrackingMeshFB";
            #endif  // XR_FB_hand_tracking_mesh
            #ifdef XR_FB_hand_tracking_mesh
        case StructureType::HandTrackingScaleFB:
            return "HandTrackingScaleFB";
            #endif  // XR_FB_hand_tracking_mesh
            #ifdef XR_FB_hand_tracking_aim
        case StructureType::HandTrackingAimStateFB:
            return "HandTrackingAimStateFB";
            #endif  // XR_FB_hand_tracking_aim
            #ifdef XR_FB_hand_tracking_capsules
        case StructureType::HandTrackingCapsulesStateFB:
            return "HandTrackingCapsulesStateFB";
            #endif  // XR_FB_hand_tracking_capsules
            #ifdef XR_FB_spatial_entity
        case StructureType::SystemSpatialEntityPropertiesFB:
            return "SystemSpatialEntityPropertiesFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case StructureType::SpatialAnchorCreateInfoFB:
            return "SpatialAnchorCreateInfoFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case StructureType::SpaceComponentStatusSetInfoFB:
            return "SpaceComponentStatusSetInfoFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case StructureType::SpaceComponentStatusFB:
            return "SpaceComponentStatusFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case StructureType::EventDataSpatialAnchorCreateCompleteFB:
            return "EventDataSpatialAnchorCreateCompleteFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_spatial_entity
        case StructureType::EventDataSpaceSetStatusCompleteFB:
            return "EventDataSpaceSetStatusCompleteFB";
            #endif  // XR_FB_spatial_entity
            #ifdef XR_FB_foveation
        case StructureType::FoveationProfileCreateInfoFB:
            return "FoveationProfileCreateInfoFB";
            #endif  // XR_FB_foveation
            #ifdef XR_FB_foveation
        case StructureType::SwapchainCreateInfoFoveationFB:
            return "SwapchainCreateInfoFoveationFB";
            #endif  // XR_FB_foveation
            #ifdef XR_FB_foveation
        case StructureType::SwapchainStateFoveationFB:
            return "SwapchainStateFoveationFB";
            #endif  // XR_FB_foveation
            #ifdef XR_FB_foveation_configuration
        case StructureType::FoveationLevelProfileCreateInfoFB:
            return "FoveationLevelProfileCreateInfoFB";
            #endif  // XR_FB_foveation_configuration
            #ifdef XR_FB_keyboard_tracking
        case StructureType::KeyboardSpaceCreateInfoFB:
            return "KeyboardSpaceCreateInfoFB";
            #endif  // XR_FB_keyboard_tracking
            #ifdef XR_FB_keyboard_tracking
        case StructureType::KeyboardTrackingQueryFB:
            return "KeyboardTrackingQueryFB";
            #endif  // XR_FB_keyboard_tracking
            #ifdef XR_FB_keyboard_tracking
        case StructureType::SystemKeyboardTrackingPropertiesFB:
            return "SystemKeyboardTrackingPropertiesFB";
            #endif  // XR_FB_keyboard_tracking
            #ifdef XR_FB_triangle_mesh
        case StructureType::TriangleMeshCreateInfoFB:
            return "TriangleMeshCreateInfoFB";
            #endif  // XR_FB_triangle_mesh
            #ifdef XR_FB_passthrough
        case StructureType::SystemPassthroughPropertiesFB:
            return "SystemPassthroughPropertiesFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::PassthroughCreateInfoFB:
            return "PassthroughCreateInfoFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::PassthroughLayerCreateInfoFB:
            return "PassthroughLayerCreateInfoFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::CompositionLayerPassthroughFB:
            return "CompositionLayerPassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::GeometryInstanceCreateInfoFB:
            return "GeometryInstanceCreateInfoFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::GeometryInstanceTransformFB:
            return "GeometryInstanceTransformFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::SystemPassthroughProperties2FB:
            return "SystemPassthroughProperties2FB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::PassthroughStyleFB:
            return "PassthroughStyleFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::PassthroughColorMapMonoToRgbaFB:
            return "PassthroughColorMapMonoToRgbaFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::PassthroughColorMapMonoToMonoFB:
            return "PassthroughColorMapMonoToMonoFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::PassthroughBrightnessContrastSaturationFB:
            return "PassthroughBrightnessContrastSaturationFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case StructureType::EventDataPassthroughStateChangedFB:
            return "EventDataPassthroughStateChangedFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_render_model
        case StructureType::RenderModelPathInfoFB:
            return "RenderModelPathInfoFB";
            #endif  // XR_FB_render_model
            #ifdef XR_FB_render_model
        case StructureType::RenderModelPropertiesFB:
            return "RenderModelPropertiesFB";
            #endif  // XR_FB_render_model
            #ifdef XR_FB_render_model
        case StructureType::RenderModelBufferFB:
            return "RenderModelBufferFB";
            #endif  // XR_FB_render_model
            #ifdef XR_FB_render_model
        case StructureType::RenderModelLoadInfoFB:
            return "RenderModelLoadInfoFB";
            #endif  // XR_FB_render_model
            #ifdef XR_FB_render_model
        case StructureType::SystemRenderModelPropertiesFB:
            return "SystemRenderModelPropertiesFB";
            #endif  // XR_FB_render_model
            #ifdef XR_FB_render_model
        case StructureType::RenderModelCapabilitiesRequestFB:
            return "RenderModelCapabilitiesRequestFB";
            #endif  // XR_FB_render_model
            #ifdef XR_KHR_binding_modification
        case StructureType::BindingModificationsKHR:
            return "BindingModificationsKHR";
            #endif  // XR_KHR_binding_modification
            #ifdef XR_VARJO_foveated_rendering
        case StructureType::ViewLocateFoveatedRenderingVARJO:
            return "ViewLocateFoveatedRenderingVARJO";
            #endif  // XR_VARJO_foveated_rendering
            #ifdef XR_VARJO_foveated_rendering
        case StructureType::FoveatedViewConfigurationViewVARJO:
            return "FoveatedViewConfigurationViewVARJO";
            #endif  // XR_VARJO_foveated_rendering
            #ifdef XR_VARJO_foveated_rendering
        case StructureType::SystemFoveatedRenderingPropertiesVARJO:
            return "SystemFoveatedRenderingPropertiesVARJO";
            #endif  // XR_VARJO_foveated_rendering
            #ifdef XR_VARJO_composition_layer_depth_test
        case StructureType::CompositionLayerDepthTestVARJO:
            return "CompositionLayerDepthTestVARJO";
            #endif  // XR_VARJO_composition_layer_depth_test
            #ifdef XR_VARJO_marker_tracking
        case StructureType::SystemMarkerTrackingPropertiesVARJO:
            return "SystemMarkerTrackingPropertiesVARJO";
            #endif  // XR_VARJO_marker_tracking
            #ifdef XR_VARJO_marker_tracking
        case StructureType::EventDataMarkerTrackingUpdateVARJO:
            return "EventDataMarkerTrackingUpdateVARJO";
            #endif  // XR_VARJO_marker_tracking
            #ifdef XR_VARJO_marker_tracking
        case StructureType::MarkerSpaceCreateInfoVARJO:
            return "MarkerSpaceCreateInfoVARJO";
            #endif  // XR_VARJO_marker_tracking
            #ifdef XR_ML_frame_end_info
        case StructureType::FrameEndInfoML:
            return "FrameEndInfoML";
            #endif  // XR_ML_frame_end_info
            #ifdef XR_ML_global_dimmer
        case StructureType::GlobalDimmerFrameEndInfoML:
            return "GlobalDimmerFrameEndInfoML";
            #endif  // XR_ML_global_dimmer
            #ifdef XR_ML_compat
        case StructureType::CoordinateSpaceCreateInfoML:
            return "CoordinateSpaceCreateInfoML";
            #endif  // XR_ML_compat
            #ifdef XR_ML_user_calibration
        case StructureType::EventDataHeadsetFitChangedML:
            return "EventDataHeadsetFitChangedML";
            #endif  // XR_ML_user_calibration
            #ifdef XR_ML_user_calibration
        case StructureType::EventDataEyeCalibrationChangedML:
            return "EventDataEyeCalibrationChangedML";
            #endif  // XR_ML_user_calibration
            #ifdef XR_ML_user_calibration
        case StructureType::UserCalibrationEnableEventsInfoML:
            return "UserCalibrationEnableEventsInfoML";
            #endif  // XR_ML_user_calibration
            #ifdef XR_MSFT_spatial_anchor_persistence
        case StructureType::SpatialAnchorPersistenceInfoMSFT:
            return "SpatialAnchorPersistenceInfoMSFT";
            #endif  // XR_MSFT_spatial_anchor_persistence
            #ifdef XR_MSFT_spatial_anchor_persistence
        case StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT:
            return "SpatialAnchorFromPersistedAnchorCreateInfoMSFT";
            #endif  // XR_MSFT_spatial_anchor_persistence
            #ifdef XR_MSFT_scene_marker
        case StructureType::SceneMarkersMSFT:
            return "SceneMarkersMSFT";
            #endif  // XR_MSFT_scene_marker
            #ifdef XR_MSFT_scene_marker
        case StructureType::SceneMarkerTypeFilterMSFT:
            return "SceneMarkerTypeFilterMSFT";
            #endif  // XR_MSFT_scene_marker
            #ifdef XR_MSFT_scene_marker
        case StructureType::SceneMarkerQrCodesMSFT:
            return "SceneMarkerQrCodesMSFT";
            #endif  // XR_MSFT_scene_marker
            #ifdef XR_FB_spatial_entity_query
        case StructureType::SpaceQueryInfoFB:
            return "SpaceQueryInfoFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_query
        case StructureType::SpaceQueryResultsFB:
            return "SpaceQueryResultsFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_query
        case StructureType::SpaceStorageLocationFilterInfoFB:
            return "SpaceStorageLocationFilterInfoFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_query
        case StructureType::SpaceUuidFilterInfoFB:
            return "SpaceUuidFilterInfoFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_query
        case StructureType::SpaceComponentFilterInfoFB:
            return "SpaceComponentFilterInfoFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_query
        case StructureType::EventDataSpaceQueryResultsAvailableFB:
            return "EventDataSpaceQueryResultsAvailableFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_query
        case StructureType::EventDataSpaceQueryCompleteFB:
            return "EventDataSpaceQueryCompleteFB";
            #endif  // XR_FB_spatial_entity_query
            #ifdef XR_FB_spatial_entity_storage
        case StructureType::SpaceSaveInfoFB:
            return "SpaceSaveInfoFB";
            #endif  // XR_FB_spatial_entity_storage
            #ifdef XR_FB_spatial_entity_storage
        case StructureType::SpaceEraseInfoFB:
            return "SpaceEraseInfoFB";
            #endif  // XR_FB_spatial_entity_storage
            #ifdef XR_FB_spatial_entity_storage
        case StructureType::EventDataSpaceSaveCompleteFB:
            return "EventDataSpaceSaveCompleteFB";
            #endif  // XR_FB_spatial_entity_storage
            #ifdef XR_FB_spatial_entity_storage
        case StructureType::EventDataSpaceEraseCompleteFB:
            return "EventDataSpaceEraseCompleteFB";
            #endif  // XR_FB_spatial_entity_storage
            #ifdef XR_FB_foveation_vulkan
        case StructureType::SwapchainImageFoveationVulkanFB:
            return "SwapchainImageFoveationVulkanFB";
            #endif  // XR_FB_foveation_vulkan
            #ifdef XR_FB_swapchain_update_state_android_surface
        case StructureType::SwapchainStateAndroidSurfaceDimensionsFB:
            return "SwapchainStateAndroidSurfaceDimensionsFB";
            #endif  // XR_FB_swapchain_update_state_android_surface
            #ifdef XR_FB_swapchain_update_state_opengl_es
        case StructureType::SwapchainStateSamplerOpenGLESFB:
            return "SwapchainStateSamplerOpenGLESFB";
            #endif  // XR_FB_swapchain_update_state_opengl_es
            #ifdef XR_FB_swapchain_update_state_vulkan
        case StructureType::SwapchainStateSamplerVulkanFB:
            return "SwapchainStateSamplerVulkanFB";
            #endif  // XR_FB_swapchain_update_state_vulkan
            #ifdef XR_FB_spatial_entity_sharing
        case StructureType::SpaceShareInfoFB:
            return "SpaceShareInfoFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_FB_spatial_entity_sharing
        case StructureType::EventDataSpaceShareCompleteFB:
            return "EventDataSpaceShareCompleteFB";
            #endif  // XR_FB_spatial_entity_sharing
            #ifdef XR_FB_space_warp
        case StructureType::CompositionLayerSpaceWarpInfoFB:
            return "CompositionLayerSpaceWarpInfoFB";
            #endif  // XR_FB_space_warp
            #ifdef XR_FB_space_warp
        case StructureType::SystemSpaceWarpPropertiesFB:
            return "SystemSpaceWarpPropertiesFB";
            #endif  // XR_FB_space_warp
            #ifdef XR_FB_haptic_amplitude_envelope
        case StructureType::HapticAmplitudeEnvelopeVibrationFB:
            return "HapticAmplitudeEnvelopeVibrationFB";
            #endif  // XR_FB_haptic_amplitude_envelope
            #ifdef XR_FB_scene
        case StructureType::SemanticLabelsFB:
            return "SemanticLabelsFB";
            #endif  // XR_FB_scene
            #ifdef XR_FB_scene
        case StructureType::RoomLayoutFB:
            return "RoomLayoutFB";
            #endif  // XR_FB_scene
            #ifdef XR_FB_scene
        case StructureType::Boundary2DFB:
            return "Boundary2DFB";
            #endif  // XR_FB_scene
            #ifdef XR_FB_scene
        case StructureType::SemanticLabelsSupportInfoFB:
            return "SemanticLabelsSupportInfoFB";
            #endif  // XR_FB_scene
            #ifdef XR_ALMALENCE_digital_lens_control
        case StructureType::DigitalLensControlALMALENCE:
            return "DigitalLensControlALMALENCE";
            #endif  // XR_ALMALENCE_digital_lens_control
            #ifdef XR_FB_scene_capture
        case StructureType::EventDataSceneCaptureCompleteFB:
            return "EventDataSceneCaptureCompleteFB";
            #endif  // XR_FB_scene_capture
            #ifdef XR_FB_scene_capture
        case StructureType::SceneCaptureRequestInfoFB:
            return "SceneCaptureRequestInfoFB";
            #endif  // XR_FB_scene_capture
            #ifdef XR_FB_spatial_entity_container
        case StructureType::SpaceContainerFB:
            return "SpaceContainerFB";
            #endif  // XR_FB_spatial_entity_container
            #ifdef XR_META_foveation_eye_tracked
        case StructureType::FoveationEyeTrackedProfileCreateInfoMETA:
            return "FoveationEyeTrackedProfileCreateInfoMETA";
            #endif  // XR_META_foveation_eye_tracked
            #ifdef XR_META_foveation_eye_tracked
        case StructureType::FoveationEyeTrackedStateMETA:
            return "FoveationEyeTrackedStateMETA";
            #endif  // XR_META_foveation_eye_tracked
            #ifdef XR_META_foveation_eye_tracked
        case StructureType::SystemFoveationEyeTrackedPropertiesMETA:
            return "SystemFoveationEyeTrackedPropertiesMETA";
            #endif  // XR_META_foveation_eye_tracked
            #ifdef XR_FB_face_tracking
        case StructureType::SystemFaceTrackingPropertiesFB:
            return "SystemFaceTrackingPropertiesFB";
            #endif  // XR_FB_face_tracking
            #ifdef XR_FB_face_tracking
        case StructureType::FaceTrackerCreateInfoFB:
            return "FaceTrackerCreateInfoFB";
            #endif  // XR_FB_face_tracking
            #ifdef XR_FB_face_tracking
        case StructureType::FaceExpressionInfoFB:
            return "FaceExpressionInfoFB";
            #endif  // XR_FB_face_tracking
            #ifdef XR_FB_face_tracking
        case StructureType::FaceExpressionWeightsFB:
            return "FaceExpressionWeightsFB";
            #endif  // XR_FB_face_tracking
            #ifdef XR_FB_eye_tracking_social
        case StructureType::EyeTrackerCreateInfoFB:
            return "EyeTrackerCreateInfoFB";
            #endif  // XR_FB_eye_tracking_social
            #ifdef XR_FB_eye_tracking_social
        case StructureType::EyeGazesInfoFB:
            return "EyeGazesInfoFB";
            #endif  // XR_FB_eye_tracking_social
            #ifdef XR_FB_eye_tracking_social
        case StructureType::EyeGazesFB:
            return "EyeGazesFB";
            #endif  // XR_FB_eye_tracking_social
            #ifdef XR_FB_eye_tracking_social
        case StructureType::SystemEyeTrackingPropertiesFB:
            return "SystemEyeTrackingPropertiesFB";
            #endif  // XR_FB_eye_tracking_social
            #ifdef XR_FB_passthrough_keyboard_hands
        case StructureType::PassthroughKeyboardHandsIntensityFB:
            return "PassthroughKeyboardHandsIntensityFB";
            #endif  // XR_FB_passthrough_keyboard_hands
            #ifdef XR_FB_composition_layer_settings
        case StructureType::CompositionLayerSettingsFB:
            return "CompositionLayerSettingsFB";
            #endif  // XR_FB_composition_layer_settings
            #ifdef XR_FB_haptic_pcm
        case StructureType::HapticPcmVibrationFB:
            return "HapticPcmVibrationFB";
            #endif  // XR_FB_haptic_pcm
            #ifdef XR_FB_haptic_pcm
        case StructureType::DevicePcmSampleRateStateFB:
            return "DevicePcmSampleRateStateFB";
            #endif  // XR_FB_haptic_pcm
        // DevicePcmSampleRateGetInfoFB is an alias for DevicePcmSampleRateStateFB
            #ifdef XR_FB_composition_layer_depth_test
        case StructureType::CompositionLayerDepthTestFB:
            return "CompositionLayerDepthTestFB";
            #endif  // XR_FB_composition_layer_depth_test
            #ifdef XR_META_local_dimming
        case StructureType::LocalDimmingFrameEndInfoMETA:
            return "LocalDimmingFrameEndInfoMETA";
            #endif  // XR_META_local_dimming
            #ifdef XR_META_passthrough_preferences
        case StructureType::PassthroughPreferencesMETA:
            return "PassthroughPreferencesMETA";
            #endif  // XR_META_passthrough_preferences
            #ifdef XR_META_virtual_keyboard
        case StructureType::SystemVirtualKeyboardPropertiesMETA:
            return "SystemVirtualKeyboardPropertiesMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardCreateInfoMETA:
            return "VirtualKeyboardCreateInfoMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardSpaceCreateInfoMETA:
            return "VirtualKeyboardSpaceCreateInfoMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardLocationInfoMETA:
            return "VirtualKeyboardLocationInfoMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardModelVisibilitySetInfoMETA:
            return "VirtualKeyboardModelVisibilitySetInfoMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardAnimationStateMETA:
            return "VirtualKeyboardAnimationStateMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardModelAnimationStatesMETA:
            return "VirtualKeyboardModelAnimationStatesMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardTextureDataMETA:
            return "VirtualKeyboardTextureDataMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardInputInfoMETA:
            return "VirtualKeyboardInputInfoMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::VirtualKeyboardTextContextChangeInfoMETA:
            return "VirtualKeyboardTextContextChangeInfoMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::EventDataVirtualKeyboardCommitTextMETA:
            return "EventDataVirtualKeyboardCommitTextMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::EventDataVirtualKeyboardBackspaceMETA:
            return "EventDataVirtualKeyboardBackspaceMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::EventDataVirtualKeyboardEnterMETA:
            return "EventDataVirtualKeyboardEnterMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::EventDataVirtualKeyboardShownMETA:
            return "EventDataVirtualKeyboardShownMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_META_virtual_keyboard
        case StructureType::EventDataVirtualKeyboardHiddenMETA:
            return "EventDataVirtualKeyboardHiddenMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_OCULUS_external_camera
        case StructureType::ExternalCameraOCULUS:
            return "ExternalCameraOCULUS";
            #endif  // XR_OCULUS_external_camera
            #ifdef XR_META_vulkan_swapchain_create_info
        case StructureType::VulkanSwapchainCreateInfoMETA:
            return "VulkanSwapchainCreateInfoMETA";
            #endif  // XR_META_vulkan_swapchain_create_info
            #ifdef XR_META_performance_metrics
        case StructureType::PerformanceMetricsStateMETA:
            return "PerformanceMetricsStateMETA";
            #endif  // XR_META_performance_metrics
            #ifdef XR_META_performance_metrics
        case StructureType::PerformanceMetricsCounterMETA:
            return "PerformanceMetricsCounterMETA";
            #endif  // XR_META_performance_metrics
            #ifdef XR_FB_spatial_entity_storage_batch
        case StructureType::SpaceListSaveInfoFB:
            return "SpaceListSaveInfoFB";
            #endif  // XR_FB_spatial_entity_storage_batch
            #ifdef XR_FB_spatial_entity_storage_batch
        case StructureType::EventDataSpaceListSaveCompleteFB:
            return "EventDataSpaceListSaveCompleteFB";
            #endif  // XR_FB_spatial_entity_storage_batch
            #ifdef XR_FB_spatial_entity_user
        case StructureType::SpaceUserCreateInfoFB:
            return "SpaceUserCreateInfoFB";
            #endif  // XR_FB_spatial_entity_user
            #ifdef XR_META_headset_id
        case StructureType::SystemHeadsetIdPropertiesMETA:
            return "SystemHeadsetIdPropertiesMETA";
            #endif  // XR_META_headset_id
            #ifdef XR_META_passthrough_color_lut
        case StructureType::SystemPassthroughColorLutPropertiesMETA:
            return "SystemPassthroughColorLutPropertiesMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_META_passthrough_color_lut
        case StructureType::PassthroughColorLutCreateInfoMETA:
            return "PassthroughColorLutCreateInfoMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_META_passthrough_color_lut
        case StructureType::PassthroughColorLutUpdateInfoMETA:
            return "PassthroughColorLutUpdateInfoMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_META_passthrough_color_lut
        case StructureType::PassthroughColorMapLutMETA:
            return "PassthroughColorMapLutMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_META_passthrough_color_lut
        case StructureType::PassthroughColorMapInterpolatedLutMETA:
            return "PassthroughColorMapInterpolatedLutMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_HTC_passthrough
        case StructureType::PassthroughCreateInfoHTC:
            return "PassthroughCreateInfoHTC";
            #endif  // XR_HTC_passthrough
            #ifdef XR_HTC_passthrough
        case StructureType::PassthroughColorHTC:
            return "PassthroughColorHTC";
            #endif  // XR_HTC_passthrough
            #ifdef XR_HTC_passthrough
        case StructureType::PassthroughMeshTransformInfoHTC:
            return "PassthroughMeshTransformInfoHTC";
            #endif  // XR_HTC_passthrough
            #ifdef XR_HTC_passthrough
        case StructureType::CompositionLayerPassthroughHTC:
            return "CompositionLayerPassthroughHTC";
            #endif  // XR_HTC_passthrough
            #ifdef XR_HTC_foveation
        case StructureType::FoveationApplyInfoHTC:
            return "FoveationApplyInfoHTC";
            #endif  // XR_HTC_foveation
            #ifdef XR_HTC_foveation
        case StructureType::FoveationDynamicModeInfoHTC:
            return "FoveationDynamicModeInfoHTC";
            #endif  // XR_HTC_foveation
            #ifdef XR_HTC_foveation
        case StructureType::FoveationCustomModeInfoHTC:
            return "FoveationCustomModeInfoHTC";
            #endif  // XR_HTC_foveation
            #ifdef XR_EXT_active_action_set_priority
        case StructureType::ActiveActionSetPrioritiesEXT:
            return "ActiveActionSetPrioritiesEXT";
            #endif  // XR_EXT_active_action_set_priority
            #ifdef XR_MNDX_force_feedback_curl
        case StructureType::SystemForceFeedbackCurlPropertiesMNDX:
            return "SystemForceFeedbackCurlPropertiesMNDX";
            #endif  // XR_MNDX_force_feedback_curl
            #ifdef XR_MNDX_force_feedback_curl
        case StructureType::ForceFeedbackCurlApplyLocationsMNDX:
            return "ForceFeedbackCurlApplyLocationsMNDX";
            #endif  // XR_MNDX_force_feedback_curl
            #ifdef XR_EXT_hand_tracking_data_source
        case StructureType::HandTrackingDataSourceInfoEXT:
            return "HandTrackingDataSourceInfoEXT";
            #endif  // XR_EXT_hand_tracking_data_source
            #ifdef XR_EXT_hand_tracking_data_source
        case StructureType::HandTrackingDataSourceStateEXT:
            return "HandTrackingDataSourceStateEXT";
            #endif  // XR_EXT_hand_tracking_data_source
            #ifdef XR_EXT_plane_detection
        case StructureType::PlaneDetectorCreateInfoEXT:
            return "PlaneDetectorCreateInfoEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case StructureType::PlaneDetectorBeginInfoEXT:
            return "PlaneDetectorBeginInfoEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case StructureType::PlaneDetectorGetInfoEXT:
            return "PlaneDetectorGetInfoEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case StructureType::PlaneDetectorLocationsEXT:
            return "PlaneDetectorLocationsEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case StructureType::PlaneDetectorLocationEXT:
            return "PlaneDetectorLocationEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case StructureType::PlaneDetectorPolygonBufferEXT:
            return "PlaneDetectorPolygonBufferEXT";
            #endif  // XR_EXT_plane_detection
            #ifdef XR_EXT_plane_detection
        case StructureType::SystemPlaneDetectionPropertiesEXT:
            return "SystemPlaneDetectionPropertiesEXT";
            #endif  // XR_EXT_plane_detection
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a StructureType value as a std::string.
 * 
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(StructureType value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrFormFactor
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFormFactor>
 * 
 * @xrentity{XrFormFactor}
 */
enum class FormFactor: int32_t {
    
    HeadMountedDisplay = XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY,
    
    
    HandheldDisplay = XR_FORM_FACTOR_HANDHELD_DISPLAY,
    
};
 static_assert(sizeof(FormFactor) == sizeof(XrFormFactor), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFormFactor value from a FormFactor.
 * 
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFormFactor get(FormFactor const& v) {
    return static_cast<XrFormFactor>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FormFactor value as a const char *.
 * 
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FormFactor value) {
    switch (value) {
            
        case FormFactor::HeadMountedDisplay:
            return "HeadMountedDisplay";
            
            
        case FormFactor::HandheldDisplay:
            return "HandheldDisplay";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FormFactor value as a std::string.
 * 
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FormFactor value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrViewConfigurationType
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationType>
 * 
 * @xrentity{XrViewConfigurationType}
 */
enum class ViewConfigurationType: int32_t {
    
    PrimaryMono = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO,
    
    
    PrimaryStereo = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,
    
    #ifdef XR_VARJO_quad_views
    PrimaryQuadVARJO = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO,
    #endif  // XR_VARJO_quad_views
    #ifdef XR_MSFT_first_person_observer
    SecondaryMonoFirstPersonObserverMSFT = XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT,
    #endif  // XR_MSFT_first_person_observer
};
 static_assert(sizeof(ViewConfigurationType) == sizeof(XrViewConfigurationType), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrViewConfigurationType value from a ViewConfigurationType.
 * 
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrViewConfigurationType get(ViewConfigurationType const& v) {
    return static_cast<XrViewConfigurationType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ViewConfigurationType value as a const char *.
 * 
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ViewConfigurationType value) {
    switch (value) {
            
        case ViewConfigurationType::PrimaryMono:
            return "PrimaryMono";
            
            
        case ViewConfigurationType::PrimaryStereo:
            return "PrimaryStereo";
            
            #ifdef XR_VARJO_quad_views
        case ViewConfigurationType::PrimaryQuadVARJO:
            return "PrimaryQuadVARJO";
            #endif  // XR_VARJO_quad_views
            #ifdef XR_MSFT_first_person_observer
        case ViewConfigurationType::SecondaryMonoFirstPersonObserverMSFT:
            return "SecondaryMonoFirstPersonObserverMSFT";
            #endif  // XR_MSFT_first_person_observer
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ViewConfigurationType value as a std::string.
 * 
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ViewConfigurationType value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrEnvironmentBlendMode
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentBlendMode>
 * 
 * @xrentity{XrEnvironmentBlendMode}
 */
enum class EnvironmentBlendMode: int32_t {
    
    Opaque = XR_ENVIRONMENT_BLEND_MODE_OPAQUE,
    
    
    Additive = XR_ENVIRONMENT_BLEND_MODE_ADDITIVE,
    
    
    AlphaBlend = XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND,
    
};
 static_assert(sizeof(EnvironmentBlendMode) == sizeof(XrEnvironmentBlendMode), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEnvironmentBlendMode value from a EnvironmentBlendMode.
 * 
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEnvironmentBlendMode get(EnvironmentBlendMode const& v) {
    return static_cast<XrEnvironmentBlendMode>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EnvironmentBlendMode value as a const char *.
 * 
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EnvironmentBlendMode value) {
    switch (value) {
            
        case EnvironmentBlendMode::Opaque:
            return "Opaque";
            
            
        case EnvironmentBlendMode::Additive:
            return "Additive";
            
            
        case EnvironmentBlendMode::AlphaBlend:
            return "AlphaBlend";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a EnvironmentBlendMode value as a std::string.
 * 
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EnvironmentBlendMode value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrReferenceSpaceType
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceType>
 * 
 * @xrentity{XrReferenceSpaceType}
 */
enum class ReferenceSpaceType: int32_t {
    
    View = XR_REFERENCE_SPACE_TYPE_VIEW,
    
    
    Local = XR_REFERENCE_SPACE_TYPE_LOCAL,
    
    
    Stage = XR_REFERENCE_SPACE_TYPE_STAGE,
    
    #ifdef XR_MSFT_unbounded_reference_space
    UnboundedMSFT = XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT,
    #endif  // XR_MSFT_unbounded_reference_space
    #ifdef XR_VARJO_foveated_rendering
    CombinedEyeVARJO = XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO,
    #endif  // XR_VARJO_foveated_rendering
    #ifdef XR_EXT_local_floor
    LocalFloorEXT = XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT,
    #endif  // XR_EXT_local_floor
};
 static_assert(sizeof(ReferenceSpaceType) == sizeof(XrReferenceSpaceType), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReferenceSpaceType value from a ReferenceSpaceType.
 * 
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrReferenceSpaceType get(ReferenceSpaceType const& v) {
    return static_cast<XrReferenceSpaceType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ReferenceSpaceType value as a const char *.
 * 
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ReferenceSpaceType value) {
    switch (value) {
            
        case ReferenceSpaceType::View:
            return "View";
            
            
        case ReferenceSpaceType::Local:
            return "Local";
            
            
        case ReferenceSpaceType::Stage:
            return "Stage";
            
            #ifdef XR_MSFT_unbounded_reference_space
        case ReferenceSpaceType::UnboundedMSFT:
            return "UnboundedMSFT";
            #endif  // XR_MSFT_unbounded_reference_space
            #ifdef XR_VARJO_foveated_rendering
        case ReferenceSpaceType::CombinedEyeVARJO:
            return "CombinedEyeVARJO";
            #endif  // XR_VARJO_foveated_rendering
            #ifdef XR_EXT_local_floor
        case ReferenceSpaceType::LocalFloorEXT:
            return "LocalFloorEXT";
            #endif  // XR_EXT_local_floor
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ReferenceSpaceType value as a std::string.
 * 
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ReferenceSpaceType value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrActionType
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionType>
 * 
 * @xrentity{XrActionType}
 */
enum class ActionType: int32_t {
    
    BooleanInput = XR_ACTION_TYPE_BOOLEAN_INPUT,
    
    
    FloatInput = XR_ACTION_TYPE_FLOAT_INPUT,
    
    
    Vector2FInput = XR_ACTION_TYPE_VECTOR2F_INPUT,
    
    
    PoseInput = XR_ACTION_TYPE_POSE_INPUT,
    
    
    VibrationOutput = XR_ACTION_TYPE_VIBRATION_OUTPUT,
    
};
 static_assert(sizeof(ActionType) == sizeof(XrActionType), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrActionType value from a ActionType.
 * 
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrActionType get(ActionType const& v) {
    return static_cast<XrActionType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ActionType value as a const char *.
 * 
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ActionType value) {
    switch (value) {
            
        case ActionType::BooleanInput:
            return "BooleanInput";
            
            
        case ActionType::FloatInput:
            return "FloatInput";
            
            
        case ActionType::Vector2FInput:
            return "Vector2FInput";
            
            
        case ActionType::PoseInput:
            return "PoseInput";
            
            
        case ActionType::VibrationOutput:
            return "VibrationOutput";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ActionType value as a std::string.
 * 
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ActionType value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrEyeVisibility
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeVisibility>
 * 
 * @xrentity{XrEyeVisibility}
 */
enum class EyeVisibility: int32_t {
    
    Both = XR_EYE_VISIBILITY_BOTH,
    
    
    Left = XR_EYE_VISIBILITY_LEFT,
    
    
    Right = XR_EYE_VISIBILITY_RIGHT,
    
};
 static_assert(sizeof(EyeVisibility) == sizeof(XrEyeVisibility), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeVisibility value from a EyeVisibility.
 * 
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeVisibility get(EyeVisibility const& v) {
    return static_cast<XrEyeVisibility>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeVisibility value as a const char *.
 * 
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyeVisibility value) {
    switch (value) {
            
        case EyeVisibility::Both:
            return "Both";
            
            
        case EyeVisibility::Left:
            return "Left";
            
            
        case EyeVisibility::Right:
            return "Right";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a EyeVisibility value as a std::string.
 * 
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeVisibility value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrSessionState
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionState>
 * 
 * @xrentity{XrSessionState}
 */
enum class SessionState: int32_t {
    
    Unknown = XR_SESSION_STATE_UNKNOWN,
    
    
    Idle = XR_SESSION_STATE_IDLE,
    
    
    Ready = XR_SESSION_STATE_READY,
    
    
    Synchronized = XR_SESSION_STATE_SYNCHRONIZED,
    
    
    Visible = XR_SESSION_STATE_VISIBLE,
    
    
    Focused = XR_SESSION_STATE_FOCUSED,
    
    
    Stopping = XR_SESSION_STATE_STOPPING,
    
    
    LossPending = XR_SESSION_STATE_LOSS_PENDING,
    
    
    Exiting = XR_SESSION_STATE_EXITING,
    
};
 static_assert(sizeof(SessionState) == sizeof(XrSessionState), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSessionState value from a SessionState.
 * 
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSessionState get(SessionState const& v) {
    return static_cast<XrSessionState>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SessionState value as a const char *.
 * 
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SessionState value) {
    switch (value) {
            
        case SessionState::Unknown:
            return "Unknown";
            
            
        case SessionState::Idle:
            return "Idle";
            
            
        case SessionState::Ready:
            return "Ready";
            
            
        case SessionState::Synchronized:
            return "Synchronized";
            
            
        case SessionState::Visible:
            return "Visible";
            
            
        case SessionState::Focused:
            return "Focused";
            
            
        case SessionState::Stopping:
            return "Stopping";
            
            
        case SessionState::LossPending:
            return "LossPending";
            
            
        case SessionState::Exiting:
            return "Exiting";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SessionState value as a std::string.
 * 
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SessionState value) {
    return {to_string_literal(value)};
}
//! @}




































/*!
 * @brief Enum class for XrObjectType
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrObjectType>
 * 
 * @xrentity{XrObjectType}
 */
enum class ObjectType: int32_t {
    
    Unknown = XR_OBJECT_TYPE_UNKNOWN,
    
    
    Instance = XR_OBJECT_TYPE_INSTANCE,
    
    
    Session = XR_OBJECT_TYPE_SESSION,
    
    
    Swapchain = XR_OBJECT_TYPE_SWAPCHAIN,
    
    
    Space = XR_OBJECT_TYPE_SPACE,
    
    
    ActionSet = XR_OBJECT_TYPE_ACTION_SET,
    
    
    Action = XR_OBJECT_TYPE_ACTION,
    
    #ifdef XR_EXT_debug_utils
    DebugUtilsMessengerEXT = XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
    #endif  // XR_EXT_debug_utils
    #ifdef XR_MSFT_spatial_anchor
    SpatialAnchorMSFT = XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT,
    #endif  // XR_MSFT_spatial_anchor
    #ifdef XR_MSFT_spatial_graph_bridge
    SpatialGraphNodeBindingMSFT = XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT,
    #endif  // XR_MSFT_spatial_graph_bridge
    #ifdef XR_EXT_hand_tracking
    HandTrackerEXT = XR_OBJECT_TYPE_HAND_TRACKER_EXT,
    #endif  // XR_EXT_hand_tracking
    #ifdef XR_FB_body_tracking
    BodyTrackerFB = XR_OBJECT_TYPE_BODY_TRACKER_FB,
    #endif  // XR_FB_body_tracking
    #ifdef XR_MSFT_scene_understanding
    SceneObserverMSFT = XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_MSFT_scene_understanding
    SceneMSFT = XR_OBJECT_TYPE_SCENE_MSFT,
    #endif  // XR_MSFT_scene_understanding
    #ifdef XR_HTC_facial_tracking
    FacialTrackerHTC = XR_OBJECT_TYPE_FACIAL_TRACKER_HTC,
    #endif  // XR_HTC_facial_tracking
    #ifdef XR_FB_foveation
    FoveationProfileFB = XR_OBJECT_TYPE_FOVEATION_PROFILE_FB,
    #endif  // XR_FB_foveation
    #ifdef XR_FB_triangle_mesh
    TriangleMeshFB = XR_OBJECT_TYPE_TRIANGLE_MESH_FB,
    #endif  // XR_FB_triangle_mesh
    #ifdef XR_FB_passthrough
    PassthroughFB = XR_OBJECT_TYPE_PASSTHROUGH_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    PassthroughLayerFB = XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_FB_passthrough
    GeometryInstanceFB = XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB,
    #endif  // XR_FB_passthrough
    #ifdef XR_MSFT_spatial_anchor_persistence
    SpatialAnchorStoreConnectionMSFT = XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT,
    #endif  // XR_MSFT_spatial_anchor_persistence
    #ifdef XR_FB_face_tracking
    FaceTrackerFB = XR_OBJECT_TYPE_FACE_TRACKER_FB,
    #endif  // XR_FB_face_tracking
    #ifdef XR_FB_eye_tracking_social
    EyeTrackerFB = XR_OBJECT_TYPE_EYE_TRACKER_FB,
    #endif  // XR_FB_eye_tracking_social
    #ifdef XR_META_virtual_keyboard
    VirtualKeyboardMETA = XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META,
    #endif  // XR_META_virtual_keyboard
    #ifdef XR_FB_spatial_entity_user
    SpaceUserFB = XR_OBJECT_TYPE_SPACE_USER_FB,
    #endif  // XR_FB_spatial_entity_user
    #ifdef XR_META_passthrough_color_lut
    PassthroughColorLutMETA = XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META,
    #endif  // XR_META_passthrough_color_lut
    #ifdef XR_HTC_passthrough
    PassthroughHTC = XR_OBJECT_TYPE_PASSTHROUGH_HTC,
    #endif  // XR_HTC_passthrough
    #ifdef XR_EXT_plane_detection
    PlaneDetectorEXT = XR_OBJECT_TYPE_PLANE_DETECTOR_EXT,
    #endif  // XR_EXT_plane_detection
};
 static_assert(sizeof(ObjectType) == sizeof(XrObjectType), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrObjectType value from a ObjectType.
 * 
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrObjectType get(ObjectType const& v) {
    return static_cast<XrObjectType>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ObjectType value as a const char *.
 * 
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ObjectType value) {
    switch (value) {
            
        case ObjectType::Unknown:
            return "Unknown";
            
            
        case ObjectType::Instance:
            return "Instance";
            
            
        case ObjectType::Session:
            return "Session";
            
            
        case ObjectType::Swapchain:
            return "Swapchain";
            
            
        case ObjectType::Space:
            return "Space";
            
            
        case ObjectType::ActionSet:
            return "ActionSet";
            
            
        case ObjectType::Action:
            return "Action";
            
            #ifdef XR_EXT_debug_utils
        case ObjectType::DebugUtilsMessengerEXT:
            return "DebugUtilsMessengerEXT";
            #endif  // XR_EXT_debug_utils
            #ifdef XR_MSFT_spatial_anchor
        case ObjectType::SpatialAnchorMSFT:
            return "SpatialAnchorMSFT";
            #endif  // XR_MSFT_spatial_anchor
            #ifdef XR_MSFT_spatial_graph_bridge
        case ObjectType::SpatialGraphNodeBindingMSFT:
            return "SpatialGraphNodeBindingMSFT";
            #endif  // XR_MSFT_spatial_graph_bridge
            #ifdef XR_EXT_hand_tracking
        case ObjectType::HandTrackerEXT:
            return "HandTrackerEXT";
            #endif  // XR_EXT_hand_tracking
            #ifdef XR_FB_body_tracking
        case ObjectType::BodyTrackerFB:
            return "BodyTrackerFB";
            #endif  // XR_FB_body_tracking
            #ifdef XR_MSFT_scene_understanding
        case ObjectType::SceneObserverMSFT:
            return "SceneObserverMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_MSFT_scene_understanding
        case ObjectType::SceneMSFT:
            return "SceneMSFT";
            #endif  // XR_MSFT_scene_understanding
            #ifdef XR_HTC_facial_tracking
        case ObjectType::FacialTrackerHTC:
            return "FacialTrackerHTC";
            #endif  // XR_HTC_facial_tracking
            #ifdef XR_FB_foveation
        case ObjectType::FoveationProfileFB:
            return "FoveationProfileFB";
            #endif  // XR_FB_foveation
            #ifdef XR_FB_triangle_mesh
        case ObjectType::TriangleMeshFB:
            return "TriangleMeshFB";
            #endif  // XR_FB_triangle_mesh
            #ifdef XR_FB_passthrough
        case ObjectType::PassthroughFB:
            return "PassthroughFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case ObjectType::PassthroughLayerFB:
            return "PassthroughLayerFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_FB_passthrough
        case ObjectType::GeometryInstanceFB:
            return "GeometryInstanceFB";
            #endif  // XR_FB_passthrough
            #ifdef XR_MSFT_spatial_anchor_persistence
        case ObjectType::SpatialAnchorStoreConnectionMSFT:
            return "SpatialAnchorStoreConnectionMSFT";
            #endif  // XR_MSFT_spatial_anchor_persistence
            #ifdef XR_FB_face_tracking
        case ObjectType::FaceTrackerFB:
            return "FaceTrackerFB";
            #endif  // XR_FB_face_tracking
            #ifdef XR_FB_eye_tracking_social
        case ObjectType::EyeTrackerFB:
            return "EyeTrackerFB";
            #endif  // XR_FB_eye_tracking_social
            #ifdef XR_META_virtual_keyboard
        case ObjectType::VirtualKeyboardMETA:
            return "VirtualKeyboardMETA";
            #endif  // XR_META_virtual_keyboard
            #ifdef XR_FB_spatial_entity_user
        case ObjectType::SpaceUserFB:
            return "SpaceUserFB";
            #endif  // XR_FB_spatial_entity_user
            #ifdef XR_META_passthrough_color_lut
        case ObjectType::PassthroughColorLutMETA:
            return "PassthroughColorLutMETA";
            #endif  // XR_META_passthrough_color_lut
            #ifdef XR_HTC_passthrough
        case ObjectType::PassthroughHTC:
            return "PassthroughHTC";
            #endif  // XR_HTC_passthrough
            #ifdef XR_EXT_plane_detection
        case ObjectType::PlaneDetectorEXT:
            return "PlaneDetectorEXT";
            #endif  // XR_EXT_plane_detection
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ObjectType value as a std::string.
 * 
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ObjectType value) {
    return {to_string_literal(value)};
}
//! @}



































#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * @brief Enum class for XrAndroidThreadTypeKHR
 * 
 * Provided by the `XR_KHR_android_thread_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAndroidThreadTypeKHR>
 * 
 * @xrentity{XrAndroidThreadTypeKHR}
 */
enum class AndroidThreadTypeKHR: int32_t {
    
    ApplicationMain = XR_ANDROID_THREAD_TYPE_APPLICATION_MAIN_KHR,
    
    
    ApplicationWorker = XR_ANDROID_THREAD_TYPE_APPLICATION_WORKER_KHR,
    
    
    RendererMain = XR_ANDROID_THREAD_TYPE_RENDERER_MAIN_KHR,
    
    
    RendererWorker = XR_ANDROID_THREAD_TYPE_RENDERER_WORKER_KHR,
    
};
 static_assert(sizeof(AndroidThreadTypeKHR) == sizeof(XrAndroidThreadTypeKHR), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrAndroidThreadTypeKHR value from a AndroidThreadTypeKHR.
 * 
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrAndroidThreadTypeKHR get(AndroidThreadTypeKHR const& v) {
    return static_cast<XrAndroidThreadTypeKHR>(v);
}

/*!
 * @brief Free function for retrieving the string name of a AndroidThreadTypeKHR value as a const char *.
 * 
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(AndroidThreadTypeKHR value) {
    switch (value) {
            
        case AndroidThreadTypeKHR::ApplicationMain:
            return "ApplicationMain";
            
            
        case AndroidThreadTypeKHR::ApplicationWorker:
            return "ApplicationWorker";
            
            
        case AndroidThreadTypeKHR::RendererMain:
            return "RendererMain";
            
            
        case AndroidThreadTypeKHR::RendererWorker:
            return "RendererWorker";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a AndroidThreadTypeKHR value as a std::string.
 * 
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(AndroidThreadTypeKHR value) {
    return {to_string_literal(value)};
}
//! @}

#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

































#ifdef XR_KHR_visibility_mask
/*!
 * @brief Enum class for XrVisibilityMaskTypeKHR
 * 
 * Provided by the `XR_KHR_visibility_mask` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskTypeKHR>
 * 
 * @xrentity{XrVisibilityMaskTypeKHR}
 */
enum class VisibilityMaskTypeKHR: int32_t {
    
    HiddenTriangleMesh = XR_VISIBILITY_MASK_TYPE_HIDDEN_TRIANGLE_MESH_KHR,
    
    
    VisibleTriangleMesh = XR_VISIBILITY_MASK_TYPE_VISIBLE_TRIANGLE_MESH_KHR,
    
    
    LineLoop = XR_VISIBILITY_MASK_TYPE_LINE_LOOP_KHR,
    
};
 static_assert(sizeof(VisibilityMaskTypeKHR) == sizeof(XrVisibilityMaskTypeKHR), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVisibilityMaskTypeKHR value from a VisibilityMaskTypeKHR.
 * 
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVisibilityMaskTypeKHR get(VisibilityMaskTypeKHR const& v) {
    return static_cast<XrVisibilityMaskTypeKHR>(v);
}

/*!
 * @brief Free function for retrieving the string name of a VisibilityMaskTypeKHR value as a const char *.
 * 
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(VisibilityMaskTypeKHR value) {
    switch (value) {
            
        case VisibilityMaskTypeKHR::HiddenTriangleMesh:
            return "HiddenTriangleMesh";
            
            
        case VisibilityMaskTypeKHR::VisibleTriangleMesh:
            return "VisibleTriangleMesh";
            
            
        case VisibilityMaskTypeKHR::LineLoop:
            return "LineLoop";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a VisibilityMaskTypeKHR value as a std::string.
 * 
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(VisibilityMaskTypeKHR value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_KHR_visibility_mask

































#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsDomainEXT
 * 
 * Provided by the `XR_EXT_performance_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsDomainEXT>
 * 
 * @xrentity{XrPerfSettingsDomainEXT}
 */
enum class PerfSettingsDomainEXT: int32_t {
    
    Cpu = XR_PERF_SETTINGS_DOMAIN_CPU_EXT,
    
    
    Gpu = XR_PERF_SETTINGS_DOMAIN_GPU_EXT,
    
};
 static_assert(sizeof(PerfSettingsDomainEXT) == sizeof(XrPerfSettingsDomainEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsDomainEXT value from a PerfSettingsDomainEXT.
 * 
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsDomainEXT get(PerfSettingsDomainEXT const& v) {
    return static_cast<XrPerfSettingsDomainEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsDomainEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PerfSettingsDomainEXT value) {
    switch (value) {
            
        case PerfSettingsDomainEXT::Cpu:
            return "Cpu";
            
            
        case PerfSettingsDomainEXT::Gpu:
            return "Gpu";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsDomainEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsDomainEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

































#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsSubDomainEXT
 * 
 * Provided by the `XR_EXT_performance_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsSubDomainEXT>
 * 
 * @xrentity{XrPerfSettingsSubDomainEXT}
 */
enum class PerfSettingsSubDomainEXT: int32_t {
    
    Compositing = XR_PERF_SETTINGS_SUB_DOMAIN_COMPOSITING_EXT,
    
    
    Rendering = XR_PERF_SETTINGS_SUB_DOMAIN_RENDERING_EXT,
    
    
    Thermal = XR_PERF_SETTINGS_SUB_DOMAIN_THERMAL_EXT,
    
};
 static_assert(sizeof(PerfSettingsSubDomainEXT) == sizeof(XrPerfSettingsSubDomainEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsSubDomainEXT value from a PerfSettingsSubDomainEXT.
 * 
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsSubDomainEXT get(PerfSettingsSubDomainEXT const& v) {
    return static_cast<XrPerfSettingsSubDomainEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsSubDomainEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PerfSettingsSubDomainEXT value) {
    switch (value) {
            
        case PerfSettingsSubDomainEXT::Compositing:
            return "Compositing";
            
            
        case PerfSettingsSubDomainEXT::Rendering:
            return "Rendering";
            
            
        case PerfSettingsSubDomainEXT::Thermal:
            return "Thermal";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsSubDomainEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsSubDomainEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

































#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsLevelEXT
 * 
 * Provided by the `XR_EXT_performance_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsLevelEXT>
 * 
 * @xrentity{XrPerfSettingsLevelEXT}
 */
enum class PerfSettingsLevelEXT: int32_t {
    
    PowerSavings = XR_PERF_SETTINGS_LEVEL_POWER_SAVINGS_EXT,
    
    
    SustainedLow = XR_PERF_SETTINGS_LEVEL_SUSTAINED_LOW_EXT,
    
    
    SustainedHigh = XR_PERF_SETTINGS_LEVEL_SUSTAINED_HIGH_EXT,
    
    
    Boost = XR_PERF_SETTINGS_LEVEL_BOOST_EXT,
    
};
 static_assert(sizeof(PerfSettingsLevelEXT) == sizeof(XrPerfSettingsLevelEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsLevelEXT value from a PerfSettingsLevelEXT.
 * 
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsLevelEXT get(PerfSettingsLevelEXT const& v) {
    return static_cast<XrPerfSettingsLevelEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsLevelEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PerfSettingsLevelEXT value) {
    switch (value) {
            
        case PerfSettingsLevelEXT::PowerSavings:
            return "PowerSavings";
            
            
        case PerfSettingsLevelEXT::SustainedLow:
            return "SustainedLow";
            
            
        case PerfSettingsLevelEXT::SustainedHigh:
            return "SustainedHigh";
            
            
        case PerfSettingsLevelEXT::Boost:
            return "Boost";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsLevelEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsLevelEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

































#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsNotificationLevelEXT
 * 
 * Provided by the `XR_EXT_performance_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsNotificationLevelEXT>
 * 
 * @xrentity{XrPerfSettingsNotificationLevelEXT}
 */
enum class PerfSettingsNotificationLevelEXT: int32_t {
    
    Normal = XR_PERF_SETTINGS_NOTIF_LEVEL_NORMAL_EXT,
    
    
    Warning = XR_PERF_SETTINGS_NOTIF_LEVEL_WARNING_EXT,
    
    
    Impaired = XR_PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED_EXT,
    
};
 static_assert(sizeof(PerfSettingsNotificationLevelEXT) == sizeof(XrPerfSettingsNotificationLevelEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsNotificationLevelEXT value from a PerfSettingsNotificationLevelEXT.
 * 
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsNotificationLevelEXT get(PerfSettingsNotificationLevelEXT const& v) {
    return static_cast<XrPerfSettingsNotificationLevelEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsNotificationLevelEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PerfSettingsNotificationLevelEXT value) {
    switch (value) {
            
        case PerfSettingsNotificationLevelEXT::Normal:
            return "Normal";
            
            
        case PerfSettingsNotificationLevelEXT::Warning:
            return "Warning";
            
            
        case PerfSettingsNotificationLevelEXT::Impaired:
            return "Impaired";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsNotificationLevelEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsNotificationLevelEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

































#ifdef XR_FB_composition_layer_alpha_blend
/*!
 * @brief Enum class for XrBlendFactorFB
 * 
 * Provided by the `XR_FB_composition_layer_alpha_blend` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBlendFactorFB>
 * 
 * @xrentity{XrBlendFactorFB}
 */
enum class BlendFactorFB: int32_t {
    
    Zero = XR_BLEND_FACTOR_ZERO_FB,
    
    
    One = XR_BLEND_FACTOR_ONE_FB,
    
    
    SrcAlpha = XR_BLEND_FACTOR_SRC_ALPHA_FB,
    
    
    OneMinusSrcAlpha = XR_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA_FB,
    
    
    DstAlpha = XR_BLEND_FACTOR_DST_ALPHA_FB,
    
    
    OneMinusDstAlpha = XR_BLEND_FACTOR_ONE_MINUS_DST_ALPHA_FB,
    
};
 static_assert(sizeof(BlendFactorFB) == sizeof(XrBlendFactorFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBlendFactorFB value from a BlendFactorFB.
 * 
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBlendFactorFB get(BlendFactorFB const& v) {
    return static_cast<XrBlendFactorFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a BlendFactorFB value as a const char *.
 * 
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BlendFactorFB value) {
    switch (value) {
            
        case BlendFactorFB::Zero:
            return "Zero";
            
            
        case BlendFactorFB::One:
            return "One";
            
            
        case BlendFactorFB::SrcAlpha:
            return "SrcAlpha";
            
            
        case BlendFactorFB::OneMinusSrcAlpha:
            return "OneMinusSrcAlpha";
            
            
        case BlendFactorFB::DstAlpha:
            return "DstAlpha";
            
            
        case BlendFactorFB::OneMinusDstAlpha:
            return "OneMinusDstAlpha";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a BlendFactorFB value as a std::string.
 * 
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BlendFactorFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_composition_layer_alpha_blend

































#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandEXT>
 * 
 * @xrentity{XrHandEXT}
 */
enum class HandEXT: int32_t {
    
    Left = XR_HAND_LEFT_EXT,
    
    
    Right = XR_HAND_RIGHT_EXT,
    
};
 static_assert(sizeof(HandEXT) == sizeof(XrHandEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandEXT value from a HandEXT.
 * 
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandEXT get(HandEXT const& v) {
    return static_cast<XrHandEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandEXT value as a const char *.
 * 
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandEXT value) {
    switch (value) {
            
        case HandEXT::Left:
            return "Left";
            
            
        case HandEXT::Right:
            return "Right";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandEXT value as a std::string.
 * 
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

































#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandJointEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointEXT>
 * 
 * @xrentity{XrHandJointEXT}
 */
enum class HandJointEXT: int32_t {
    
    Palm = XR_HAND_JOINT_PALM_EXT,
    
    
    Wrist = XR_HAND_JOINT_WRIST_EXT,
    
    
    ThumbMetacarpal = XR_HAND_JOINT_THUMB_METACARPAL_EXT,
    
    
    ThumbProximal = XR_HAND_JOINT_THUMB_PROXIMAL_EXT,
    
    
    ThumbDistal = XR_HAND_JOINT_THUMB_DISTAL_EXT,
    
    
    ThumbTip = XR_HAND_JOINT_THUMB_TIP_EXT,
    
    
    IndexMetacarpal = XR_HAND_JOINT_INDEX_METACARPAL_EXT,
    
    
    IndexProximal = XR_HAND_JOINT_INDEX_PROXIMAL_EXT,
    
    
    IndexIntermediate = XR_HAND_JOINT_INDEX_INTERMEDIATE_EXT,
    
    
    IndexDistal = XR_HAND_JOINT_INDEX_DISTAL_EXT,
    
    
    IndexTip = XR_HAND_JOINT_INDEX_TIP_EXT,
    
    
    MiddleMetacarpal = XR_HAND_JOINT_MIDDLE_METACARPAL_EXT,
    
    
    MiddleProximal = XR_HAND_JOINT_MIDDLE_PROXIMAL_EXT,
    
    
    MiddleIntermediate = XR_HAND_JOINT_MIDDLE_INTERMEDIATE_EXT,
    
    
    MiddleDistal = XR_HAND_JOINT_MIDDLE_DISTAL_EXT,
    
    
    MiddleTip = XR_HAND_JOINT_MIDDLE_TIP_EXT,
    
    
    RingMetacarpal = XR_HAND_JOINT_RING_METACARPAL_EXT,
    
    
    RingProximal = XR_HAND_JOINT_RING_PROXIMAL_EXT,
    
    
    RingIntermediate = XR_HAND_JOINT_RING_INTERMEDIATE_EXT,
    
    
    RingDistal = XR_HAND_JOINT_RING_DISTAL_EXT,
    
    
    RingTip = XR_HAND_JOINT_RING_TIP_EXT,
    
    
    LittleMetacarpal = XR_HAND_JOINT_LITTLE_METACARPAL_EXT,
    
    
    LittleProximal = XR_HAND_JOINT_LITTLE_PROXIMAL_EXT,
    
    
    LittleIntermediate = XR_HAND_JOINT_LITTLE_INTERMEDIATE_EXT,
    
    
    LittleDistal = XR_HAND_JOINT_LITTLE_DISTAL_EXT,
    
    
    LittleTip = XR_HAND_JOINT_LITTLE_TIP_EXT,
    
};
 static_assert(sizeof(HandJointEXT) == sizeof(XrHandJointEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointEXT value from a HandJointEXT.
 * 
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointEXT get(HandJointEXT const& v) {
    return static_cast<XrHandJointEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointEXT value as a const char *.
 * 
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointEXT value) {
    switch (value) {
            
        case HandJointEXT::Palm:
            return "Palm";
            
            
        case HandJointEXT::Wrist:
            return "Wrist";
            
            
        case HandJointEXT::ThumbMetacarpal:
            return "ThumbMetacarpal";
            
            
        case HandJointEXT::ThumbProximal:
            return "ThumbProximal";
            
            
        case HandJointEXT::ThumbDistal:
            return "ThumbDistal";
            
            
        case HandJointEXT::ThumbTip:
            return "ThumbTip";
            
            
        case HandJointEXT::IndexMetacarpal:
            return "IndexMetacarpal";
            
            
        case HandJointEXT::IndexProximal:
            return "IndexProximal";
            
            
        case HandJointEXT::IndexIntermediate:
            return "IndexIntermediate";
            
            
        case HandJointEXT::IndexDistal:
            return "IndexDistal";
            
            
        case HandJointEXT::IndexTip:
            return "IndexTip";
            
            
        case HandJointEXT::MiddleMetacarpal:
            return "MiddleMetacarpal";
            
            
        case HandJointEXT::MiddleProximal:
            return "MiddleProximal";
            
            
        case HandJointEXT::MiddleIntermediate:
            return "MiddleIntermediate";
            
            
        case HandJointEXT::MiddleDistal:
            return "MiddleDistal";
            
            
        case HandJointEXT::MiddleTip:
            return "MiddleTip";
            
            
        case HandJointEXT::RingMetacarpal:
            return "RingMetacarpal";
            
            
        case HandJointEXT::RingProximal:
            return "RingProximal";
            
            
        case HandJointEXT::RingIntermediate:
            return "RingIntermediate";
            
            
        case HandJointEXT::RingDistal:
            return "RingDistal";
            
            
        case HandJointEXT::RingTip:
            return "RingTip";
            
            
        case HandJointEXT::LittleMetacarpal:
            return "LittleMetacarpal";
            
            
        case HandJointEXT::LittleProximal:
            return "LittleProximal";
            
            
        case HandJointEXT::LittleIntermediate:
            return "LittleIntermediate";
            
            
        case HandJointEXT::LittleDistal:
            return "LittleDistal";
            
            
        case HandJointEXT::LittleTip:
            return "LittleTip";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointEXT value as a std::string.
 * 
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

































#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandJointSetEXT
 * 
 * Provided by the `XR_EXT_hand_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointSetEXT>
 * 
 * @xrentity{XrHandJointSetEXT}
 */
enum class HandJointSetEXT: int32_t {
    
    Default = XR_HAND_JOINT_SET_DEFAULT_EXT,
    
    #ifdef XR_ULTRALEAP_hand_tracking_forearm
    HandWithForearmULTRALEAP = XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP,
    #endif  // XR_ULTRALEAP_hand_tracking_forearm
};
 static_assert(sizeof(HandJointSetEXT) == sizeof(XrHandJointSetEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointSetEXT value from a HandJointSetEXT.
 * 
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointSetEXT get(HandJointSetEXT const& v) {
    return static_cast<XrHandJointSetEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointSetEXT value as a const char *.
 * 
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointSetEXT value) {
    switch (value) {
            
        case HandJointSetEXT::Default:
            return "Default";
            
            #ifdef XR_ULTRALEAP_hand_tracking_forearm
        case HandJointSetEXT::HandWithForearmULTRALEAP:
            return "HandWithForearmULTRALEAP";
            #endif  // XR_ULTRALEAP_hand_tracking_forearm
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointSetEXT value as a std::string.
 * 
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointSetEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

































#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * @brief Enum class for XrHandPoseTypeMSFT
 * 
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeMSFT>
 * 
 * @xrentity{XrHandPoseTypeMSFT}
 */
enum class HandPoseTypeMSFT: int32_t {
    
    Tracked = XR_HAND_POSE_TYPE_TRACKED_MSFT,
    
    
    ReferenceOpenPalm = XR_HAND_POSE_TYPE_REFERENCE_OPEN_PALM_MSFT,
    
};
 static_assert(sizeof(HandPoseTypeMSFT) == sizeof(XrHandPoseTypeMSFT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandPoseTypeMSFT value from a HandPoseTypeMSFT.
 * 
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandPoseTypeMSFT get(HandPoseTypeMSFT const& v) {
    return static_cast<XrHandPoseTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandPoseTypeMSFT value as a const char *.
 * 
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandPoseTypeMSFT value) {
    switch (value) {
            
        case HandPoseTypeMSFT::Tracked:
            return "Tracked";
            
            
        case HandPoseTypeMSFT::ReferenceOpenPalm:
            return "ReferenceOpenPalm";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandPoseTypeMSFT value as a std::string.
 * 
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandPoseTypeMSFT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_hand_tracking_mesh

































#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * @brief Enum class for XrReprojectionModeMSFT
 * 
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReprojectionModeMSFT>
 * 
 * @xrentity{XrReprojectionModeMSFT}
 */
enum class ReprojectionModeMSFT: int32_t {
    
    Depth = XR_REPROJECTION_MODE_DEPTH_MSFT,
    
    
    PlanarFromDepth = XR_REPROJECTION_MODE_PLANAR_FROM_DEPTH_MSFT,
    
    
    PlanarManual = XR_REPROJECTION_MODE_PLANAR_MANUAL_MSFT,
    
    
    OrientationOnly = XR_REPROJECTION_MODE_ORIENTATION_ONLY_MSFT,
    
};
 static_assert(sizeof(ReprojectionModeMSFT) == sizeof(XrReprojectionModeMSFT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReprojectionModeMSFT value from a ReprojectionModeMSFT.
 * 
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrReprojectionModeMSFT get(ReprojectionModeMSFT const& v) {
    return static_cast<XrReprojectionModeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ReprojectionModeMSFT value as a const char *.
 * 
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ReprojectionModeMSFT value) {
    switch (value) {
            
        case ReprojectionModeMSFT::Depth:
            return "Depth";
            
            
        case ReprojectionModeMSFT::PlanarFromDepth:
            return "PlanarFromDepth";
            
            
        case ReprojectionModeMSFT::PlanarManual:
            return "PlanarManual";
            
            
        case ReprojectionModeMSFT::OrientationOnly:
            return "OrientationOnly";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ReprojectionModeMSFT value as a std::string.
 * 
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ReprojectionModeMSFT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_composition_layer_reprojection

































#ifdef XR_FB_body_tracking
/*!
 * @brief Enum class for XrBodyJointFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointFB>
 * 
 * @xrentity{XrBodyJointFB}
 */
enum class BodyJointFB: int32_t {
    
    Root = XR_BODY_JOINT_ROOT_FB,
    
    
    Hips = XR_BODY_JOINT_HIPS_FB,
    
    
    SpineLower = XR_BODY_JOINT_SPINE_LOWER_FB,
    
    
    SpineMiddle = XR_BODY_JOINT_SPINE_MIDDLE_FB,
    
    
    SpineUpper = XR_BODY_JOINT_SPINE_UPPER_FB,
    
    
    Chest = XR_BODY_JOINT_CHEST_FB,
    
    
    Neck = XR_BODY_JOINT_NECK_FB,
    
    
    Head = XR_BODY_JOINT_HEAD_FB,
    
    
    LeftShoulder = XR_BODY_JOINT_LEFT_SHOULDER_FB,
    
    
    LeftScapula = XR_BODY_JOINT_LEFT_SCAPULA_FB,
    
    
    LeftArmUpper = XR_BODY_JOINT_LEFT_ARM_UPPER_FB,
    
    
    LeftArmLower = XR_BODY_JOINT_LEFT_ARM_LOWER_FB,
    
    
    LeftHandWristTwist = XR_BODY_JOINT_LEFT_HAND_WRIST_TWIST_FB,
    
    
    RightShoulder = XR_BODY_JOINT_RIGHT_SHOULDER_FB,
    
    
    RightScapula = XR_BODY_JOINT_RIGHT_SCAPULA_FB,
    
    
    RightArmUpper = XR_BODY_JOINT_RIGHT_ARM_UPPER_FB,
    
    
    RightArmLower = XR_BODY_JOINT_RIGHT_ARM_LOWER_FB,
    
    
    RightHandWristTwist = XR_BODY_JOINT_RIGHT_HAND_WRIST_TWIST_FB,
    
    
    LeftHandPalm = XR_BODY_JOINT_LEFT_HAND_PALM_FB,
    
    
    LeftHandWrist = XR_BODY_JOINT_LEFT_HAND_WRIST_FB,
    
    
    LeftHandThumbMetacarpal = XR_BODY_JOINT_LEFT_HAND_THUMB_METACARPAL_FB,
    
    
    LeftHandThumbProximal = XR_BODY_JOINT_LEFT_HAND_THUMB_PROXIMAL_FB,
    
    
    LeftHandThumbDistal = XR_BODY_JOINT_LEFT_HAND_THUMB_DISTAL_FB,
    
    
    LeftHandThumbTip = XR_BODY_JOINT_LEFT_HAND_THUMB_TIP_FB,
    
    
    LeftHandIndexMetacarpal = XR_BODY_JOINT_LEFT_HAND_INDEX_METACARPAL_FB,
    
    
    LeftHandIndexProximal = XR_BODY_JOINT_LEFT_HAND_INDEX_PROXIMAL_FB,
    
    
    LeftHandIndexIntermediate = XR_BODY_JOINT_LEFT_HAND_INDEX_INTERMEDIATE_FB,
    
    
    LeftHandIndexDistal = XR_BODY_JOINT_LEFT_HAND_INDEX_DISTAL_FB,
    
    
    LeftHandIndexTip = XR_BODY_JOINT_LEFT_HAND_INDEX_TIP_FB,
    
    
    LeftHandMiddleMetacarpal = XR_BODY_JOINT_LEFT_HAND_MIDDLE_METACARPAL_FB,
    
    
    LeftHandMiddleProximal = XR_BODY_JOINT_LEFT_HAND_MIDDLE_PROXIMAL_FB,
    
    
    LeftHandMiddleIntermediate = XR_BODY_JOINT_LEFT_HAND_MIDDLE_INTERMEDIATE_FB,
    
    
    LeftHandMiddleDistal = XR_BODY_JOINT_LEFT_HAND_MIDDLE_DISTAL_FB,
    
    
    LeftHandMiddleTip = XR_BODY_JOINT_LEFT_HAND_MIDDLE_TIP_FB,
    
    
    LeftHandRingMetacarpal = XR_BODY_JOINT_LEFT_HAND_RING_METACARPAL_FB,
    
    
    LeftHandRingProximal = XR_BODY_JOINT_LEFT_HAND_RING_PROXIMAL_FB,
    
    
    LeftHandRingIntermediate = XR_BODY_JOINT_LEFT_HAND_RING_INTERMEDIATE_FB,
    
    
    LeftHandRingDistal = XR_BODY_JOINT_LEFT_HAND_RING_DISTAL_FB,
    
    
    LeftHandRingTip = XR_BODY_JOINT_LEFT_HAND_RING_TIP_FB,
    
    
    LeftHandLittleMetacarpal = XR_BODY_JOINT_LEFT_HAND_LITTLE_METACARPAL_FB,
    
    
    LeftHandLittleProximal = XR_BODY_JOINT_LEFT_HAND_LITTLE_PROXIMAL_FB,
    
    
    LeftHandLittleIntermediate = XR_BODY_JOINT_LEFT_HAND_LITTLE_INTERMEDIATE_FB,
    
    
    LeftHandLittleDistal = XR_BODY_JOINT_LEFT_HAND_LITTLE_DISTAL_FB,
    
    
    LeftHandLittleTip = XR_BODY_JOINT_LEFT_HAND_LITTLE_TIP_FB,
    
    
    RightHandPalm = XR_BODY_JOINT_RIGHT_HAND_PALM_FB,
    
    
    RightHandWrist = XR_BODY_JOINT_RIGHT_HAND_WRIST_FB,
    
    
    RightHandThumbMetacarpal = XR_BODY_JOINT_RIGHT_HAND_THUMB_METACARPAL_FB,
    
    
    RightHandThumbProximal = XR_BODY_JOINT_RIGHT_HAND_THUMB_PROXIMAL_FB,
    
    
    RightHandThumbDistal = XR_BODY_JOINT_RIGHT_HAND_THUMB_DISTAL_FB,
    
    
    RightHandThumbTip = XR_BODY_JOINT_RIGHT_HAND_THUMB_TIP_FB,
    
    
    RightHandIndexMetacarpal = XR_BODY_JOINT_RIGHT_HAND_INDEX_METACARPAL_FB,
    
    
    RightHandIndexProximal = XR_BODY_JOINT_RIGHT_HAND_INDEX_PROXIMAL_FB,
    
    
    RightHandIndexIntermediate = XR_BODY_JOINT_RIGHT_HAND_INDEX_INTERMEDIATE_FB,
    
    
    RightHandIndexDistal = XR_BODY_JOINT_RIGHT_HAND_INDEX_DISTAL_FB,
    
    
    RightHandIndexTip = XR_BODY_JOINT_RIGHT_HAND_INDEX_TIP_FB,
    
    
    RightHandMiddleMetacarpal = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_METACARPAL_FB,
    
    
    RightHandMiddleProximal = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_PROXIMAL_FB,
    
    
    RightHandMiddleIntermediate = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_INTERMEDIATE_FB,
    
    
    RightHandMiddleDistal = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_DISTAL_FB,
    
    
    RightHandMiddleTip = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_TIP_FB,
    
    
    RightHandRingMetacarpal = XR_BODY_JOINT_RIGHT_HAND_RING_METACARPAL_FB,
    
    
    RightHandRingProximal = XR_BODY_JOINT_RIGHT_HAND_RING_PROXIMAL_FB,
    
    
    RightHandRingIntermediate = XR_BODY_JOINT_RIGHT_HAND_RING_INTERMEDIATE_FB,
    
    
    RightHandRingDistal = XR_BODY_JOINT_RIGHT_HAND_RING_DISTAL_FB,
    
    
    RightHandRingTip = XR_BODY_JOINT_RIGHT_HAND_RING_TIP_FB,
    
    
    RightHandLittleMetacarpal = XR_BODY_JOINT_RIGHT_HAND_LITTLE_METACARPAL_FB,
    
    
    RightHandLittleProximal = XR_BODY_JOINT_RIGHT_HAND_LITTLE_PROXIMAL_FB,
    
    
    RightHandLittleIntermediate = XR_BODY_JOINT_RIGHT_HAND_LITTLE_INTERMEDIATE_FB,
    
    
    RightHandLittleDistal = XR_BODY_JOINT_RIGHT_HAND_LITTLE_DISTAL_FB,
    
    
    RightHandLittleTip = XR_BODY_JOINT_RIGHT_HAND_LITTLE_TIP_FB,
    
    
    Count = XR_BODY_JOINT_COUNT_FB,
    
    
    None = XR_BODY_JOINT_NONE_FB,
    
};
 static_assert(sizeof(BodyJointFB) == sizeof(XrBodyJointFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointFB value from a BodyJointFB.
 * 
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointFB get(BodyJointFB const& v) {
    return static_cast<XrBodyJointFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointFB value as a const char *.
 * 
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointFB value) {
    switch (value) {
            
        case BodyJointFB::Root:
            return "Root";
            
            
        case BodyJointFB::Hips:
            return "Hips";
            
            
        case BodyJointFB::SpineLower:
            return "SpineLower";
            
            
        case BodyJointFB::SpineMiddle:
            return "SpineMiddle";
            
            
        case BodyJointFB::SpineUpper:
            return "SpineUpper";
            
            
        case BodyJointFB::Chest:
            return "Chest";
            
            
        case BodyJointFB::Neck:
            return "Neck";
            
            
        case BodyJointFB::Head:
            return "Head";
            
            
        case BodyJointFB::LeftShoulder:
            return "LeftShoulder";
            
            
        case BodyJointFB::LeftScapula:
            return "LeftScapula";
            
            
        case BodyJointFB::LeftArmUpper:
            return "LeftArmUpper";
            
            
        case BodyJointFB::LeftArmLower:
            return "LeftArmLower";
            
            
        case BodyJointFB::LeftHandWristTwist:
            return "LeftHandWristTwist";
            
            
        case BodyJointFB::RightShoulder:
            return "RightShoulder";
            
            
        case BodyJointFB::RightScapula:
            return "RightScapula";
            
            
        case BodyJointFB::RightArmUpper:
            return "RightArmUpper";
            
            
        case BodyJointFB::RightArmLower:
            return "RightArmLower";
            
            
        case BodyJointFB::RightHandWristTwist:
            return "RightHandWristTwist";
            
            
        case BodyJointFB::LeftHandPalm:
            return "LeftHandPalm";
            
            
        case BodyJointFB::LeftHandWrist:
            return "LeftHandWrist";
            
            
        case BodyJointFB::LeftHandThumbMetacarpal:
            return "LeftHandThumbMetacarpal";
            
            
        case BodyJointFB::LeftHandThumbProximal:
            return "LeftHandThumbProximal";
            
            
        case BodyJointFB::LeftHandThumbDistal:
            return "LeftHandThumbDistal";
            
            
        case BodyJointFB::LeftHandThumbTip:
            return "LeftHandThumbTip";
            
            
        case BodyJointFB::LeftHandIndexMetacarpal:
            return "LeftHandIndexMetacarpal";
            
            
        case BodyJointFB::LeftHandIndexProximal:
            return "LeftHandIndexProximal";
            
            
        case BodyJointFB::LeftHandIndexIntermediate:
            return "LeftHandIndexIntermediate";
            
            
        case BodyJointFB::LeftHandIndexDistal:
            return "LeftHandIndexDistal";
            
            
        case BodyJointFB::LeftHandIndexTip:
            return "LeftHandIndexTip";
            
            
        case BodyJointFB::LeftHandMiddleMetacarpal:
            return "LeftHandMiddleMetacarpal";
            
            
        case BodyJointFB::LeftHandMiddleProximal:
            return "LeftHandMiddleProximal";
            
            
        case BodyJointFB::LeftHandMiddleIntermediate:
            return "LeftHandMiddleIntermediate";
            
            
        case BodyJointFB::LeftHandMiddleDistal:
            return "LeftHandMiddleDistal";
            
            
        case BodyJointFB::LeftHandMiddleTip:
            return "LeftHandMiddleTip";
            
            
        case BodyJointFB::LeftHandRingMetacarpal:
            return "LeftHandRingMetacarpal";
            
            
        case BodyJointFB::LeftHandRingProximal:
            return "LeftHandRingProximal";
            
            
        case BodyJointFB::LeftHandRingIntermediate:
            return "LeftHandRingIntermediate";
            
            
        case BodyJointFB::LeftHandRingDistal:
            return "LeftHandRingDistal";
            
            
        case BodyJointFB::LeftHandRingTip:
            return "LeftHandRingTip";
            
            
        case BodyJointFB::LeftHandLittleMetacarpal:
            return "LeftHandLittleMetacarpal";
            
            
        case BodyJointFB::LeftHandLittleProximal:
            return "LeftHandLittleProximal";
            
            
        case BodyJointFB::LeftHandLittleIntermediate:
            return "LeftHandLittleIntermediate";
            
            
        case BodyJointFB::LeftHandLittleDistal:
            return "LeftHandLittleDistal";
            
            
        case BodyJointFB::LeftHandLittleTip:
            return "LeftHandLittleTip";
            
            
        case BodyJointFB::RightHandPalm:
            return "RightHandPalm";
            
            
        case BodyJointFB::RightHandWrist:
            return "RightHandWrist";
            
            
        case BodyJointFB::RightHandThumbMetacarpal:
            return "RightHandThumbMetacarpal";
            
            
        case BodyJointFB::RightHandThumbProximal:
            return "RightHandThumbProximal";
            
            
        case BodyJointFB::RightHandThumbDistal:
            return "RightHandThumbDistal";
            
            
        case BodyJointFB::RightHandThumbTip:
            return "RightHandThumbTip";
            
            
        case BodyJointFB::RightHandIndexMetacarpal:
            return "RightHandIndexMetacarpal";
            
            
        case BodyJointFB::RightHandIndexProximal:
            return "RightHandIndexProximal";
            
            
        case BodyJointFB::RightHandIndexIntermediate:
            return "RightHandIndexIntermediate";
            
            
        case BodyJointFB::RightHandIndexDistal:
            return "RightHandIndexDistal";
            
            
        case BodyJointFB::RightHandIndexTip:
            return "RightHandIndexTip";
            
            
        case BodyJointFB::RightHandMiddleMetacarpal:
            return "RightHandMiddleMetacarpal";
            
            
        case BodyJointFB::RightHandMiddleProximal:
            return "RightHandMiddleProximal";
            
            
        case BodyJointFB::RightHandMiddleIntermediate:
            return "RightHandMiddleIntermediate";
            
            
        case BodyJointFB::RightHandMiddleDistal:
            return "RightHandMiddleDistal";
            
            
        case BodyJointFB::RightHandMiddleTip:
            return "RightHandMiddleTip";
            
            
        case BodyJointFB::RightHandRingMetacarpal:
            return "RightHandRingMetacarpal";
            
            
        case BodyJointFB::RightHandRingProximal:
            return "RightHandRingProximal";
            
            
        case BodyJointFB::RightHandRingIntermediate:
            return "RightHandRingIntermediate";
            
            
        case BodyJointFB::RightHandRingDistal:
            return "RightHandRingDistal";
            
            
        case BodyJointFB::RightHandRingTip:
            return "RightHandRingTip";
            
            
        case BodyJointFB::RightHandLittleMetacarpal:
            return "RightHandLittleMetacarpal";
            
            
        case BodyJointFB::RightHandLittleProximal:
            return "RightHandLittleProximal";
            
            
        case BodyJointFB::RightHandLittleIntermediate:
            return "RightHandLittleIntermediate";
            
            
        case BodyJointFB::RightHandLittleDistal:
            return "RightHandLittleDistal";
            
            
        case BodyJointFB::RightHandLittleTip:
            return "RightHandLittleTip";
            
            
        case BodyJointFB::Count:
            return "Count";
            
            
        case BodyJointFB::None:
            return "None";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointFB value as a std::string.
 * 
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_body_tracking

































#ifdef XR_FB_body_tracking
/*!
 * @brief Enum class for XrBodyJointSetFB
 * 
 * Provided by the `XR_FB_body_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointSetFB>
 * 
 * @xrentity{XrBodyJointSetFB}
 */
enum class BodyJointSetFB: int32_t {
    
    Default = XR_BODY_JOINT_SET_DEFAULT_FB,
    
};
 static_assert(sizeof(BodyJointSetFB) == sizeof(XrBodyJointSetFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetFB value from a BodyJointSetFB.
 * 
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointSetFB get(BodyJointSetFB const& v) {
    return static_cast<XrBodyJointSetFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetFB value as a const char *.
 * 
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointSetFB value) {
    switch (value) {
            
        case BodyJointSetFB::Default:
            return "Default";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetFB value as a std::string.
 * 
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointSetFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_body_tracking

































#ifdef XR_EXT_hand_joints_motion_range
/*!
 * @brief Enum class for XrHandJointsMotionRangeEXT
 * 
 * Provided by the `XR_EXT_hand_joints_motion_range` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsMotionRangeEXT>
 * 
 * @xrentity{XrHandJointsMotionRangeEXT}
 */
enum class HandJointsMotionRangeEXT: int32_t {
    
    Unobstructed = XR_HAND_JOINTS_MOTION_RANGE_UNOBSTRUCTED_EXT,
    
    
    ConformingToController = XR_HAND_JOINTS_MOTION_RANGE_CONFORMING_TO_CONTROLLER_EXT,
    
};
 static_assert(sizeof(HandJointsMotionRangeEXT) == sizeof(XrHandJointsMotionRangeEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointsMotionRangeEXT value from a HandJointsMotionRangeEXT.
 * 
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointsMotionRangeEXT get(HandJointsMotionRangeEXT const& v) {
    return static_cast<XrHandJointsMotionRangeEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointsMotionRangeEXT value as a const char *.
 * 
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointsMotionRangeEXT value) {
    switch (value) {
            
        case HandJointsMotionRangeEXT::Unobstructed:
            return "Unobstructed";
            
            
        case HandJointsMotionRangeEXT::ConformingToController:
            return "ConformingToController";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointsMotionRangeEXT value as a std::string.
 * 
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointsMotionRangeEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_joints_motion_range

































#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrEyeExpressionHTC
 * 
 * Provided by the `XR_HTC_facial_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeExpressionHTC>
 * 
 * @xrentity{XrEyeExpressionHTC}
 */
enum class EyeExpressionHTC: int32_t {
    
    LeftBlink = XR_EYE_EXPRESSION_LEFT_BLINK_HTC,
    
    
    LeftWide = XR_EYE_EXPRESSION_LEFT_WIDE_HTC,
    
    
    RightBlink = XR_EYE_EXPRESSION_RIGHT_BLINK_HTC,
    
    
    RightWide = XR_EYE_EXPRESSION_RIGHT_WIDE_HTC,
    
    
    LeftSqueeze = XR_EYE_EXPRESSION_LEFT_SQUEEZE_HTC,
    
    
    RightSqueeze = XR_EYE_EXPRESSION_RIGHT_SQUEEZE_HTC,
    
    
    LeftDown = XR_EYE_EXPRESSION_LEFT_DOWN_HTC,
    
    
    RightDown = XR_EYE_EXPRESSION_RIGHT_DOWN_HTC,
    
    
    LeftOut = XR_EYE_EXPRESSION_LEFT_OUT_HTC,
    
    
    RightIn = XR_EYE_EXPRESSION_RIGHT_IN_HTC,
    
    
    LeftIn = XR_EYE_EXPRESSION_LEFT_IN_HTC,
    
    
    RightOut = XR_EYE_EXPRESSION_RIGHT_OUT_HTC,
    
    
    LeftUp = XR_EYE_EXPRESSION_LEFT_UP_HTC,
    
    
    RightUp = XR_EYE_EXPRESSION_RIGHT_UP_HTC,
    
};
 static_assert(sizeof(EyeExpressionHTC) == sizeof(XrEyeExpressionHTC), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeExpressionHTC value from a EyeExpressionHTC.
 * 
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeExpressionHTC get(EyeExpressionHTC const& v) {
    return static_cast<XrEyeExpressionHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeExpressionHTC value as a const char *.
 * 
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyeExpressionHTC value) {
    switch (value) {
            
        case EyeExpressionHTC::LeftBlink:
            return "LeftBlink";
            
            
        case EyeExpressionHTC::LeftWide:
            return "LeftWide";
            
            
        case EyeExpressionHTC::RightBlink:
            return "RightBlink";
            
            
        case EyeExpressionHTC::RightWide:
            return "RightWide";
            
            
        case EyeExpressionHTC::LeftSqueeze:
            return "LeftSqueeze";
            
            
        case EyeExpressionHTC::RightSqueeze:
            return "RightSqueeze";
            
            
        case EyeExpressionHTC::LeftDown:
            return "LeftDown";
            
            
        case EyeExpressionHTC::RightDown:
            return "RightDown";
            
            
        case EyeExpressionHTC::LeftOut:
            return "LeftOut";
            
            
        case EyeExpressionHTC::RightIn:
            return "RightIn";
            
            
        case EyeExpressionHTC::LeftIn:
            return "LeftIn";
            
            
        case EyeExpressionHTC::RightOut:
            return "RightOut";
            
            
        case EyeExpressionHTC::LeftUp:
            return "LeftUp";
            
            
        case EyeExpressionHTC::RightUp:
            return "RightUp";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a EyeExpressionHTC value as a std::string.
 * 
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeExpressionHTC value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

































#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrLipExpressionHTC
 * 
 * Provided by the `XR_HTC_facial_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLipExpressionHTC>
 * 
 * @xrentity{XrLipExpressionHTC}
 */
enum class LipExpressionHTC: int32_t {
    
    JawRight = XR_LIP_EXPRESSION_JAW_RIGHT_HTC,
    
    
    JawLeft = XR_LIP_EXPRESSION_JAW_LEFT_HTC,
    
    
    JawForward = XR_LIP_EXPRESSION_JAW_FORWARD_HTC,
    
    
    JawOpen = XR_LIP_EXPRESSION_JAW_OPEN_HTC,
    
    
    MouthApeShape = XR_LIP_EXPRESSION_MOUTH_APE_SHAPE_HTC,
    
    
    MouthUpperRight = XR_LIP_EXPRESSION_MOUTH_UPPER_RIGHT_HTC,
    
    
    MouthUpperLeft = XR_LIP_EXPRESSION_MOUTH_UPPER_LEFT_HTC,
    
    
    MouthLowerRight = XR_LIP_EXPRESSION_MOUTH_LOWER_RIGHT_HTC,
    
    
    MouthLowerLeft = XR_LIP_EXPRESSION_MOUTH_LOWER_LEFT_HTC,
    
    
    MouthUpperOverturn = XR_LIP_EXPRESSION_MOUTH_UPPER_OVERTURN_HTC,
    
    
    MouthLowerOverturn = XR_LIP_EXPRESSION_MOUTH_LOWER_OVERTURN_HTC,
    
    
    MouthPout = XR_LIP_EXPRESSION_MOUTH_POUT_HTC,
    
    
    MouthSmileRight = XR_LIP_EXPRESSION_MOUTH_SMILE_RIGHT_HTC,
    
    
    MouthSmileLeft = XR_LIP_EXPRESSION_MOUTH_SMILE_LEFT_HTC,
    
    
    MouthSadRight = XR_LIP_EXPRESSION_MOUTH_SAD_RIGHT_HTC,
    
    
    MouthSadLeft = XR_LIP_EXPRESSION_MOUTH_SAD_LEFT_HTC,
    
    
    CheekPuffRight = XR_LIP_EXPRESSION_CHEEK_PUFF_RIGHT_HTC,
    
    
    CheekPuffLeft = XR_LIP_EXPRESSION_CHEEK_PUFF_LEFT_HTC,
    
    
    CheekSuck = XR_LIP_EXPRESSION_CHEEK_SUCK_HTC,
    
    
    MouthUpperUpright = XR_LIP_EXPRESSION_MOUTH_UPPER_UPRIGHT_HTC,
    
    
    MouthUpperUpleft = XR_LIP_EXPRESSION_MOUTH_UPPER_UPLEFT_HTC,
    
    
    MouthLowerDownright = XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNRIGHT_HTC,
    
    
    MouthLowerDownleft = XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNLEFT_HTC,
    
    
    MouthUpperInside = XR_LIP_EXPRESSION_MOUTH_UPPER_INSIDE_HTC,
    
    
    MouthLowerInside = XR_LIP_EXPRESSION_MOUTH_LOWER_INSIDE_HTC,
    
    
    MouthLowerOverlay = XR_LIP_EXPRESSION_MOUTH_LOWER_OVERLAY_HTC,
    
    
    TongueLongstep1 = XR_LIP_EXPRESSION_TONGUE_LONGSTEP1_HTC,
    
    
    TongueLeft = XR_LIP_EXPRESSION_TONGUE_LEFT_HTC,
    
    
    TongueRight = XR_LIP_EXPRESSION_TONGUE_RIGHT_HTC,
    
    
    TongueUp = XR_LIP_EXPRESSION_TONGUE_UP_HTC,
    
    
    TongueDown = XR_LIP_EXPRESSION_TONGUE_DOWN_HTC,
    
    
    TongueRoll = XR_LIP_EXPRESSION_TONGUE_ROLL_HTC,
    
    
    TongueLongstep2 = XR_LIP_EXPRESSION_TONGUE_LONGSTEP2_HTC,
    
    
    TongueUprightMorph = XR_LIP_EXPRESSION_TONGUE_UPRIGHT_MORPH_HTC,
    
    
    TongueUpleftMorph = XR_LIP_EXPRESSION_TONGUE_UPLEFT_MORPH_HTC,
    
    
    TongueDownrightMorph = XR_LIP_EXPRESSION_TONGUE_DOWNRIGHT_MORPH_HTC,
    
    
    TongueDownleftMorph = XR_LIP_EXPRESSION_TONGUE_DOWNLEFT_MORPH_HTC,
    
};
 static_assert(sizeof(LipExpressionHTC) == sizeof(XrLipExpressionHTC), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLipExpressionHTC value from a LipExpressionHTC.
 * 
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLipExpressionHTC get(LipExpressionHTC const& v) {
    return static_cast<XrLipExpressionHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a LipExpressionHTC value as a const char *.
 * 
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(LipExpressionHTC value) {
    switch (value) {
            
        case LipExpressionHTC::JawRight:
            return "JawRight";
            
            
        case LipExpressionHTC::JawLeft:
            return "JawLeft";
            
            
        case LipExpressionHTC::JawForward:
            return "JawForward";
            
            
        case LipExpressionHTC::JawOpen:
            return "JawOpen";
            
            
        case LipExpressionHTC::MouthApeShape:
            return "MouthApeShape";
            
            
        case LipExpressionHTC::MouthUpperRight:
            return "MouthUpperRight";
            
            
        case LipExpressionHTC::MouthUpperLeft:
            return "MouthUpperLeft";
            
            
        case LipExpressionHTC::MouthLowerRight:
            return "MouthLowerRight";
            
            
        case LipExpressionHTC::MouthLowerLeft:
            return "MouthLowerLeft";
            
            
        case LipExpressionHTC::MouthUpperOverturn:
            return "MouthUpperOverturn";
            
            
        case LipExpressionHTC::MouthLowerOverturn:
            return "MouthLowerOverturn";
            
            
        case LipExpressionHTC::MouthPout:
            return "MouthPout";
            
            
        case LipExpressionHTC::MouthSmileRight:
            return "MouthSmileRight";
            
            
        case LipExpressionHTC::MouthSmileLeft:
            return "MouthSmileLeft";
            
            
        case LipExpressionHTC::MouthSadRight:
            return "MouthSadRight";
            
            
        case LipExpressionHTC::MouthSadLeft:
            return "MouthSadLeft";
            
            
        case LipExpressionHTC::CheekPuffRight:
            return "CheekPuffRight";
            
            
        case LipExpressionHTC::CheekPuffLeft:
            return "CheekPuffLeft";
            
            
        case LipExpressionHTC::CheekSuck:
            return "CheekSuck";
            
            
        case LipExpressionHTC::MouthUpperUpright:
            return "MouthUpperUpright";
            
            
        case LipExpressionHTC::MouthUpperUpleft:
            return "MouthUpperUpleft";
            
            
        case LipExpressionHTC::MouthLowerDownright:
            return "MouthLowerDownright";
            
            
        case LipExpressionHTC::MouthLowerDownleft:
            return "MouthLowerDownleft";
            
            
        case LipExpressionHTC::MouthUpperInside:
            return "MouthUpperInside";
            
            
        case LipExpressionHTC::MouthLowerInside:
            return "MouthLowerInside";
            
            
        case LipExpressionHTC::MouthLowerOverlay:
            return "MouthLowerOverlay";
            
            
        case LipExpressionHTC::TongueLongstep1:
            return "TongueLongstep1";
            
            
        case LipExpressionHTC::TongueLeft:
            return "TongueLeft";
            
            
        case LipExpressionHTC::TongueRight:
            return "TongueRight";
            
            
        case LipExpressionHTC::TongueUp:
            return "TongueUp";
            
            
        case LipExpressionHTC::TongueDown:
            return "TongueDown";
            
            
        case LipExpressionHTC::TongueRoll:
            return "TongueRoll";
            
            
        case LipExpressionHTC::TongueLongstep2:
            return "TongueLongstep2";
            
            
        case LipExpressionHTC::TongueUprightMorph:
            return "TongueUprightMorph";
            
            
        case LipExpressionHTC::TongueUpleftMorph:
            return "TongueUpleftMorph";
            
            
        case LipExpressionHTC::TongueDownrightMorph:
            return "TongueDownrightMorph";
            
            
        case LipExpressionHTC::TongueDownleftMorph:
            return "TongueDownleftMorph";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a LipExpressionHTC value as a std::string.
 * 
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LipExpressionHTC value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

































#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrFacialTrackingTypeHTC
 * 
 * Provided by the `XR_HTC_facial_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackingTypeHTC>
 * 
 * @xrentity{XrFacialTrackingTypeHTC}
 */
enum class FacialTrackingTypeHTC: int32_t {
    
    EyeDefault = XR_FACIAL_TRACKING_TYPE_EYE_DEFAULT_HTC,
    
    
    LipDefault = XR_FACIAL_TRACKING_TYPE_LIP_DEFAULT_HTC,
    
};
 static_assert(sizeof(FacialTrackingTypeHTC) == sizeof(XrFacialTrackingTypeHTC), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFacialTrackingTypeHTC value from a FacialTrackingTypeHTC.
 * 
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFacialTrackingTypeHTC get(FacialTrackingTypeHTC const& v) {
    return static_cast<XrFacialTrackingTypeHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FacialTrackingTypeHTC value as a const char *.
 * 
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FacialTrackingTypeHTC value) {
    switch (value) {
            
        case FacialTrackingTypeHTC::EyeDefault:
            return "EyeDefault";
            
            
        case FacialTrackingTypeHTC::LipDefault:
            return "LipDefault";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FacialTrackingTypeHTC value as a std::string.
 * 
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FacialTrackingTypeHTC value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

































#ifdef XR_FB_color_space
/*!
 * @brief Enum class for XrColorSpaceFB
 * 
 * Provided by the `XR_FB_color_space` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColorSpaceFB>
 * 
 * @xrentity{XrColorSpaceFB}
 */
enum class ColorSpaceFB: int32_t {
    
    Unmanaged = XR_COLOR_SPACE_UNMANAGED_FB,
    
    
    Rec2020 = XR_COLOR_SPACE_REC2020_FB,
    
    
    Rec709 = XR_COLOR_SPACE_REC709_FB,
    
    
    RiftCV1 = XR_COLOR_SPACE_RIFT_CV1_FB,
    
    
    RiftS = XR_COLOR_SPACE_RIFT_S_FB,
    
    
    Quest = XR_COLOR_SPACE_QUEST_FB,
    
    
    P3 = XR_COLOR_SPACE_P3_FB,
    
    
    AdobeRGB = XR_COLOR_SPACE_ADOBE_RGB_FB,
    
};
 static_assert(sizeof(ColorSpaceFB) == sizeof(XrColorSpaceFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrColorSpaceFB value from a ColorSpaceFB.
 * 
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrColorSpaceFB get(ColorSpaceFB const& v) {
    return static_cast<XrColorSpaceFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ColorSpaceFB value as a const char *.
 * 
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ColorSpaceFB value) {
    switch (value) {
            
        case ColorSpaceFB::Unmanaged:
            return "Unmanaged";
            
            
        case ColorSpaceFB::Rec2020:
            return "Rec2020";
            
            
        case ColorSpaceFB::Rec709:
            return "Rec709";
            
            
        case ColorSpaceFB::RiftCV1:
            return "RiftCV1";
            
            
        case ColorSpaceFB::RiftS:
            return "RiftS";
            
            
        case ColorSpaceFB::Quest:
            return "Quest";
            
            
        case ColorSpaceFB::P3:
            return "P3";
            
            
        case ColorSpaceFB::AdobeRGB:
            return "AdobeRGB";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ColorSpaceFB value as a std::string.
 * 
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ColorSpaceFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_color_space

































#ifdef XR_FB_spatial_entity
/*!
 * @brief Enum class for XrSpaceComponentTypeFB
 * 
 * Provided by the `XR_FB_spatial_entity` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentTypeFB>
 * 
 * @xrentity{XrSpaceComponentTypeFB}
 */
enum class SpaceComponentTypeFB: int32_t {
    
    Locatable = XR_SPACE_COMPONENT_TYPE_LOCATABLE_FB,
    
    
    Storable = XR_SPACE_COMPONENT_TYPE_STORABLE_FB,
    
    
    Sharable = XR_SPACE_COMPONENT_TYPE_SHARABLE_FB,
    
    
    Bounded2D = XR_SPACE_COMPONENT_TYPE_BOUNDED_2D_FB,
    
    
    Bounded3D = XR_SPACE_COMPONENT_TYPE_BOUNDED_3D_FB,
    
    
    SemanticLabels = XR_SPACE_COMPONENT_TYPE_SEMANTIC_LABELS_FB,
    
    
    RoomLayout = XR_SPACE_COMPONENT_TYPE_ROOM_LAYOUT_FB,
    
    
    SpaceContainer = XR_SPACE_COMPONENT_TYPE_SPACE_CONTAINER_FB,
    
};
 static_assert(sizeof(SpaceComponentTypeFB) == sizeof(XrSpaceComponentTypeFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceComponentTypeFB value from a SpaceComponentTypeFB.
 * 
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpaceComponentTypeFB get(SpaceComponentTypeFB const& v) {
    return static_cast<XrSpaceComponentTypeFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SpaceComponentTypeFB value as a const char *.
 * 
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SpaceComponentTypeFB value) {
    switch (value) {
            
        case SpaceComponentTypeFB::Locatable:
            return "Locatable";
            
            
        case SpaceComponentTypeFB::Storable:
            return "Storable";
            
            
        case SpaceComponentTypeFB::Sharable:
            return "Sharable";
            
            
        case SpaceComponentTypeFB::Bounded2D:
            return "Bounded2D";
            
            
        case SpaceComponentTypeFB::Bounded3D:
            return "Bounded3D";
            
            
        case SpaceComponentTypeFB::SemanticLabels:
            return "SemanticLabels";
            
            
        case SpaceComponentTypeFB::RoomLayout:
            return "RoomLayout";
            
            
        case SpaceComponentTypeFB::SpaceContainer:
            return "SpaceContainer";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SpaceComponentTypeFB value as a std::string.
 * 
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpaceComponentTypeFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity

































#ifdef XR_FB_foveation_configuration
/*!
 * @brief Enum class for XrFoveationLevelFB
 * 
 * Provided by the `XR_FB_foveation_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelFB>
 * 
 * @xrentity{XrFoveationLevelFB}
 */
enum class FoveationLevelFB: int32_t {
    
    None = XR_FOVEATION_LEVEL_NONE_FB,
    
    
    Low = XR_FOVEATION_LEVEL_LOW_FB,
    
    
    Medium = XR_FOVEATION_LEVEL_MEDIUM_FB,
    
    
    High = XR_FOVEATION_LEVEL_HIGH_FB,
    
};
 static_assert(sizeof(FoveationLevelFB) == sizeof(XrFoveationLevelFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelFB value from a FoveationLevelFB.
 * 
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationLevelFB get(FoveationLevelFB const& v) {
    return static_cast<XrFoveationLevelFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelFB value as a const char *.
 * 
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FoveationLevelFB value) {
    switch (value) {
            
        case FoveationLevelFB::None:
            return "None";
            
            
        case FoveationLevelFB::Low:
            return "Low";
            
            
        case FoveationLevelFB::Medium:
            return "Medium";
            
            
        case FoveationLevelFB::High:
            return "High";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelFB value as a std::string.
 * 
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationLevelFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_foveation_configuration

































#ifdef XR_FB_foveation_configuration
/*!
 * @brief Enum class for XrFoveationDynamicFB
 * 
 * Provided by the `XR_FB_foveation_configuration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationDynamicFB>
 * 
 * @xrentity{XrFoveationDynamicFB}
 */
enum class FoveationDynamicFB: int32_t {
    
    Disabled = XR_FOVEATION_DYNAMIC_DISABLED_FB,
    
    
    LevelEnabled = XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_FB,
    
};
 static_assert(sizeof(FoveationDynamicFB) == sizeof(XrFoveationDynamicFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationDynamicFB value from a FoveationDynamicFB.
 * 
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationDynamicFB get(FoveationDynamicFB const& v) {
    return static_cast<XrFoveationDynamicFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationDynamicFB value as a const char *.
 * 
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FoveationDynamicFB value) {
    switch (value) {
            
        case FoveationDynamicFB::Disabled:
            return "Disabled";
            
            
        case FoveationDynamicFB::LevelEnabled:
            return "LevelEnabled";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationDynamicFB value as a std::string.
 * 
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationDynamicFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_foveation_configuration

































#ifdef XR_FB_triangle_mesh
/*!
 * @brief Enum class for XrWindingOrderFB
 * 
 * Provided by the `XR_FB_triangle_mesh` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWindingOrderFB>
 * 
 * @xrentity{XrWindingOrderFB}
 */
enum class WindingOrderFB: int32_t {
    
    Unknown = XR_WINDING_ORDER_UNKNOWN_FB,
    
    
    CW = XR_WINDING_ORDER_CW_FB,
    
    
    CCW = XR_WINDING_ORDER_CCW_FB,
    
};
 static_assert(sizeof(WindingOrderFB) == sizeof(XrWindingOrderFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWindingOrderFB value from a WindingOrderFB.
 * 
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrWindingOrderFB get(WindingOrderFB const& v) {
    return static_cast<XrWindingOrderFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a WindingOrderFB value as a const char *.
 * 
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(WindingOrderFB value) {
    switch (value) {
            
        case WindingOrderFB::Unknown:
            return "Unknown";
            
            
        case WindingOrderFB::CW:
            return "CW";
            
            
        case WindingOrderFB::CCW:
            return "CCW";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a WindingOrderFB value as a std::string.
 * 
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(WindingOrderFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_triangle_mesh

































#ifdef XR_FB_passthrough
/*!
 * @brief Enum class for XrPassthroughLayerPurposeFB
 * 
 * Provided by the `XR_FB_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerPurposeFB>
 * 
 * @xrentity{XrPassthroughLayerPurposeFB}
 */
enum class PassthroughLayerPurposeFB: int32_t {
    
    Reconstruction = XR_PASSTHROUGH_LAYER_PURPOSE_RECONSTRUCTION_FB,
    
    
    Projected = XR_PASSTHROUGH_LAYER_PURPOSE_PROJECTED_FB,
    
    #ifdef XR_FB_passthrough_keyboard_hands
    TrackedKeyboardHands = XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB,
    #endif  // XR_FB_passthrough_keyboard_hands
    #ifdef XR_FB_passthrough_keyboard_hands
    TrackedKeyboardMaskedHands = XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB,
    #endif  // XR_FB_passthrough_keyboard_hands
};
 static_assert(sizeof(PassthroughLayerPurposeFB) == sizeof(XrPassthroughLayerPurposeFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughLayerPurposeFB value from a PassthroughLayerPurposeFB.
 * 
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughLayerPurposeFB get(PassthroughLayerPurposeFB const& v) {
    return static_cast<XrPassthroughLayerPurposeFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughLayerPurposeFB value as a const char *.
 * 
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PassthroughLayerPurposeFB value) {
    switch (value) {
            
        case PassthroughLayerPurposeFB::Reconstruction:
            return "Reconstruction";
            
            
        case PassthroughLayerPurposeFB::Projected:
            return "Projected";
            
            #ifdef XR_FB_passthrough_keyboard_hands
        case PassthroughLayerPurposeFB::TrackedKeyboardHands:
            return "TrackedKeyboardHands";
            #endif  // XR_FB_passthrough_keyboard_hands
            #ifdef XR_FB_passthrough_keyboard_hands
        case PassthroughLayerPurposeFB::TrackedKeyboardMaskedHands:
            return "TrackedKeyboardMaskedHands";
            #endif  // XR_FB_passthrough_keyboard_hands
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughLayerPurposeFB value as a std::string.
 * 
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PassthroughLayerPurposeFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_passthrough

































#ifdef XR_MSFT_scene_marker
/*!
 * @brief Enum class for XrSceneMarkerTypeMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerTypeMSFT>
 * 
 * @xrentity{XrSceneMarkerTypeMSFT}
 */
enum class SceneMarkerTypeMSFT: int32_t {
    
    QrCode = XR_SCENE_MARKER_TYPE_QR_CODE_MSFT,
    
};
 static_assert(sizeof(SceneMarkerTypeMSFT) == sizeof(XrSceneMarkerTypeMSFT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneMarkerTypeMSFT value from a SceneMarkerTypeMSFT.
 * 
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneMarkerTypeMSFT get(SceneMarkerTypeMSFT const& v) {
    return static_cast<XrSceneMarkerTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerTypeMSFT value as a const char *.
 * 
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SceneMarkerTypeMSFT value) {
    switch (value) {
            
        case SceneMarkerTypeMSFT::QrCode:
            return "QrCode";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerTypeMSFT value as a std::string.
 * 
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneMarkerTypeMSFT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_marker

































#ifdef XR_MSFT_scene_marker
/*!
 * @brief Enum class for XrSceneMarkerQRCodeSymbolTypeMSFT
 * 
 * Provided by the `XR_MSFT_scene_marker` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerQRCodeSymbolTypeMSFT>
 * 
 * @xrentity{XrSceneMarkerQRCodeSymbolTypeMSFT}
 */
enum class SceneMarkerQRCodeSymbolTypeMSFT: int32_t {
    
    QrCode = XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_QR_CODE_MSFT,
    
    
    MicroQrCode = XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_MICRO_QR_CODE_MSFT,
    
};
 static_assert(sizeof(SceneMarkerQRCodeSymbolTypeMSFT) == sizeof(XrSceneMarkerQRCodeSymbolTypeMSFT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneMarkerQRCodeSymbolTypeMSFT value from a SceneMarkerQRCodeSymbolTypeMSFT.
 * 
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneMarkerQRCodeSymbolTypeMSFT get(SceneMarkerQRCodeSymbolTypeMSFT const& v) {
    return static_cast<XrSceneMarkerQRCodeSymbolTypeMSFT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerQRCodeSymbolTypeMSFT value as a const char *.
 * 
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SceneMarkerQRCodeSymbolTypeMSFT value) {
    switch (value) {
            
        case SceneMarkerQRCodeSymbolTypeMSFT::QrCode:
            return "QrCode";
            
            
        case SceneMarkerQRCodeSymbolTypeMSFT::MicroQrCode:
            return "MicroQrCode";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerQRCodeSymbolTypeMSFT value as a std::string.
 * 
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneMarkerQRCodeSymbolTypeMSFT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_marker

































#ifdef XR_ULTRALEAP_hand_tracking_forearm
/*!
 * @brief Enum class for XrHandForearmJointULTRALEAP
 * 
 * Provided by the `XR_ULTRALEAP_hand_tracking_forearm` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandForearmJointULTRALEAP>
 * 
 * @xrentity{XrHandForearmJointULTRALEAP}
 */
enum class HandForearmJointULTRALEAP: int32_t {
    
    Palm = XR_HAND_FOREARM_JOINT_PALM_ULTRALEAP,
    
    
    Wrist = XR_HAND_FOREARM_JOINT_WRIST_ULTRALEAP,
    
    
    ThumbMetacarpal = XR_HAND_FOREARM_JOINT_THUMB_METACARPAL_ULTRALEAP,
    
    
    ThumbProximal = XR_HAND_FOREARM_JOINT_THUMB_PROXIMAL_ULTRALEAP,
    
    
    ThumbDistal = XR_HAND_FOREARM_JOINT_THUMB_DISTAL_ULTRALEAP,
    
    
    ThumbTip = XR_HAND_FOREARM_JOINT_THUMB_TIP_ULTRALEAP,
    
    
    IndexMetacarpal = XR_HAND_FOREARM_JOINT_INDEX_METACARPAL_ULTRALEAP,
    
    
    IndexProximal = XR_HAND_FOREARM_JOINT_INDEX_PROXIMAL_ULTRALEAP,
    
    
    IndexIntermediate = XR_HAND_FOREARM_JOINT_INDEX_INTERMEDIATE_ULTRALEAP,
    
    
    IndexDistal = XR_HAND_FOREARM_JOINT_INDEX_DISTAL_ULTRALEAP,
    
    
    IndexTip = XR_HAND_FOREARM_JOINT_INDEX_TIP_ULTRALEAP,
    
    
    MiddleMetacarpal = XR_HAND_FOREARM_JOINT_MIDDLE_METACARPAL_ULTRALEAP,
    
    
    MiddleProximal = XR_HAND_FOREARM_JOINT_MIDDLE_PROXIMAL_ULTRALEAP,
    
    
    MiddleIntermediate = XR_HAND_FOREARM_JOINT_MIDDLE_INTERMEDIATE_ULTRALEAP,
    
    
    MiddleDistal = XR_HAND_FOREARM_JOINT_MIDDLE_DISTAL_ULTRALEAP,
    
    
    MiddleTip = XR_HAND_FOREARM_JOINT_MIDDLE_TIP_ULTRALEAP,
    
    
    RingMetacarpal = XR_HAND_FOREARM_JOINT_RING_METACARPAL_ULTRALEAP,
    
    
    RingProximal = XR_HAND_FOREARM_JOINT_RING_PROXIMAL_ULTRALEAP,
    
    
    RingIntermediate = XR_HAND_FOREARM_JOINT_RING_INTERMEDIATE_ULTRALEAP,
    
    
    RingDistal = XR_HAND_FOREARM_JOINT_RING_DISTAL_ULTRALEAP,
    
    
    RingTip = XR_HAND_FOREARM_JOINT_RING_TIP_ULTRALEAP,
    
    
    LittleMetacarpal = XR_HAND_FOREARM_JOINT_LITTLE_METACARPAL_ULTRALEAP,
    
    
    LittleProximal = XR_HAND_FOREARM_JOINT_LITTLE_PROXIMAL_ULTRALEAP,
    
    
    LittleIntermediate = XR_HAND_FOREARM_JOINT_LITTLE_INTERMEDIATE_ULTRALEAP,
    
    
    LittleDistal = XR_HAND_FOREARM_JOINT_LITTLE_DISTAL_ULTRALEAP,
    
    
    LittleTip = XR_HAND_FOREARM_JOINT_LITTLE_TIP_ULTRALEAP,
    
    
    Elbow = XR_HAND_FOREARM_JOINT_ELBOW_ULTRALEAP,
    
};
 static_assert(sizeof(HandForearmJointULTRALEAP) == sizeof(XrHandForearmJointULTRALEAP), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandForearmJointULTRALEAP value from a HandForearmJointULTRALEAP.
 * 
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandForearmJointULTRALEAP get(HandForearmJointULTRALEAP const& v) {
    return static_cast<XrHandForearmJointULTRALEAP>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandForearmJointULTRALEAP value as a const char *.
 * 
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandForearmJointULTRALEAP value) {
    switch (value) {
            
        case HandForearmJointULTRALEAP::Palm:
            return "Palm";
            
            
        case HandForearmJointULTRALEAP::Wrist:
            return "Wrist";
            
            
        case HandForearmJointULTRALEAP::ThumbMetacarpal:
            return "ThumbMetacarpal";
            
            
        case HandForearmJointULTRALEAP::ThumbProximal:
            return "ThumbProximal";
            
            
        case HandForearmJointULTRALEAP::ThumbDistal:
            return "ThumbDistal";
            
            
        case HandForearmJointULTRALEAP::ThumbTip:
            return "ThumbTip";
            
            
        case HandForearmJointULTRALEAP::IndexMetacarpal:
            return "IndexMetacarpal";
            
            
        case HandForearmJointULTRALEAP::IndexProximal:
            return "IndexProximal";
            
            
        case HandForearmJointULTRALEAP::IndexIntermediate:
            return "IndexIntermediate";
            
            
        case HandForearmJointULTRALEAP::IndexDistal:
            return "IndexDistal";
            
            
        case HandForearmJointULTRALEAP::IndexTip:
            return "IndexTip";
            
            
        case HandForearmJointULTRALEAP::MiddleMetacarpal:
            return "MiddleMetacarpal";
            
            
        case HandForearmJointULTRALEAP::MiddleProximal:
            return "MiddleProximal";
            
            
        case HandForearmJointULTRALEAP::MiddleIntermediate:
            return "MiddleIntermediate";
            
            
        case HandForearmJointULTRALEAP::MiddleDistal:
            return "MiddleDistal";
            
            
        case HandForearmJointULTRALEAP::MiddleTip:
            return "MiddleTip";
            
            
        case HandForearmJointULTRALEAP::RingMetacarpal:
            return "RingMetacarpal";
            
            
        case HandForearmJointULTRALEAP::RingProximal:
            return "RingProximal";
            
            
        case HandForearmJointULTRALEAP::RingIntermediate:
            return "RingIntermediate";
            
            
        case HandForearmJointULTRALEAP::RingDistal:
            return "RingDistal";
            
            
        case HandForearmJointULTRALEAP::RingTip:
            return "RingTip";
            
            
        case HandForearmJointULTRALEAP::LittleMetacarpal:
            return "LittleMetacarpal";
            
            
        case HandForearmJointULTRALEAP::LittleProximal:
            return "LittleProximal";
            
            
        case HandForearmJointULTRALEAP::LittleIntermediate:
            return "LittleIntermediate";
            
            
        case HandForearmJointULTRALEAP::LittleDistal:
            return "LittleDistal";
            
            
        case HandForearmJointULTRALEAP::LittleTip:
            return "LittleTip";
            
            
        case HandForearmJointULTRALEAP::Elbow:
            return "Elbow";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandForearmJointULTRALEAP value as a std::string.
 * 
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandForearmJointULTRALEAP value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_ULTRALEAP_hand_tracking_forearm

































#ifdef XR_FB_spatial_entity_query
/*!
 * @brief Enum class for XrSpaceQueryActionFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryActionFB>
 * 
 * @xrentity{XrSpaceQueryActionFB}
 */
enum class SpaceQueryActionFB: int32_t {
    
    Load = XR_SPACE_QUERY_ACTION_LOAD_FB,
    
};
 static_assert(sizeof(SpaceQueryActionFB) == sizeof(XrSpaceQueryActionFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceQueryActionFB value from a SpaceQueryActionFB.
 * 
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpaceQueryActionFB get(SpaceQueryActionFB const& v) {
    return static_cast<XrSpaceQueryActionFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SpaceQueryActionFB value as a const char *.
 * 
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SpaceQueryActionFB value) {
    switch (value) {
            
        case SpaceQueryActionFB::Load:
            return "Load";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SpaceQueryActionFB value as a std::string.
 * 
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpaceQueryActionFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity_query

































#ifdef XR_FB_spatial_entity_query
/*!
 * @brief Enum class for XrSpaceStorageLocationFB
 * 
 * Provided by the `XR_FB_spatial_entity_query` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceStorageLocationFB>
 * 
 * @xrentity{XrSpaceStorageLocationFB}
 */
enum class SpaceStorageLocationFB: int32_t {
    
    Invalid = XR_SPACE_STORAGE_LOCATION_INVALID_FB,
    
    
    Local = XR_SPACE_STORAGE_LOCATION_LOCAL_FB,
    
    
    Cloud = XR_SPACE_STORAGE_LOCATION_CLOUD_FB,
    
};
 static_assert(sizeof(SpaceStorageLocationFB) == sizeof(XrSpaceStorageLocationFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceStorageLocationFB value from a SpaceStorageLocationFB.
 * 
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpaceStorageLocationFB get(SpaceStorageLocationFB const& v) {
    return static_cast<XrSpaceStorageLocationFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SpaceStorageLocationFB value as a const char *.
 * 
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SpaceStorageLocationFB value) {
    switch (value) {
            
        case SpaceStorageLocationFB::Invalid:
            return "Invalid";
            
            
        case SpaceStorageLocationFB::Local:
            return "Local";
            
            
        case SpaceStorageLocationFB::Cloud:
            return "Cloud";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SpaceStorageLocationFB value as a std::string.
 * 
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpaceStorageLocationFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity_query

































#ifdef XR_FB_spatial_entity_storage
/*!
 * @brief Enum class for XrSpacePersistenceModeFB
 * 
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpacePersistenceModeFB>
 * 
 * @xrentity{XrSpacePersistenceModeFB}
 */
enum class SpacePersistenceModeFB: int32_t {
    
    Invalid = XR_SPACE_PERSISTENCE_MODE_INVALID_FB,
    
    
    Indefinite = XR_SPACE_PERSISTENCE_MODE_INDEFINITE_FB,
    
};
 static_assert(sizeof(SpacePersistenceModeFB) == sizeof(XrSpacePersistenceModeFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpacePersistenceModeFB value from a SpacePersistenceModeFB.
 * 
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpacePersistenceModeFB get(SpacePersistenceModeFB const& v) {
    return static_cast<XrSpacePersistenceModeFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a SpacePersistenceModeFB value as a const char *.
 * 
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SpacePersistenceModeFB value) {
    switch (value) {
            
        case SpacePersistenceModeFB::Invalid:
            return "Invalid";
            
            
        case SpacePersistenceModeFB::Indefinite:
            return "Indefinite";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a SpacePersistenceModeFB value as a std::string.
 * 
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpacePersistenceModeFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity_storage

































#ifdef XR_FB_face_tracking
/*!
 * @brief Enum class for XrFaceExpressionFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionFB>
 * 
 * @xrentity{XrFaceExpressionFB}
 */
enum class FaceExpressionFB: int32_t {
    
    BrowLowererL = XR_FACE_EXPRESSION_BROW_LOWERER_L_FB,
    
    
    BrowLowererR = XR_FACE_EXPRESSION_BROW_LOWERER_R_FB,
    
    
    CheekPuffL = XR_FACE_EXPRESSION_CHEEK_PUFF_L_FB,
    
    
    CheekPuffR = XR_FACE_EXPRESSION_CHEEK_PUFF_R_FB,
    
    
    CheekRaiserL = XR_FACE_EXPRESSION_CHEEK_RAISER_L_FB,
    
    
    CheekRaiserR = XR_FACE_EXPRESSION_CHEEK_RAISER_R_FB,
    
    
    CheekSuckL = XR_FACE_EXPRESSION_CHEEK_SUCK_L_FB,
    
    
    CheekSuckR = XR_FACE_EXPRESSION_CHEEK_SUCK_R_FB,
    
    
    ChinRaiserB = XR_FACE_EXPRESSION_CHIN_RAISER_B_FB,
    
    
    ChinRaiserT = XR_FACE_EXPRESSION_CHIN_RAISER_T_FB,
    
    
    DimplerL = XR_FACE_EXPRESSION_DIMPLER_L_FB,
    
    
    DimplerR = XR_FACE_EXPRESSION_DIMPLER_R_FB,
    
    
    EyesClosedL = XR_FACE_EXPRESSION_EYES_CLOSED_L_FB,
    
    
    EyesClosedR = XR_FACE_EXPRESSION_EYES_CLOSED_R_FB,
    
    
    EyesLookDownL = XR_FACE_EXPRESSION_EYES_LOOK_DOWN_L_FB,
    
    
    EyesLookDownR = XR_FACE_EXPRESSION_EYES_LOOK_DOWN_R_FB,
    
    
    EyesLookLeftL = XR_FACE_EXPRESSION_EYES_LOOK_LEFT_L_FB,
    
    
    EyesLookLeftR = XR_FACE_EXPRESSION_EYES_LOOK_LEFT_R_FB,
    
    
    EyesLookRightL = XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_L_FB,
    
    
    EyesLookRightR = XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_R_FB,
    
    
    EyesLookUpL = XR_FACE_EXPRESSION_EYES_LOOK_UP_L_FB,
    
    
    EyesLookUpR = XR_FACE_EXPRESSION_EYES_LOOK_UP_R_FB,
    
    
    InnerBrowRaiserL = XR_FACE_EXPRESSION_INNER_BROW_RAISER_L_FB,
    
    
    InnerBrowRaiserR = XR_FACE_EXPRESSION_INNER_BROW_RAISER_R_FB,
    
    
    JawDrop = XR_FACE_EXPRESSION_JAW_DROP_FB,
    
    
    JawSidewaysLeft = XR_FACE_EXPRESSION_JAW_SIDEWAYS_LEFT_FB,
    
    
    JawSidewaysRight = XR_FACE_EXPRESSION_JAW_SIDEWAYS_RIGHT_FB,
    
    
    JawThrust = XR_FACE_EXPRESSION_JAW_THRUST_FB,
    
    
    LidTightenerL = XR_FACE_EXPRESSION_LID_TIGHTENER_L_FB,
    
    
    LidTightenerR = XR_FACE_EXPRESSION_LID_TIGHTENER_R_FB,
    
    
    LipCornerDepressorL = XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_L_FB,
    
    
    LipCornerDepressorR = XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_R_FB,
    
    
    LipCornerPullerL = XR_FACE_EXPRESSION_LIP_CORNER_PULLER_L_FB,
    
    
    LipCornerPullerR = XR_FACE_EXPRESSION_LIP_CORNER_PULLER_R_FB,
    
    
    LipFunnelerLb = XR_FACE_EXPRESSION_LIP_FUNNELER_LB_FB,
    
    
    LipFunnelerLt = XR_FACE_EXPRESSION_LIP_FUNNELER_LT_FB,
    
    
    LipFunnelerRb = XR_FACE_EXPRESSION_LIP_FUNNELER_RB_FB,
    
    
    LipFunnelerRt = XR_FACE_EXPRESSION_LIP_FUNNELER_RT_FB,
    
    
    LipPressorL = XR_FACE_EXPRESSION_LIP_PRESSOR_L_FB,
    
    
    LipPressorR = XR_FACE_EXPRESSION_LIP_PRESSOR_R_FB,
    
    
    LipPuckerL = XR_FACE_EXPRESSION_LIP_PUCKER_L_FB,
    
    
    LipPuckerR = XR_FACE_EXPRESSION_LIP_PUCKER_R_FB,
    
    
    LipStretcherL = XR_FACE_EXPRESSION_LIP_STRETCHER_L_FB,
    
    
    LipStretcherR = XR_FACE_EXPRESSION_LIP_STRETCHER_R_FB,
    
    
    LipSuckLb = XR_FACE_EXPRESSION_LIP_SUCK_LB_FB,
    
    
    LipSuckLt = XR_FACE_EXPRESSION_LIP_SUCK_LT_FB,
    
    
    LipSuckRb = XR_FACE_EXPRESSION_LIP_SUCK_RB_FB,
    
    
    LipSuckRt = XR_FACE_EXPRESSION_LIP_SUCK_RT_FB,
    
    
    LipTightenerL = XR_FACE_EXPRESSION_LIP_TIGHTENER_L_FB,
    
    
    LipTightenerR = XR_FACE_EXPRESSION_LIP_TIGHTENER_R_FB,
    
    
    LipsToward = XR_FACE_EXPRESSION_LIPS_TOWARD_FB,
    
    
    LowerLipDepressorL = XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_L_FB,
    
    
    LowerLipDepressorR = XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_R_FB,
    
    
    MouthLeft = XR_FACE_EXPRESSION_MOUTH_LEFT_FB,
    
    
    MouthRight = XR_FACE_EXPRESSION_MOUTH_RIGHT_FB,
    
    
    NoseWrinklerL = XR_FACE_EXPRESSION_NOSE_WRINKLER_L_FB,
    
    
    NoseWrinklerR = XR_FACE_EXPRESSION_NOSE_WRINKLER_R_FB,
    
    
    OuterBrowRaiserL = XR_FACE_EXPRESSION_OUTER_BROW_RAISER_L_FB,
    
    
    OuterBrowRaiserR = XR_FACE_EXPRESSION_OUTER_BROW_RAISER_R_FB,
    
    
    UpperLidRaiserL = XR_FACE_EXPRESSION_UPPER_LID_RAISER_L_FB,
    
    
    UpperLidRaiserR = XR_FACE_EXPRESSION_UPPER_LID_RAISER_R_FB,
    
    
    UpperLipRaiserL = XR_FACE_EXPRESSION_UPPER_LIP_RAISER_L_FB,
    
    
    UpperLipRaiserR = XR_FACE_EXPRESSION_UPPER_LIP_RAISER_R_FB,
    
    
    Count = XR_FACE_EXPRESSION_COUNT_FB,
    
};
 static_assert(sizeof(FaceExpressionFB) == sizeof(XrFaceExpressionFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionFB value from a FaceExpressionFB.
 * 
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceExpressionFB get(FaceExpressionFB const& v) {
    return static_cast<XrFaceExpressionFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionFB value as a const char *.
 * 
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FaceExpressionFB value) {
    switch (value) {
            
        case FaceExpressionFB::BrowLowererL:
            return "BrowLowererL";
            
            
        case FaceExpressionFB::BrowLowererR:
            return "BrowLowererR";
            
            
        case FaceExpressionFB::CheekPuffL:
            return "CheekPuffL";
            
            
        case FaceExpressionFB::CheekPuffR:
            return "CheekPuffR";
            
            
        case FaceExpressionFB::CheekRaiserL:
            return "CheekRaiserL";
            
            
        case FaceExpressionFB::CheekRaiserR:
            return "CheekRaiserR";
            
            
        case FaceExpressionFB::CheekSuckL:
            return "CheekSuckL";
            
            
        case FaceExpressionFB::CheekSuckR:
            return "CheekSuckR";
            
            
        case FaceExpressionFB::ChinRaiserB:
            return "ChinRaiserB";
            
            
        case FaceExpressionFB::ChinRaiserT:
            return "ChinRaiserT";
            
            
        case FaceExpressionFB::DimplerL:
            return "DimplerL";
            
            
        case FaceExpressionFB::DimplerR:
            return "DimplerR";
            
            
        case FaceExpressionFB::EyesClosedL:
            return "EyesClosedL";
            
            
        case FaceExpressionFB::EyesClosedR:
            return "EyesClosedR";
            
            
        case FaceExpressionFB::EyesLookDownL:
            return "EyesLookDownL";
            
            
        case FaceExpressionFB::EyesLookDownR:
            return "EyesLookDownR";
            
            
        case FaceExpressionFB::EyesLookLeftL:
            return "EyesLookLeftL";
            
            
        case FaceExpressionFB::EyesLookLeftR:
            return "EyesLookLeftR";
            
            
        case FaceExpressionFB::EyesLookRightL:
            return "EyesLookRightL";
            
            
        case FaceExpressionFB::EyesLookRightR:
            return "EyesLookRightR";
            
            
        case FaceExpressionFB::EyesLookUpL:
            return "EyesLookUpL";
            
            
        case FaceExpressionFB::EyesLookUpR:
            return "EyesLookUpR";
            
            
        case FaceExpressionFB::InnerBrowRaiserL:
            return "InnerBrowRaiserL";
            
            
        case FaceExpressionFB::InnerBrowRaiserR:
            return "InnerBrowRaiserR";
            
            
        case FaceExpressionFB::JawDrop:
            return "JawDrop";
            
            
        case FaceExpressionFB::JawSidewaysLeft:
            return "JawSidewaysLeft";
            
            
        case FaceExpressionFB::JawSidewaysRight:
            return "JawSidewaysRight";
            
            
        case FaceExpressionFB::JawThrust:
            return "JawThrust";
            
            
        case FaceExpressionFB::LidTightenerL:
            return "LidTightenerL";
            
            
        case FaceExpressionFB::LidTightenerR:
            return "LidTightenerR";
            
            
        case FaceExpressionFB::LipCornerDepressorL:
            return "LipCornerDepressorL";
            
            
        case FaceExpressionFB::LipCornerDepressorR:
            return "LipCornerDepressorR";
            
            
        case FaceExpressionFB::LipCornerPullerL:
            return "LipCornerPullerL";
            
            
        case FaceExpressionFB::LipCornerPullerR:
            return "LipCornerPullerR";
            
            
        case FaceExpressionFB::LipFunnelerLb:
            return "LipFunnelerLb";
            
            
        case FaceExpressionFB::LipFunnelerLt:
            return "LipFunnelerLt";
            
            
        case FaceExpressionFB::LipFunnelerRb:
            return "LipFunnelerRb";
            
            
        case FaceExpressionFB::LipFunnelerRt:
            return "LipFunnelerRt";
            
            
        case FaceExpressionFB::LipPressorL:
            return "LipPressorL";
            
            
        case FaceExpressionFB::LipPressorR:
            return "LipPressorR";
            
            
        case FaceExpressionFB::LipPuckerL:
            return "LipPuckerL";
            
            
        case FaceExpressionFB::LipPuckerR:
            return "LipPuckerR";
            
            
        case FaceExpressionFB::LipStretcherL:
            return "LipStretcherL";
            
            
        case FaceExpressionFB::LipStretcherR:
            return "LipStretcherR";
            
            
        case FaceExpressionFB::LipSuckLb:
            return "LipSuckLb";
            
            
        case FaceExpressionFB::LipSuckLt:
            return "LipSuckLt";
            
            
        case FaceExpressionFB::LipSuckRb:
            return "LipSuckRb";
            
            
        case FaceExpressionFB::LipSuckRt:
            return "LipSuckRt";
            
            
        case FaceExpressionFB::LipTightenerL:
            return "LipTightenerL";
            
            
        case FaceExpressionFB::LipTightenerR:
            return "LipTightenerR";
            
            
        case FaceExpressionFB::LipsToward:
            return "LipsToward";
            
            
        case FaceExpressionFB::LowerLipDepressorL:
            return "LowerLipDepressorL";
            
            
        case FaceExpressionFB::LowerLipDepressorR:
            return "LowerLipDepressorR";
            
            
        case FaceExpressionFB::MouthLeft:
            return "MouthLeft";
            
            
        case FaceExpressionFB::MouthRight:
            return "MouthRight";
            
            
        case FaceExpressionFB::NoseWrinklerL:
            return "NoseWrinklerL";
            
            
        case FaceExpressionFB::NoseWrinklerR:
            return "NoseWrinklerR";
            
            
        case FaceExpressionFB::OuterBrowRaiserL:
            return "OuterBrowRaiserL";
            
            
        case FaceExpressionFB::OuterBrowRaiserR:
            return "OuterBrowRaiserR";
            
            
        case FaceExpressionFB::UpperLidRaiserL:
            return "UpperLidRaiserL";
            
            
        case FaceExpressionFB::UpperLidRaiserR:
            return "UpperLidRaiserR";
            
            
        case FaceExpressionFB::UpperLipRaiserL:
            return "UpperLipRaiserL";
            
            
        case FaceExpressionFB::UpperLipRaiserR:
            return "UpperLipRaiserR";
            
            
        case FaceExpressionFB::Count:
            return "Count";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionFB value as a std::string.
 * 
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceExpressionFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking

































#ifdef XR_FB_face_tracking
/*!
 * @brief Enum class for XrFaceExpressionSetFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionSetFB>
 * 
 * @xrentity{XrFaceExpressionSetFB}
 */
enum class FaceExpressionSetFB: int32_t {
    
    Default = XR_FACE_EXPRESSION_SET_DEFAULT_FB,
    
};
 static_assert(sizeof(FaceExpressionSetFB) == sizeof(XrFaceExpressionSetFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionSetFB value from a FaceExpressionSetFB.
 * 
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceExpressionSetFB get(FaceExpressionSetFB const& v) {
    return static_cast<XrFaceExpressionSetFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionSetFB value as a const char *.
 * 
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FaceExpressionSetFB value) {
    switch (value) {
            
        case FaceExpressionSetFB::Default:
            return "Default";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionSetFB value as a std::string.
 * 
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceExpressionSetFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking

































#ifdef XR_FB_face_tracking
/*!
 * @brief Enum class for XrFaceConfidenceFB
 * 
 * Provided by the `XR_FB_face_tracking` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceConfidenceFB>
 * 
 * @xrentity{XrFaceConfidenceFB}
 */
enum class FaceConfidenceFB: int32_t {
    
    LowerFace = XR_FACE_CONFIDENCE_LOWER_FACE_FB,
    
    
    UpperFace = XR_FACE_CONFIDENCE_UPPER_FACE_FB,
    
    
    Count = XR_FACE_CONFIDENCE_COUNT_FB,
    
};
 static_assert(sizeof(FaceConfidenceFB) == sizeof(XrFaceConfidenceFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceConfidenceFB value from a FaceConfidenceFB.
 * 
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceConfidenceFB get(FaceConfidenceFB const& v) {
    return static_cast<XrFaceConfidenceFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceConfidenceFB value as a const char *.
 * 
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FaceConfidenceFB value) {
    switch (value) {
            
        case FaceConfidenceFB::LowerFace:
            return "LowerFace";
            
            
        case FaceConfidenceFB::UpperFace:
            return "UpperFace";
            
            
        case FaceConfidenceFB::Count:
            return "Count";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FaceConfidenceFB value as a std::string.
 * 
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceConfidenceFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking

































#ifdef XR_FB_eye_tracking_social
/*!
 * @brief Enum class for XrEyePositionFB
 * 
 * Provided by the `XR_FB_eye_tracking_social` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyePositionFB>
 * 
 * @xrentity{XrEyePositionFB}
 */
enum class EyePositionFB: int32_t {
    
    Left = XR_EYE_POSITION_LEFT_FB,
    
    
    Right = XR_EYE_POSITION_RIGHT_FB,
    
    
    Count = XR_EYE_POSITION_COUNT_FB,
    
};
 static_assert(sizeof(EyePositionFB) == sizeof(XrEyePositionFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyePositionFB value from a EyePositionFB.
 * 
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyePositionFB get(EyePositionFB const& v) {
    return static_cast<XrEyePositionFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EyePositionFB value as a const char *.
 * 
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyePositionFB value) {
    switch (value) {
            
        case EyePositionFB::Left:
            return "Left";
            
            
        case EyePositionFB::Right:
            return "Right";
            
            
        case EyePositionFB::Count:
            return "Count";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a EyePositionFB value as a std::string.
 * 
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyePositionFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_eye_tracking_social

































#ifdef XR_FB_composition_layer_depth_test
/*!
 * @brief Enum class for XrCompareOpFB
 * 
 * Provided by the `XR_FB_composition_layer_depth_test` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompareOpFB>
 * 
 * @xrentity{XrCompareOpFB}
 */
enum class CompareOpFB: int32_t {
    
    Never = XR_COMPARE_OP_NEVER_FB,
    
    
    Less = XR_COMPARE_OP_LESS_FB,
    
    
    Equal = XR_COMPARE_OP_EQUAL_FB,
    
    
    LessOrEqual = XR_COMPARE_OP_LESS_OR_EQUAL_FB,
    
    
    Greater = XR_COMPARE_OP_GREATER_FB,
    
    
    NotEqual = XR_COMPARE_OP_NOT_EQUAL_FB,
    
    
    GreaterOrEqual = XR_COMPARE_OP_GREATER_OR_EQUAL_FB,
    
    
    Always = XR_COMPARE_OP_ALWAYS_FB,
    
};
 static_assert(sizeof(CompareOpFB) == sizeof(XrCompareOpFB), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrCompareOpFB value from a CompareOpFB.
 * 
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrCompareOpFB get(CompareOpFB const& v) {
    return static_cast<XrCompareOpFB>(v);
}

/*!
 * @brief Free function for retrieving the string name of a CompareOpFB value as a const char *.
 * 
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(CompareOpFB value) {
    switch (value) {
            
        case CompareOpFB::Never:
            return "Never";
            
            
        case CompareOpFB::Less:
            return "Less";
            
            
        case CompareOpFB::Equal:
            return "Equal";
            
            
        case CompareOpFB::LessOrEqual:
            return "LessOrEqual";
            
            
        case CompareOpFB::Greater:
            return "Greater";
            
            
        case CompareOpFB::NotEqual:
            return "NotEqual";
            
            
        case CompareOpFB::GreaterOrEqual:
            return "GreaterOrEqual";
            
            
        case CompareOpFB::Always:
            return "Always";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a CompareOpFB value as a std::string.
 * 
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(CompareOpFB value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_composition_layer_depth_test

































#ifdef XR_META_local_dimming
/*!
 * @brief Enum class for XrLocalDimmingModeMETA
 * 
 * Provided by the `XR_META_local_dimming` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalDimmingModeMETA>
 * 
 * @xrentity{XrLocalDimmingModeMETA}
 */
enum class LocalDimmingModeMETA: int32_t {
    
    Off = XR_LOCAL_DIMMING_MODE_OFF_META,
    
    
    On = XR_LOCAL_DIMMING_MODE_ON_META,
    
};
 static_assert(sizeof(LocalDimmingModeMETA) == sizeof(XrLocalDimmingModeMETA), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalDimmingModeMETA value from a LocalDimmingModeMETA.
 * 
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLocalDimmingModeMETA get(LocalDimmingModeMETA const& v) {
    return static_cast<XrLocalDimmingModeMETA>(v);
}

/*!
 * @brief Free function for retrieving the string name of a LocalDimmingModeMETA value as a const char *.
 * 
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(LocalDimmingModeMETA value) {
    switch (value) {
            
        case LocalDimmingModeMETA::Off:
            return "Off";
            
            
        case LocalDimmingModeMETA::On:
            return "On";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a LocalDimmingModeMETA value as a std::string.
 * 
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LocalDimmingModeMETA value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_local_dimming

































#ifdef XR_META_virtual_keyboard
/*!
 * @brief Enum class for XrVirtualKeyboardLocationTypeMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardLocationTypeMETA>
 * 
 * @xrentity{XrVirtualKeyboardLocationTypeMETA}
 */
enum class VirtualKeyboardLocationTypeMETA: int32_t {
    
    Custom = XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_CUSTOM_META,
    
    
    Far = XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_FAR_META,
    
    
    Direct = XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_DIRECT_META,
    
};
 static_assert(sizeof(VirtualKeyboardLocationTypeMETA) == sizeof(XrVirtualKeyboardLocationTypeMETA), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVirtualKeyboardLocationTypeMETA value from a VirtualKeyboardLocationTypeMETA.
 * 
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVirtualKeyboardLocationTypeMETA get(VirtualKeyboardLocationTypeMETA const& v) {
    return static_cast<XrVirtualKeyboardLocationTypeMETA>(v);
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardLocationTypeMETA value as a const char *.
 * 
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(VirtualKeyboardLocationTypeMETA value) {
    switch (value) {
            
        case VirtualKeyboardLocationTypeMETA::Custom:
            return "Custom";
            
            
        case VirtualKeyboardLocationTypeMETA::Far:
            return "Far";
            
            
        case VirtualKeyboardLocationTypeMETA::Direct:
            return "Direct";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardLocationTypeMETA value as a std::string.
 * 
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(VirtualKeyboardLocationTypeMETA value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_virtual_keyboard

































#ifdef XR_META_virtual_keyboard
/*!
 * @brief Enum class for XrVirtualKeyboardInputSourceMETA
 * 
 * Provided by the `XR_META_virtual_keyboard` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardInputSourceMETA>
 * 
 * @xrentity{XrVirtualKeyboardInputSourceMETA}
 */
enum class VirtualKeyboardInputSourceMETA: int32_t {
    
    ControllerRayLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_LEFT_META,
    
    
    ControllerRayRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_RIGHT_META,
    
    
    HandRayLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_LEFT_META,
    
    
    HandRayRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_RIGHT_META,
    
    
    ControllerDirectLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_LEFT_META,
    
    
    ControllerDirectRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_RIGHT_META,
    
    
    HandDirectIndexTipLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_LEFT_META,
    
    
    HandDirectIndexTipRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_RIGHT_META,
    
};
 static_assert(sizeof(VirtualKeyboardInputSourceMETA) == sizeof(XrVirtualKeyboardInputSourceMETA), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVirtualKeyboardInputSourceMETA value from a VirtualKeyboardInputSourceMETA.
 * 
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVirtualKeyboardInputSourceMETA get(VirtualKeyboardInputSourceMETA const& v) {
    return static_cast<XrVirtualKeyboardInputSourceMETA>(v);
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardInputSourceMETA value as a const char *.
 * 
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(VirtualKeyboardInputSourceMETA value) {
    switch (value) {
            
        case VirtualKeyboardInputSourceMETA::ControllerRayLeft:
            return "ControllerRayLeft";
            
            
        case VirtualKeyboardInputSourceMETA::ControllerRayRight:
            return "ControllerRayRight";
            
            
        case VirtualKeyboardInputSourceMETA::HandRayLeft:
            return "HandRayLeft";
            
            
        case VirtualKeyboardInputSourceMETA::HandRayRight:
            return "HandRayRight";
            
            
        case VirtualKeyboardInputSourceMETA::ControllerDirectLeft:
            return "ControllerDirectLeft";
            
            
        case VirtualKeyboardInputSourceMETA::ControllerDirectRight:
            return "ControllerDirectRight";
            
            
        case VirtualKeyboardInputSourceMETA::HandDirectIndexTipLeft:
            return "HandDirectIndexTipLeft";
            
            
        case VirtualKeyboardInputSourceMETA::HandDirectIndexTipRight:
            return "HandDirectIndexTipRight";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardInputSourceMETA value as a std::string.
 * 
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(VirtualKeyboardInputSourceMETA value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_virtual_keyboard

































#ifdef XR_OCULUS_external_camera
/*!
 * @brief Enum class for XrExternalCameraAttachedToDeviceOCULUS
 * 
 * Provided by the `XR_OCULUS_external_camera` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraAttachedToDeviceOCULUS>
 * 
 * @xrentity{XrExternalCameraAttachedToDeviceOCULUS}
 */
enum class ExternalCameraAttachedToDeviceOCULUS: int32_t {
    
    None = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_NONE_OCULUS,
    
    
    Hmd = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_HMD_OCULUS,
    
    
    Ltouch = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_LTOUCH_OCULUS,
    
    
    Rtouch = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_RTOUCH_OCULUS,
    
};
 static_assert(sizeof(ExternalCameraAttachedToDeviceOCULUS) == sizeof(XrExternalCameraAttachedToDeviceOCULUS), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrExternalCameraAttachedToDeviceOCULUS value from a ExternalCameraAttachedToDeviceOCULUS.
 * 
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrExternalCameraAttachedToDeviceOCULUS get(ExternalCameraAttachedToDeviceOCULUS const& v) {
    return static_cast<XrExternalCameraAttachedToDeviceOCULUS>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ExternalCameraAttachedToDeviceOCULUS value as a const char *.
 * 
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ExternalCameraAttachedToDeviceOCULUS value) {
    switch (value) {
            
        case ExternalCameraAttachedToDeviceOCULUS::None:
            return "None";
            
            
        case ExternalCameraAttachedToDeviceOCULUS::Hmd:
            return "Hmd";
            
            
        case ExternalCameraAttachedToDeviceOCULUS::Ltouch:
            return "Ltouch";
            
            
        case ExternalCameraAttachedToDeviceOCULUS::Rtouch:
            return "Rtouch";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ExternalCameraAttachedToDeviceOCULUS value as a std::string.
 * 
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ExternalCameraAttachedToDeviceOCULUS value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_OCULUS_external_camera

































#ifdef XR_META_performance_metrics
/*!
 * @brief Enum class for XrPerformanceMetricsCounterUnitMETA
 * 
 * Provided by the `XR_META_performance_metrics` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerformanceMetricsCounterUnitMETA>
 * 
 * @xrentity{XrPerformanceMetricsCounterUnitMETA}
 */
enum class PerformanceMetricsCounterUnitMETA: int32_t {
    
    Generic = XR_PERFORMANCE_METRICS_COUNTER_UNIT_GENERIC_META,
    
    
    Percentage = XR_PERFORMANCE_METRICS_COUNTER_UNIT_PERCENTAGE_META,
    
    
    Milliseconds = XR_PERFORMANCE_METRICS_COUNTER_UNIT_MILLISECONDS_META,
    
    
    Bytes = XR_PERFORMANCE_METRICS_COUNTER_UNIT_BYTES_META,
    
    
    Hertz = XR_PERFORMANCE_METRICS_COUNTER_UNIT_HERTZ_META,
    
};
 static_assert(sizeof(PerformanceMetricsCounterUnitMETA) == sizeof(XrPerformanceMetricsCounterUnitMETA), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerformanceMetricsCounterUnitMETA value from a PerformanceMetricsCounterUnitMETA.
 * 
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerformanceMetricsCounterUnitMETA get(PerformanceMetricsCounterUnitMETA const& v) {
    return static_cast<XrPerformanceMetricsCounterUnitMETA>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PerformanceMetricsCounterUnitMETA value as a const char *.
 * 
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PerformanceMetricsCounterUnitMETA value) {
    switch (value) {
            
        case PerformanceMetricsCounterUnitMETA::Generic:
            return "Generic";
            
            
        case PerformanceMetricsCounterUnitMETA::Percentage:
            return "Percentage";
            
            
        case PerformanceMetricsCounterUnitMETA::Milliseconds:
            return "Milliseconds";
            
            
        case PerformanceMetricsCounterUnitMETA::Bytes:
            return "Bytes";
            
            
        case PerformanceMetricsCounterUnitMETA::Hertz:
            return "Hertz";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PerformanceMetricsCounterUnitMETA value as a std::string.
 * 
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerformanceMetricsCounterUnitMETA value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_performance_metrics

































#ifdef XR_META_passthrough_color_lut
/*!
 * @brief Enum class for XrPassthroughColorLutChannelsMETA
 * 
 * Provided by the `XR_META_passthrough_color_lut` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutChannelsMETA>
 * 
 * @xrentity{XrPassthroughColorLutChannelsMETA}
 */
enum class PassthroughColorLutChannelsMETA: int32_t {
    
    RGB = XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGB_META,
    
    
    Rgba = XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGBA_META,
    
};
 static_assert(sizeof(PassthroughColorLutChannelsMETA) == sizeof(XrPassthroughColorLutChannelsMETA), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughColorLutChannelsMETA value from a PassthroughColorLutChannelsMETA.
 * 
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughColorLutChannelsMETA get(PassthroughColorLutChannelsMETA const& v) {
    return static_cast<XrPassthroughColorLutChannelsMETA>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughColorLutChannelsMETA value as a const char *.
 * 
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PassthroughColorLutChannelsMETA value) {
    switch (value) {
            
        case PassthroughColorLutChannelsMETA::RGB:
            return "RGB";
            
            
        case PassthroughColorLutChannelsMETA::Rgba:
            return "Rgba";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughColorLutChannelsMETA value as a std::string.
 * 
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PassthroughColorLutChannelsMETA value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_passthrough_color_lut

































#ifdef XR_QCOM_tracking_optimization_settings
/*!
 * @brief Enum class for XrTrackingOptimizationSettingsDomainQCOM
 * 
 * Provided by the `XR_QCOM_tracking_optimization_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTrackingOptimizationSettingsDomainQCOM>
 * 
 * @xrentity{XrTrackingOptimizationSettingsDomainQCOM}
 */
enum class TrackingOptimizationSettingsDomainQCOM: int32_t {
    
    All = XR_TRACKING_OPTIMIZATION_SETTINGS_DOMAIN_ALL_QCOM,
    
};
 static_assert(sizeof(TrackingOptimizationSettingsDomainQCOM) == sizeof(XrTrackingOptimizationSettingsDomainQCOM), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrTrackingOptimizationSettingsDomainQCOM value from a TrackingOptimizationSettingsDomainQCOM.
 * 
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrTrackingOptimizationSettingsDomainQCOM get(TrackingOptimizationSettingsDomainQCOM const& v) {
    return static_cast<XrTrackingOptimizationSettingsDomainQCOM>(v);
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsDomainQCOM value as a const char *.
 * 
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(TrackingOptimizationSettingsDomainQCOM value) {
    switch (value) {
            
        case TrackingOptimizationSettingsDomainQCOM::All:
            return "All";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsDomainQCOM value as a std::string.
 * 
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(TrackingOptimizationSettingsDomainQCOM value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_QCOM_tracking_optimization_settings

































#ifdef XR_QCOM_tracking_optimization_settings
/*!
 * @brief Enum class for XrTrackingOptimizationSettingsHintQCOM
 * 
 * Provided by the `XR_QCOM_tracking_optimization_settings` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTrackingOptimizationSettingsHintQCOM>
 * 
 * @xrentity{XrTrackingOptimizationSettingsHintQCOM}
 */
enum class TrackingOptimizationSettingsHintQCOM: int32_t {
    
    None = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_NONE_QCOM,
    
    
    LongRangePriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LONG_RANGE_PRIORIZATION_QCOM,
    
    
    CloseRangePriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_CLOSE_RANGE_PRIORIZATION_QCOM,
    
    
    LowPowerPriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LOW_POWER_PRIORIZATION_QCOM,
    
    
    HighPowerPriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_HIGH_POWER_PRIORIZATION_QCOM,
    
};
 static_assert(sizeof(TrackingOptimizationSettingsHintQCOM) == sizeof(XrTrackingOptimizationSettingsHintQCOM), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrTrackingOptimizationSettingsHintQCOM value from a TrackingOptimizationSettingsHintQCOM.
 * 
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrTrackingOptimizationSettingsHintQCOM get(TrackingOptimizationSettingsHintQCOM const& v) {
    return static_cast<XrTrackingOptimizationSettingsHintQCOM>(v);
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsHintQCOM value as a const char *.
 * 
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(TrackingOptimizationSettingsHintQCOM value) {
    switch (value) {
            
        case TrackingOptimizationSettingsHintQCOM::None:
            return "None";
            
            
        case TrackingOptimizationSettingsHintQCOM::LongRangePriorization:
            return "LongRangePriorization";
            
            
        case TrackingOptimizationSettingsHintQCOM::CloseRangePriorization:
            return "CloseRangePriorization";
            
            
        case TrackingOptimizationSettingsHintQCOM::LowPowerPriorization:
            return "LowPowerPriorization";
            
            
        case TrackingOptimizationSettingsHintQCOM::HighPowerPriorization:
            return "HighPowerPriorization";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsHintQCOM value as a std::string.
 * 
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(TrackingOptimizationSettingsHintQCOM value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_QCOM_tracking_optimization_settings

































#ifdef XR_HTC_passthrough
/*!
 * @brief Enum class for XrPassthroughFormHTC
 * 
 * Provided by the `XR_HTC_passthrough` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughFormHTC>
 * 
 * @xrentity{XrPassthroughFormHTC}
 */
enum class PassthroughFormHTC: int32_t {
    
    Planar = XR_PASSTHROUGH_FORM_PLANAR_HTC,
    
    
    Projected = XR_PASSTHROUGH_FORM_PROJECTED_HTC,
    
};
 static_assert(sizeof(PassthroughFormHTC) == sizeof(XrPassthroughFormHTC), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughFormHTC value from a PassthroughFormHTC.
 * 
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughFormHTC get(PassthroughFormHTC const& v) {
    return static_cast<XrPassthroughFormHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughFormHTC value as a const char *.
 * 
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PassthroughFormHTC value) {
    switch (value) {
            
        case PassthroughFormHTC::Planar:
            return "Planar";
            
            
        case PassthroughFormHTC::Projected:
            return "Projected";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughFormHTC value as a std::string.
 * 
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PassthroughFormHTC value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_passthrough

































#ifdef XR_HTC_foveation
/*!
 * @brief Enum class for XrFoveationModeHTC
 * 
 * Provided by the `XR_HTC_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationModeHTC>
 * 
 * @xrentity{XrFoveationModeHTC}
 */
enum class FoveationModeHTC: int32_t {
    
    Disable = XR_FOVEATION_MODE_DISABLE_HTC,
    
    
    Fixed = XR_FOVEATION_MODE_FIXED_HTC,
    
    
    Dynamic = XR_FOVEATION_MODE_DYNAMIC_HTC,
    
    
    Custom = XR_FOVEATION_MODE_CUSTOM_HTC,
    
};
 static_assert(sizeof(FoveationModeHTC) == sizeof(XrFoveationModeHTC), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationModeHTC value from a FoveationModeHTC.
 * 
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationModeHTC get(FoveationModeHTC const& v) {
    return static_cast<XrFoveationModeHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationModeHTC value as a const char *.
 * 
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FoveationModeHTC value) {
    switch (value) {
            
        case FoveationModeHTC::Disable:
            return "Disable";
            
            
        case FoveationModeHTC::Fixed:
            return "Fixed";
            
            
        case FoveationModeHTC::Dynamic:
            return "Dynamic";
            
            
        case FoveationModeHTC::Custom:
            return "Custom";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationModeHTC value as a std::string.
 * 
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationModeHTC value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_foveation

































#ifdef XR_HTC_foveation
/*!
 * @brief Enum class for XrFoveationLevelHTC
 * 
 * Provided by the `XR_HTC_foveation` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelHTC>
 * 
 * @xrentity{XrFoveationLevelHTC}
 */
enum class FoveationLevelHTC: int32_t {
    
    None = XR_FOVEATION_LEVEL_NONE_HTC,
    
    
    Low = XR_FOVEATION_LEVEL_LOW_HTC,
    
    
    Medium = XR_FOVEATION_LEVEL_MEDIUM_HTC,
    
    
    High = XR_FOVEATION_LEVEL_HIGH_HTC,
    
};
 static_assert(sizeof(FoveationLevelHTC) == sizeof(XrFoveationLevelHTC), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelHTC value from a FoveationLevelHTC.
 * 
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationLevelHTC get(FoveationLevelHTC const& v) {
    return static_cast<XrFoveationLevelHTC>(v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelHTC value as a const char *.
 * 
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FoveationLevelHTC value) {
    switch (value) {
            
        case FoveationLevelHTC::None:
            return "None";
            
            
        case FoveationLevelHTC::Low:
            return "Low";
            
            
        case FoveationLevelHTC::Medium:
            return "Medium";
            
            
        case FoveationLevelHTC::High:
            return "High";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelHTC value as a std::string.
 * 
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationLevelHTC value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_foveation

































#ifdef XR_MNDX_force_feedback_curl
/*!
 * @brief Enum class for XrForceFeedbackCurlLocationMNDX
 * 
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrForceFeedbackCurlLocationMNDX>
 * 
 * @xrentity{XrForceFeedbackCurlLocationMNDX}
 */
enum class ForceFeedbackCurlLocationMNDX: int32_t {
    
    ThumbCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_THUMB_CURL_MNDX,
    
    
    IndexCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_INDEX_CURL_MNDX,
    
    
    MiddleCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_MIDDLE_CURL_MNDX,
    
    
    RingCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_RING_CURL_MNDX,
    
    
    LittleCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_LITTLE_CURL_MNDX,
    
};
 static_assert(sizeof(ForceFeedbackCurlLocationMNDX) == sizeof(XrForceFeedbackCurlLocationMNDX), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrForceFeedbackCurlLocationMNDX value from a ForceFeedbackCurlLocationMNDX.
 * 
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrForceFeedbackCurlLocationMNDX get(ForceFeedbackCurlLocationMNDX const& v) {
    return static_cast<XrForceFeedbackCurlLocationMNDX>(v);
}

/*!
 * @brief Free function for retrieving the string name of a ForceFeedbackCurlLocationMNDX value as a const char *.
 * 
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ForceFeedbackCurlLocationMNDX value) {
    switch (value) {
            
        case ForceFeedbackCurlLocationMNDX::ThumbCurl:
            return "ThumbCurl";
            
            
        case ForceFeedbackCurlLocationMNDX::IndexCurl:
            return "IndexCurl";
            
            
        case ForceFeedbackCurlLocationMNDX::MiddleCurl:
            return "MiddleCurl";
            
            
        case ForceFeedbackCurlLocationMNDX::RingCurl:
            return "RingCurl";
            
            
        case ForceFeedbackCurlLocationMNDX::LittleCurl:
            return "LittleCurl";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a ForceFeedbackCurlLocationMNDX value as a std::string.
 * 
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ForceFeedbackCurlLocationMNDX value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_MNDX_force_feedback_curl

































#ifdef XR_EXT_hand_tracking_data_source
/*!
 * @brief Enum class for XrHandTrackingDataSourceEXT
 * 
 * Provided by the `XR_EXT_hand_tracking_data_source` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingDataSourceEXT>
 * 
 * @xrentity{XrHandTrackingDataSourceEXT}
 */
enum class HandTrackingDataSourceEXT: int32_t {
    
    Unobstructed = XR_HAND_TRACKING_DATA_SOURCE_UNOBSTRUCTED_EXT,
    
    
    Controller = XR_HAND_TRACKING_DATA_SOURCE_CONTROLLER_EXT,
    
};
 static_assert(sizeof(HandTrackingDataSourceEXT) == sizeof(XrHandTrackingDataSourceEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandTrackingDataSourceEXT value from a HandTrackingDataSourceEXT.
 * 
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandTrackingDataSourceEXT get(HandTrackingDataSourceEXT const& v) {
    return static_cast<XrHandTrackingDataSourceEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HandTrackingDataSourceEXT value as a const char *.
 * 
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandTrackingDataSourceEXT value) {
    switch (value) {
            
        case HandTrackingDataSourceEXT::Unobstructed:
            return "Unobstructed";
            
            
        case HandTrackingDataSourceEXT::Controller:
            return "Controller";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HandTrackingDataSourceEXT value as a std::string.
 * 
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandTrackingDataSourceEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking_data_source

































#ifdef XR_EXT_plane_detection
/*!
 * @brief Enum class for XrPlaneDetectorOrientationEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorOrientationEXT>
 * 
 * @xrentity{XrPlaneDetectorOrientationEXT}
 */
enum class PlaneDetectorOrientationEXT: int32_t {
    
    HorizontalUpward = XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_UPWARD_EXT,
    
    
    HorizontalDownward = XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_DOWNWARD_EXT,
    
    
    Vertical = XR_PLANE_DETECTOR_ORIENTATION_VERTICAL_EXT,
    
    
    Arbitrary = XR_PLANE_DETECTOR_ORIENTATION_ARBITRARY_EXT,
    
};
 static_assert(sizeof(PlaneDetectorOrientationEXT) == sizeof(XrPlaneDetectorOrientationEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectorOrientationEXT value from a PlaneDetectorOrientationEXT.
 * 
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneDetectorOrientationEXT get(PlaneDetectorOrientationEXT const& v) {
    return static_cast<XrPlaneDetectorOrientationEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorOrientationEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PlaneDetectorOrientationEXT value) {
    switch (value) {
            
        case PlaneDetectorOrientationEXT::HorizontalUpward:
            return "HorizontalUpward";
            
            
        case PlaneDetectorOrientationEXT::HorizontalDownward:
            return "HorizontalDownward";
            
            
        case PlaneDetectorOrientationEXT::Vertical:
            return "Vertical";
            
            
        case PlaneDetectorOrientationEXT::Arbitrary:
            return "Arbitrary";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorOrientationEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PlaneDetectorOrientationEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_plane_detection

































#ifdef XR_EXT_plane_detection
/*!
 * @brief Enum class for XrPlaneDetectorSemanticTypeEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorSemanticTypeEXT>
 * 
 * @xrentity{XrPlaneDetectorSemanticTypeEXT}
 */
enum class PlaneDetectorSemanticTypeEXT: int32_t {
    
    Undefined = XR_PLANE_DETECTOR_SEMANTIC_TYPE_UNDEFINED_EXT,
    
    
    Ceiling = XR_PLANE_DETECTOR_SEMANTIC_TYPE_CEILING_EXT,
    
    
    Floor = XR_PLANE_DETECTOR_SEMANTIC_TYPE_FLOOR_EXT,
    
    
    Wall = XR_PLANE_DETECTOR_SEMANTIC_TYPE_WALL_EXT,
    
    
    Platform = XR_PLANE_DETECTOR_SEMANTIC_TYPE_PLATFORM_EXT,
    
};
 static_assert(sizeof(PlaneDetectorSemanticTypeEXT) == sizeof(XrPlaneDetectorSemanticTypeEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectorSemanticTypeEXT value from a PlaneDetectorSemanticTypeEXT.
 * 
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneDetectorSemanticTypeEXT get(PlaneDetectorSemanticTypeEXT const& v) {
    return static_cast<XrPlaneDetectorSemanticTypeEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorSemanticTypeEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PlaneDetectorSemanticTypeEXT value) {
    switch (value) {
            
        case PlaneDetectorSemanticTypeEXT::Undefined:
            return "Undefined";
            
            
        case PlaneDetectorSemanticTypeEXT::Ceiling:
            return "Ceiling";
            
            
        case PlaneDetectorSemanticTypeEXT::Floor:
            return "Floor";
            
            
        case PlaneDetectorSemanticTypeEXT::Wall:
            return "Wall";
            
            
        case PlaneDetectorSemanticTypeEXT::Platform:
            return "Platform";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorSemanticTypeEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PlaneDetectorSemanticTypeEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_plane_detection

































#ifdef XR_EXT_plane_detection
/*!
 * @brief Enum class for XrPlaneDetectionStateEXT
 * 
 * Provided by the `XR_EXT_plane_detection` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectionStateEXT>
 * 
 * @xrentity{XrPlaneDetectionStateEXT}
 */
enum class PlaneDetectionStateEXT: int32_t {
    
    None = XR_PLANE_DETECTION_STATE_NONE_EXT,
    
    
    Pending = XR_PLANE_DETECTION_STATE_PENDING_EXT,
    
    
    Done = XR_PLANE_DETECTION_STATE_DONE_EXT,
    
    
    Error = XR_PLANE_DETECTION_STATE_ERROR_EXT,
    
    
    Fatal = XR_PLANE_DETECTION_STATE_FATAL_EXT,
    
};
 static_assert(sizeof(PlaneDetectionStateEXT) == sizeof(XrPlaneDetectionStateEXT), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectionStateEXT value from a PlaneDetectionStateEXT.
 * 
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneDetectionStateEXT get(PlaneDetectionStateEXT const& v) {
    return static_cast<XrPlaneDetectionStateEXT>(v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectionStateEXT value as a const char *.
 * 
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(PlaneDetectionStateEXT value) {
    switch (value) {
            
        case PlaneDetectionStateEXT::None:
            return "None";
            
            
        case PlaneDetectionStateEXT::Pending:
            return "Pending";
            
            
        case PlaneDetectionStateEXT::Done:
            return "Done";
            
            
        case PlaneDetectionStateEXT::Error:
            return "Error";
            
            
        case PlaneDetectionStateEXT::Fatal:
            return "Fatal";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectionStateEXT value as a std::string.
 * 
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PlaneDetectionStateEXT value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_plane_detection

































#ifdef XR_ML_user_calibration
/*!
 * @brief Enum class for XrHeadsetFitStatusML
 * 
 * Provided by the `XR_ML_user_calibration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHeadsetFitStatusML>
 * 
 * @xrentity{XrHeadsetFitStatusML}
 */
enum class HeadsetFitStatusML: int32_t {
    
    Unknown = XR_HEADSET_FIT_STATUS_UNKNOWN_ML,
    
    
    NotWorn = XR_HEADSET_FIT_STATUS_NOT_WORN_ML,
    
    
    GoodFit = XR_HEADSET_FIT_STATUS_GOOD_FIT_ML,
    
    
    BadFit = XR_HEADSET_FIT_STATUS_BAD_FIT_ML,
    
};
 static_assert(sizeof(HeadsetFitStatusML) == sizeof(XrHeadsetFitStatusML), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHeadsetFitStatusML value from a HeadsetFitStatusML.
 * 
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHeadsetFitStatusML get(HeadsetFitStatusML const& v) {
    return static_cast<XrHeadsetFitStatusML>(v);
}

/*!
 * @brief Free function for retrieving the string name of a HeadsetFitStatusML value as a const char *.
 * 
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HeadsetFitStatusML value) {
    switch (value) {
            
        case HeadsetFitStatusML::Unknown:
            return "Unknown";
            
            
        case HeadsetFitStatusML::NotWorn:
            return "NotWorn";
            
            
        case HeadsetFitStatusML::GoodFit:
            return "GoodFit";
            
            
        case HeadsetFitStatusML::BadFit:
            return "BadFit";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a HeadsetFitStatusML value as a std::string.
 * 
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HeadsetFitStatusML value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_user_calibration

































#ifdef XR_ML_user_calibration
/*!
 * @brief Enum class for XrEyeCalibrationStatusML
 * 
 * Provided by the `XR_ML_user_calibration` extension.
 * 
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeCalibrationStatusML>
 * 
 * @xrentity{XrEyeCalibrationStatusML}
 */
enum class EyeCalibrationStatusML: int32_t {
    
    Unknown = XR_EYE_CALIBRATION_STATUS_UNKNOWN_ML,
    
    
    None = XR_EYE_CALIBRATION_STATUS_NONE_ML,
    
    
    Coarse = XR_EYE_CALIBRATION_STATUS_COARSE_ML,
    
    
    Fine = XR_EYE_CALIBRATION_STATUS_FINE_ML,
    
};
 static_assert(sizeof(EyeCalibrationStatusML) == sizeof(XrEyeCalibrationStatusML), "Original type and wrapper have different size!"); 

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeCalibrationStatusML value from a EyeCalibrationStatusML.
 * 
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeCalibrationStatusML get(EyeCalibrationStatusML const& v) {
    return static_cast<XrEyeCalibrationStatusML>(v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeCalibrationStatusML value as a const char *.
 * 
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyeCalibrationStatusML value) {
    switch (value) {
            
        case EyeCalibrationStatusML::Unknown:
            return "Unknown";
            
            
        case EyeCalibrationStatusML::None:
            return "None";
            
            
        case EyeCalibrationStatusML::Coarse:
            return "Coarse";
            
            
        case EyeCalibrationStatusML::Fine:
            return "Fine";
            
        default:
            return "invalid";
    }
}

/*!
 * @brief Free function for retrieving the string name of a EyeCalibrationStatusML value as a std::string.
 * 
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeCalibrationStatusML value) {
    return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_user_calibration
//! @}

}  // namespace OPENXR_HPP_NAMESPACE
































#endif  // ifndef OPENXR_ENUMS_HPP_

