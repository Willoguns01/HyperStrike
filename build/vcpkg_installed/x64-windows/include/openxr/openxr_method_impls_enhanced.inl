// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************
































/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_METHOD_IMPLS_ENHANCED_INL_
#define OPENXR_METHOD_IMPLS_ENHANCED_INL_
/*!
 * @file
 * @brief Inline implementations - include @ref openxr_method_impls.hpp instead!
 *
 * Contains inline implementations of "enhanced mode" method wrappers whose signature is the same whether or not exceptions are permitted.
 */


#ifdef OPENXR_HPP_DOXYGEN































#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#include "openxr_handles.hpp"
#endif

#ifndef OPENXR_HANDLES_HPP_
#error "This is not meant to be included on its own."
#endif

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE

namespace OPENXR_HPP_NAMESPACE {





































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::getInstanceProcAddr (
    const char* name, PFN_xrVoidFunction* function, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetInstanceProcAddr(this->get(), name, function) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector (
    Dispatch&& d)  {
    std::vector<ApiLayerProperties, Allocator> properties;
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(properties) };
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrApiLayerProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(properties) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector (
    Allocator const& vectorAllocator, Dispatch&& d)  {
    std::vector<ApiLayerProperties, Allocator> properties{vectorAllocator};
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(properties) };
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateApiLayerProperties(propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrApiLayerProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(properties) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ExtensionProperties, Allocator>> enumerateInstanceExtensionPropertiesToVector (
    const char* layerName, Dispatch&& d)  {
    std::vector<ExtensionProperties, Allocator> properties;
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(properties) };
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrExtensionProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(properties) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ExtensionProperties, Allocator>> enumerateInstanceExtensionPropertiesToVector (
    const char* layerName, Allocator const& vectorAllocator, Dispatch&& d)  {
    std::vector<ExtensionProperties, Allocator> properties{vectorAllocator};
        uint32_t propertyCountOutput = 0;
    uint32_t propertyCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || propertyCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(properties) };
    }
    do {
        properties.resize(propertyCountOutput);
        propertyCapacityInput = static_cast<uint32_t>(properties.size());
        result = static_cast<Result>( d.xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, &propertyCountOutput, reinterpret_cast<XrExtensionProperties*>(properties.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(propertyCountOutput <= properties.size());
        properties.resize(propertyCountOutput);
    } else properties.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(properties) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Instance> createInstance (
    const InstanceCreateInfo& createInfo, Dispatch&& d)  {
    Instance handle;
    Result result = static_cast<Result>( d.xrCreateInstance(createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>> createInstanceUnique (
    const InstanceCreateInfo& createInfo, Dispatch&& d)  {
    Instance handle;
    Result result = static_cast<Result>( d.xrCreateInstance(createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyInstance(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<InstanceProperties> Instance::getInstanceProperties (
    Dispatch&& d) const {
    InstanceProperties instanceProperties;
    Result result = static_cast<Result>( d.xrGetInstanceProperties(this->get(), OPENXR_HPP_NAMESPACE::put(instanceProperties)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(instanceProperties) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::pollEvent (
    EventDataBuffer& eventData, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPollEvent(this->get(), eventData.put()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Instance::pollEvent");
    }
#endif



    return result;
}







#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::resultToString (
    Result value, char buffer[XR_MAX_RESULT_STRING_SIZE], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrResultToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS






#ifdef OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::structureTypeToString (
    StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrStructureTypeToString(this->get(), OPENXR_HPP_NAMESPACE::get(value), buffer) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  //  OPENXR_HPP_PROVIDE_DISCOURAGED_FUNCTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SystemId> Instance::getSystem (
    const SystemGetInfo& getInfo, Dispatch&& d) const {
    SystemId systemId;
    Result result = static_cast<Result>( d.xrGetSystem(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(systemId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(systemId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SystemProperties> Instance::getSystemProperties (
    SystemId systemId, Dispatch&& d) const {
    SystemProperties properties;
    Result result = static_cast<Result>( d.xrGetSystemProperties(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(properties)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(properties) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<EnvironmentBlendMode, Allocator>> Instance::enumerateEnvironmentBlendModesToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes;
        uint32_t environmentBlendModeCountOutput = 0;
    uint32_t environmentBlendModeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(environmentBlendModes) };
    }
    do {
        environmentBlendModes.resize(environmentBlendModeCountOutput);
        environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
        result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
        environmentBlendModes.resize(environmentBlendModeCountOutput);
    } else environmentBlendModes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(environmentBlendModes) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<EnvironmentBlendMode, Allocator>> Instance::enumerateEnvironmentBlendModesToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<EnvironmentBlendMode, Allocator> environmentBlendModes{vectorAllocator};
        uint32_t environmentBlendModeCountOutput = 0;
    uint32_t environmentBlendModeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || environmentBlendModeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(environmentBlendModes) };
    }
    do {
        environmentBlendModes.resize(environmentBlendModeCountOutput);
        environmentBlendModeCapacityInput = static_cast<uint32_t>(environmentBlendModes.size());
        result = static_cast<Result>( d.xrEnumerateEnvironmentBlendModes(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), environmentBlendModeCapacityInput, &environmentBlendModeCountOutput, reinterpret_cast<XrEnvironmentBlendMode*>(environmentBlendModes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(environmentBlendModeCountOutput <= environmentBlendModes.size());
        environmentBlendModes.resize(environmentBlendModeCountOutput);
    } else environmentBlendModes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(environmentBlendModes) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Session> Instance::createSession (
    const SessionCreateInfo& createInfo, Dispatch&& d) const {
    Session handle;
    Result result = static_cast<Result>( d.xrCreateSession(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>> Instance::createSessionUnique (
    const SessionCreateInfo& createInfo, Dispatch&& d) const {
    Session handle;
    Result result = static_cast<Result>( d.xrCreateSession(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySession(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReferenceSpaceType, Allocator>> Session::enumerateReferenceSpacesToVector (
    Dispatch&& d) const {
    std::vector<ReferenceSpaceType, Allocator> spaces;
        uint32_t spaceCountOutput = 0;
    uint32_t spaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(spaces) };
    }
    do {
        spaces.resize(spaceCountOutput);
        spaceCapacityInput = static_cast<uint32_t>(spaces.size());
        result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, reinterpret_cast<XrReferenceSpaceType*>(spaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
        spaces.resize(spaceCountOutput);
    } else spaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(spaces) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReferenceSpaceType, Allocator>> Session::enumerateReferenceSpacesToVector (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ReferenceSpaceType, Allocator> spaces{vectorAllocator};
        uint32_t spaceCountOutput = 0;
    uint32_t spaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || spaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(spaces) };
    }
    do {
        spaces.resize(spaceCountOutput);
        spaceCapacityInput = static_cast<uint32_t>(spaces.size());
        result = static_cast<Result>( d.xrEnumerateReferenceSpaces(this->get(), spaceCapacityInput, &spaceCountOutput, reinterpret_cast<XrReferenceSpaceType*>(spaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(spaceCountOutput <= spaces.size());
        spaces.resize(spaceCountOutput);
    } else spaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(spaces) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createReferenceSpace (
    const ReferenceSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createReferenceSpaceUnique (
    const ReferenceSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateReferenceSpace(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::getReferenceSpaceBoundsRect (
    ReferenceSpaceType referenceSpaceType, Extent2Df& bounds, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetReferenceSpaceBoundsRect(this->get(), OPENXR_HPP_NAMESPACE::get(referenceSpaceType), bounds.put()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getReferenceSpaceBoundsRect");
    }
#endif



    return result;
}







































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createActionSpace (
    const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createActionSpaceUnique (
    const ActionSpaceCreateInfo& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateActionSpace(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceLocation> Space::locateSpace (
    Space baseSpace, Time time, Dispatch&& d) const {
    SpaceLocation location;
    Result result = static_cast<Result>( d.xrLocateSpace(this->get(), baseSpace.get(), time.get(), OPENXR_HPP_NAMESPACE::put(location)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(location) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Space::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySpace(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationType, Allocator>> Instance::enumerateViewConfigurationsToVector (
    SystemId systemId, Dispatch&& d) const {
    std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes;
        uint32_t viewConfigurationTypeCountOutput = 0;
    uint32_t viewConfigurationTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(viewConfigurationTypes) };
    }
    do {
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
        viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    } else viewConfigurationTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(viewConfigurationTypes) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationType, Allocator>> Instance::enumerateViewConfigurationsToVector (
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ViewConfigurationType, Allocator> viewConfigurationTypes{vectorAllocator};
        uint32_t viewConfigurationTypeCountOutput = 0;
    uint32_t viewConfigurationTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewConfigurationTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(viewConfigurationTypes) };
    }
    do {
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
        viewConfigurationTypeCapacityInput = static_cast<uint32_t>(viewConfigurationTypes.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurations(this->get(), systemId.get(), viewConfigurationTypeCapacityInput, &viewConfigurationTypeCountOutput, reinterpret_cast<XrViewConfigurationType*>(viewConfigurationTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewConfigurationTypeCountOutput <= viewConfigurationTypes.size());
        viewConfigurationTypes.resize(viewConfigurationTypeCountOutput);
    } else viewConfigurationTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(viewConfigurationTypes) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ViewConfigurationProperties> Instance::getViewConfigurationProperties (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    ViewConfigurationProperties configurationProperties;
    Result result = static_cast<Result>( d.xrGetViewConfigurationProperties(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), OPENXR_HPP_NAMESPACE::put(configurationProperties)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(configurationProperties) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationView, Allocator>> Instance::enumerateViewConfigurationViewsToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    std::vector<ViewConfigurationView, Allocator> views;
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(views) };
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, reinterpret_cast<XrViewConfigurationView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(views) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViewConfigurationView, Allocator>> Instance::enumerateViewConfigurationViewsToVector (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ViewConfigurationView, Allocator> views{vectorAllocator};
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(views) };
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrEnumerateViewConfigurationViews(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewCapacityInput, &viewCountOutput, reinterpret_cast<XrViewConfigurationView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(views) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<int64_t, Allocator>> Session::enumerateSwapchainFormatsToVector (
    Dispatch&& d) const {
    std::vector<int64_t, Allocator> formats;
        uint32_t formatCountOutput = 0;
    uint32_t formatCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(formats) };
    }
    do {
        formats.resize(formatCountOutput);
        formatCapacityInput = static_cast<uint32_t>(formats.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, reinterpret_cast<int64_t*>(formats.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
        formats.resize(formatCountOutput);
    } else formats.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(formats) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<int64_t, Allocator>> Session::enumerateSwapchainFormatsToVector (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<int64_t, Allocator> formats{vectorAllocator};
        uint32_t formatCountOutput = 0;
    uint32_t formatCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || formatCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(formats) };
    }
    do {
        formats.resize(formatCountOutput);
        formatCapacityInput = static_cast<uint32_t>(formats.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainFormats(this->get(), formatCapacityInput, &formatCountOutput, reinterpret_cast<int64_t*>(formats.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(formatCountOutput <= formats.size());
        formats.resize(formatCountOutput);
    } else formats.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(formats) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Swapchain> Session::createSwapchain (
    const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>> Session::createSwapchainUnique (
    const SwapchainCreateInfo& createInfo, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchain(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySwapchain(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename ResultItemType, typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ResultItemType, Allocator>> Swapchain::enumerateSwapchainImagesToVector (
    Dispatch&& d) const {
    std::vector<ResultItemType, Allocator> images;
        uint32_t imageCountOutput = 0;
    uint32_t imageCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(images) };
    }
    do {
        images.resize(imageCountOutput);
        imageCapacityInput = static_cast<uint32_t>(images.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
        images.resize(imageCountOutput);
    } else images.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(images) };

}

template <typename ResultItemType, typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ResultItemType, Allocator>> Swapchain::enumerateSwapchainImagesToVector (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ResultItemType, Allocator> images{vectorAllocator};
        uint32_t imageCountOutput = 0;
    uint32_t imageCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || imageCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(images) };
    }
    do {
        images.resize(imageCountOutput);
        imageCapacityInput = static_cast<uint32_t>(images.size());
        result = static_cast<Result>( d.xrEnumerateSwapchainImages(this->get(), imageCapacityInput, &imageCountOutput, reinterpret_cast<XrSwapchainImageBaseHeader*>(images.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(imageCountOutput <= images.size());
        images.resize(imageCountOutput);
    } else images.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(images) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<uint32_t> Swapchain::acquireSwapchainImage (
    const SwapchainImageAcquireInfo& acquireInfo, Dispatch&& d) const {
    uint32_t index;
    Result result = static_cast<Result>( d.xrAcquireSwapchainImage(this->get(), acquireInfo.get(), &index) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(index) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::waitSwapchainImage (
    const SwapchainImageWaitInfo& waitInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrWaitSwapchainImage(this->get(), waitInfo.get()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Swapchain::waitSwapchainImage");
    }
#endif



    return result;
}







































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::releaseSwapchainImage (
    const SwapchainImageReleaseInfo& releaseInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrReleaseSwapchainImage(this->get(), releaseInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::beginSession (
    const SessionBeginInfo& beginInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrBeginSession(this->get(), beginInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::endSession (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrEndSession(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::requestExitSession (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrRequestExitSession(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FrameState> Session::waitFrame (
    const FrameWaitInfo& frameWaitInfo, Dispatch&& d) const {
    FrameState frameState;
    Result result = static_cast<Result>( d.xrWaitFrame(this->get(), frameWaitInfo.get(), OPENXR_HPP_NAMESPACE::put(frameState)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(frameState) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::beginFrame (
    const FrameBeginInfo& frameBeginInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrBeginFrame(this->get(), frameBeginInfo.get()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::beginFrame");
    }
#endif



    return result;
}







































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::endFrame (
    const FrameEndInfo& frameEndInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrEndFrame(this->get(), frameEndInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<View, Allocator>> Session::locateViewsToVector (
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Dispatch&& d) const {
    std::vector<View, Allocator> views;
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(views) };
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, reinterpret_cast<XrView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(views) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<View, Allocator>> Session::locateViewsToVector (
    const ViewLocateInfo& viewLocateInfo, XrViewState* viewState, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<View, Allocator> views{vectorAllocator};
        uint32_t viewCountOutput = 0;
    uint32_t viewCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || viewCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(views) };
    }
    do {
        views.resize(viewCountOutput);
        viewCapacityInput = static_cast<uint32_t>(views.size());
        result = static_cast<Result>( d.xrLocateViews(this->get(), viewLocateInfo.get(), viewState, viewCapacityInput, &viewCountOutput, reinterpret_cast<XrView*>(views.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(viewCountOutput <= views.size());
        views.resize(viewCountOutput);
    } else views.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(views) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Path> Instance::stringToPath (
    const char* pathString, Dispatch&& d) const {
    Path path;
    Result result = static_cast<Result>( d.xrStringToPath(this->get(), pathString, OPENXR_HPP_NAMESPACE::put(path)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(path) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::pathToString (
    Path path, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::pathToString (
    Path path, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrPathToString(this->get(), path.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionSet> Instance::createActionSet (
    const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
    ActionSet handle;
    Result result = static_cast<Result>( d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>> Instance::createActionSetUnique (
    const ActionSetCreateInfo& createInfo, Dispatch&& d) const {
    ActionSet handle;
    Result result = static_cast<Result>( d.xrCreateActionSet(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result ActionSet::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyActionSet(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Action> ActionSet::createAction (
    const ActionCreateInfo& createInfo, Dispatch&& d) const {
    Action handle;
    Result result = static_cast<Result>( d.xrCreateAction(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>> ActionSet::createActionUnique (
    const ActionCreateInfo& createInfo, Dispatch&& d) const {
    Action handle;
    Result result = static_cast<Result>( d.xrCreateAction(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Action::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyAction(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::suggestInteractionProfileBindings (
    const InteractionProfileSuggestedBinding& suggestedBindings, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSuggestInteractionProfileBindings(this->get(), suggestedBindings.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::attachSessionActionSets (
    const SessionActionSetsAttachInfo& attachInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrAttachSessionActionSets(this->get(), attachInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<InteractionProfileState> Session::getCurrentInteractionProfile (
    Path topLevelUserPath, Dispatch&& d) const {
    InteractionProfileState interactionProfile;
    Result result = static_cast<Result>( d.xrGetCurrentInteractionProfile(this->get(), topLevelUserPath.get(), OPENXR_HPP_NAMESPACE::put(interactionProfile)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(interactionProfile) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStateBoolean> Session::getActionStateBoolean (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStateBoolean state;
    Result result = static_cast<Result>( d.xrGetActionStateBoolean(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(state) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStateFloat> Session::getActionStateFloat (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStateFloat state;
    Result result = static_cast<Result>( d.xrGetActionStateFloat(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(state) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStateVector2f> Session::getActionStateVector2f (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStateVector2f state;
    Result result = static_cast<Result>( d.xrGetActionStateVector2f(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(state) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<ActionStatePose> Session::getActionStatePose (
    const ActionStateGetInfo& getInfo, Dispatch&& d) const {
    ActionStatePose state;
    Result result = static_cast<Result>( d.xrGetActionStatePose(this->get(), getInfo.get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(state) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::syncActions (
    const ActionsSyncInfo& syncInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSyncActions(this->get(), syncInfo.get()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::syncActions");
    }
#endif



    return result;
}







































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<Path, Allocator>> Session::enumerateBoundSourcesForActionToVector (
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Dispatch&& d) const {
    std::vector<Path, Allocator> sources;
        uint32_t sourceCountOutput = 0;
    uint32_t sourceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(sources) };
    }
    do {
        sources.resize(sourceCountOutput);
        sourceCapacityInput = static_cast<uint32_t>(sources.size());
        result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, reinterpret_cast<XrPath*>(sources.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
        sources.resize(sourceCountOutput);
    } else sources.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(sources) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<Path, Allocator>> Session::enumerateBoundSourcesForActionToVector (
    const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<Path, Allocator> sources{vectorAllocator};
        uint32_t sourceCountOutput = 0;
    uint32_t sourceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || sourceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(sources) };
    }
    do {
        sources.resize(sourceCountOutput);
        sourceCapacityInput = static_cast<uint32_t>(sources.size());
        result = static_cast<Result>( d.xrEnumerateBoundSourcesForAction(this->get(), enumerateInfo.get(), sourceCapacityInput, &sourceCountOutput, reinterpret_cast<XrPath*>(sources.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(sourceCountOutput <= sources.size());
        sources.resize(sourceCountOutput);
    } else sources.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(sources) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Session::getInputSourceLocalizedName (
    const InputSourceLocalizedNameGetInfo& getInfo, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Session::getInputSourceLocalizedName (
    const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetInputSourceLocalizedName(this->get(), getInfo.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS






































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::applyHapticFeedback (
    const HapticActionInfo& hapticActionInfo, const XrHapticBaseHeader* hapticFeedback, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrApplyHapticFeedback(this->get(), hapticActionInfo.get(), hapticFeedback) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::applyHapticFeedback");
    }
#endif



    return result;
}







































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::stopHapticFeedback (
    const HapticActionInfo& hapticActionInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrStopHapticFeedback(this->get(), hapticActionInfo.get()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::stopHapticFeedback");
    }
#endif



    return result;
}





#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setAndroidApplicationThreadKHR (
    AndroidThreadTypeKHR threadType, uint32_t threadId, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetAndroidApplicationThreadKHR(this->get(), OPENXR_HPP_NAMESPACE::get(threadType), threadId) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings


#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Swapchain> Session::createSwapchainAndroidSurfaceKHR (
    const SwapchainCreateInfo& info, jobject* surface, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>> Session::createSwapchainAndroidSurfaceUniqueKHR (
    const SwapchainCreateInfo& info, jobject* surface, Dispatch&& d) const {
    Swapchain handle;
    Result result = static_cast<Result>( d.xrCreateSwapchainAndroidSurfaceKHR(this->get(), info.get(), handle.put(), surface) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain


#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsOpenGLKHR> Instance::getOpenGLGraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsOpenGLKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetOpenGLGraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(graphicsRequirements) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable


#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsOpenGLESKHR> Instance::getOpenGLESGraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsOpenGLESKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetOpenGLESGraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(graphicsRequirements) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable


#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::getVulkanInstanceExtensionsKHR (
    SystemId systemId, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::getVulkanInstanceExtensionsKHR (
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanInstanceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable


#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::getVulkanDeviceExtensionsKHR (
    SystemId systemId, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> Instance::getVulkanDeviceExtensionsKHR (
    SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetVulkanDeviceExtensionsKHR(this->get(), systemId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable


#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VkPhysicalDevice> Instance::getVulkanGraphicsDeviceKHR (
    SystemId systemId, VkInstance vkInstance, Dispatch&& d) const {
    VkPhysicalDevice vkPhysicalDevice;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsDeviceKHR(this->get(), systemId.get(), vkInstance, &vkPhysicalDevice) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(vkPhysicalDevice) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable


#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsVulkanKHR> Instance::getVulkanGraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsVulkanKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(graphicsRequirements) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable


#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsD3D11KHR> Instance::getD3D11GraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsD3D11KHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetD3D11GraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(graphicsRequirements) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable


#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsD3D12KHR> Instance::getD3D12GraphicsRequirementsKHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsD3D12KHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetD3D12GraphicsRequirementsKHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(graphicsRequirements) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable


#ifdef XR_KHR_visibility_mask

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VisibilityMaskKHR> Session::getVisibilityMaskKHR (
    ViewConfigurationType viewConfigurationType, uint32_t viewIndex, VisibilityMaskTypeKHR visibilityMaskType, Dispatch&& d) const {
    VisibilityMaskKHR visibilityMask;
    Result result = static_cast<Result>( d.xrGetVisibilityMaskKHR(this->get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), viewIndex, OPENXR_HPP_NAMESPACE::get(visibilityMaskType), OPENXR_HPP_NAMESPACE::put(visibilityMask)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(visibilityMask) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_KHR_visibility_mask


#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Time> Instance::convertWin32PerformanceCounterToTimeKHR (
    const LARGE_INTEGER* performanceCounter, Dispatch&& d) const {
    Time time;
    Result result = static_cast<Result>( d.xrConvertWin32PerformanceCounterToTimeKHR(this->get(), performanceCounter, OPENXR_HPP_NAMESPACE::put(time)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(time) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time


#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<LARGE_INTEGER> Instance::convertTimeToWin32PerformanceCounterKHR (
    Time time, Dispatch&& d) const {
    LARGE_INTEGER performanceCounter;
    Result result = static_cast<Result>( d.xrConvertTimeToWin32PerformanceCounterKHR(this->get(), time.get(), &performanceCounter) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(performanceCounter) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time


#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Time> Instance::convertTimespecTimeToTimeKHR (
    const struct timespec* timespecTime, Dispatch&& d) const {
    Time time;
    Result result = static_cast<Result>( d.xrConvertTimespecTimeToTimeKHR(this->get(), timespecTime, OPENXR_HPP_NAMESPACE::put(time)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(time) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time


#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<timespec> Instance::convertTimeToTimespecTimeKHR (
    Time time, Dispatch&& d) const {
    timespec timespecTime;
    Result result = static_cast<Result>( d.xrConvertTimeToTimespecTimeKHR(this->get(), time.get(), &timespecTime) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(timespecTime) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time


#ifdef XR_KHR_loader_init

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result initializeLoaderKHR (
    const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo, Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrInitializeLoaderKHR(loaderInitInfo) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_KHR_loader_init


#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::createVulkanInstanceKHR (
    const VulkanInstanceCreateInfoKHR& createInfo, VkInstance* vulkanInstance, VkResult* vulkanResult, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrCreateVulkanInstanceKHR(this->get(), createInfo.get(), vulkanInstance, vulkanResult) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2


#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::createVulkanDeviceKHR (
    const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice, VkResult* vulkanResult, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrCreateVulkanDeviceKHR(this->get(), createInfo.get(), vulkanDevice, vulkanResult) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2


#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VkPhysicalDevice> Instance::getVulkanGraphicsDevice2KHR (
    const VulkanGraphicsDeviceGetInfoKHR& getInfo, Dispatch&& d) const {
    VkPhysicalDevice vulkanPhysicalDevice;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsDevice2KHR(this->get(), getInfo.get(), &vulkanPhysicalDevice) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(vulkanPhysicalDevice) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2


#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GraphicsRequirementsVulkanKHR> Instance::getVulkanGraphicsRequirements2KHR (
    SystemId systemId, Dispatch&& d) const {
    GraphicsRequirementsVulkanKHR graphicsRequirements;
    Result result = static_cast<Result>( d.xrGetVulkanGraphicsRequirements2KHR(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::put(graphicsRequirements)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(graphicsRequirements) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2


#ifdef XR_EXT_performance_settings

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::perfSettingsSetPerformanceLevelEXT (
    PerfSettingsDomainEXT domain, PerfSettingsLevelEXT level, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPerfSettingsSetPerformanceLevelEXT(this->get(), OPENXR_HPP_NAMESPACE::get(domain), OPENXR_HPP_NAMESPACE::get(level)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_performance_settings


#ifdef XR_EXT_thermal_query

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::thermalGetTemperatureTrendEXT (
    PerfSettingsDomainEXT domain, PerfSettingsNotificationLevelEXT& notificationLevel, float* tempHeadroom, float* tempSlope, Dispatch&& d) const {
    XrPerfSettingsNotificationLevelEXT notificationLevel_tmp;
    Result result = static_cast<Result>( d.xrThermalGetTemperatureTrendEXT(this->get(), OPENXR_HPP_NAMESPACE::get(domain), &notificationLevel_tmp, tempHeadroom, tempSlope) );
    notificationLevel = static_cast<PerfSettingsNotificationLevelEXT>(notificationLevel_tmp);
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_thermal_query


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::setDebugUtilsObjectNameEXT (
    const DebugUtilsObjectNameInfoEXT& nameInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetDebugUtilsObjectNameEXT(this->get(), nameInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<DebugUtilsMessengerEXT> Instance::createDebugUtilsMessengerEXT (
    const DebugUtilsMessengerCreateInfoEXT& createInfo, Dispatch&& d) const {
    DebugUtilsMessengerEXT handle;
    Result result = static_cast<Result>( d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>> Instance::createDebugUtilsMessengerUniqueEXT (
    const DebugUtilsMessengerCreateInfoEXT& createInfo, Dispatch&& d) const {
    DebugUtilsMessengerEXT handle;
    Result result = static_cast<Result>( d.xrCreateDebugUtilsMessengerEXT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result DebugUtilsMessengerEXT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyDebugUtilsMessengerEXT(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::submitDebugUtilsMessageEXT (
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity, XrDebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT& callbackData, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSubmitDebugUtilsMessageEXT(this->get(), messageSeverity, messageTypes, callbackData.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::sessionBeginDebugUtilsLabelRegionEXT (
    const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSessionBeginDebugUtilsLabelRegionEXT(this->get(), labelInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::sessionEndDebugUtilsLabelRegionEXT (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSessionEndDebugUtilsLabelRegionEXT(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_EXT_debug_utils

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::sessionInsertDebugUtilsLabelEXT (
    const DebugUtilsLabelEXT& labelInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSessionInsertDebugUtilsLabelEXT(this->get(), labelInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_debug_utils


#ifdef XR_MSFT_spatial_anchor

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpatialAnchorMSFT> Session::createSpatialAnchorMSFT (
    const SpatialAnchorCreateInfoMSFT& createInfo, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>> Session::createSpatialAnchorUniqueMSFT (
    const SpatialAnchorCreateInfoMSFT& createInfo, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorMSFT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor


#ifdef XR_MSFT_spatial_anchor

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createSpatialAnchorSpaceMSFT (
    const SpatialAnchorSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createSpatialAnchorSpaceUniqueMSFT (
    const SpatialAnchorSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor


#ifdef XR_MSFT_spatial_anchor

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SpatialAnchorMSFT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySpatialAnchorMSFT(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_spatial_anchor


#ifdef XR_EXT_conformance_automation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceActiveEXT (
    Path interactionProfile, Path topLevelPath, XrBool32 isActive, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceActiveEXT(this->get(), interactionProfile.get(), topLevelPath.get(), isActive) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation


#ifdef XR_EXT_conformance_automation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceStateBoolEXT (
    Path topLevelPath, Path inputSourcePath, XrBool32 state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceStateBoolEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), state) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation


#ifdef XR_EXT_conformance_automation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceStateFloatEXT (
    Path topLevelPath, Path inputSourcePath, float state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceStateFloatEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), state) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation


#ifdef XR_EXT_conformance_automation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceStateVector2fEXT (
    Path topLevelPath, Path inputSourcePath, XrVector2f state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceStateVector2fEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), state) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation


#ifdef XR_EXT_conformance_automation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setInputDeviceLocationEXT (
    Path topLevelPath, Path inputSourcePath, Space space, XrPosef pose, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetInputDeviceLocationEXT(this->get(), topLevelPath.get(), inputSourcePath.get(), space.get(), pose) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_conformance_automation


#ifdef XR_EXT_hand_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandTrackerEXT> Session::createHandTrackerEXT (
    const HandTrackerCreateInfoEXT& createInfo, Dispatch&& d) const {
    HandTrackerEXT handle;
    Result result = static_cast<Result>( d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>> Session::createHandTrackerUniqueEXT (
    const HandTrackerCreateInfoEXT& createInfo, Dispatch&& d) const {
    HandTrackerEXT handle;
    Result result = static_cast<Result>( d.xrCreateHandTrackerEXT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_hand_tracking


#ifdef XR_EXT_hand_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result HandTrackerEXT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyHandTrackerEXT(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_hand_tracking


#ifdef XR_EXT_hand_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandJointLocationsEXT> HandTrackerEXT::locateHandJointsEXT (
    const HandJointsLocateInfoEXT& locateInfo, Dispatch&& d) const {
    HandJointLocationsEXT locations;
    Result result = static_cast<Result>( d.xrLocateHandJointsEXT(this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(locations)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(locations) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_hand_tracking


#ifdef XR_MSFT_hand_tracking_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> HandTrackerEXT::createHandMeshSpaceMSFT (
    const HandMeshSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> HandTrackerEXT::createHandMeshSpaceUniqueMSFT (
    const HandMeshSpaceCreateInfoMSFT& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateHandMeshSpaceMSFT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_hand_tracking_mesh


#ifdef XR_MSFT_hand_tracking_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandMeshMSFT> HandTrackerEXT::updateHandMeshMSFT (
    const HandMeshUpdateInfoMSFT& updateInfo, Dispatch&& d) const {
    HandMeshMSFT handMesh;
    Result result = static_cast<Result>( d.xrUpdateHandMeshMSFT(this->get(), updateInfo.get(), OPENXR_HPP_NAMESPACE::put(handMesh)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handMesh) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_hand_tracking_mesh


#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpatialAnchorMSFT> Session::createSpatialAnchorFromPerceptionAnchorMSFT (
    IUnknown* perceptionAnchor, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>> Session::createSpatialAnchorFromPerceptionAnchorUniqueMSFT (
    IUnknown* perceptionAnchor, Dispatch&& d) const {
    SpatialAnchorMSFT handle;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorFromPerceptionAnchorMSFT(this->get(), perceptionAnchor, handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop


#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::tryGetPerceptionAnchorFromSpatialAnchorMSFT (
    SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(this->get(), anchor.get(), perceptionAnchor) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop


#ifdef XR_MSFT_composition_layer_reprojection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReprojectionModeMSFT, Allocator>> Instance::enumerateReprojectionModesToVectorMSFT (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Dispatch&& d) const {
    std::vector<ReprojectionModeMSFT, Allocator> modes;
        uint32_t modeCountOutput = 0;
    uint32_t modeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(modes) };
    }
    do {
        modes.resize(modeCountOutput);
        modeCapacityInput = static_cast<uint32_t>(modes.size());
        result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
        modes.resize(modeCountOutput);
    } else modes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(modes) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ReprojectionModeMSFT, Allocator>> Instance::enumerateReprojectionModesToVectorMSFT (
    SystemId systemId, ViewConfigurationType viewConfigurationType, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ReprojectionModeMSFT, Allocator> modes{vectorAllocator};
        uint32_t modeCountOutput = 0;
    uint32_t modeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || modeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(modes) };
    }
    do {
        modes.resize(modeCountOutput);
        modeCapacityInput = static_cast<uint32_t>(modes.size());
        result = static_cast<Result>( d.xrEnumerateReprojectionModesMSFT(this->get(), systemId.get(), OPENXR_HPP_NAMESPACE::get(viewConfigurationType), modeCapacityInput, &modeCountOutput, reinterpret_cast<XrReprojectionModeMSFT*>(modes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(modeCountOutput <= modes.size());
        modes.resize(modeCountOutput);
    } else modes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(modes) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_composition_layer_reprojection


#ifdef XR_FB_swapchain_update_state

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Swapchain::updateSwapchainFB (
    const XrSwapchainStateBaseHeaderFB* state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrUpdateSwapchainFB(this->get(), state) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_swapchain_update_state


#ifdef XR_FB_body_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<BodyTrackerFB> Session::createBodyTrackerFB (
    const BodyTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    BodyTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateBodyTrackerFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<BodyTrackerFB, impl::RemoveRefConst<Dispatch>>> Session::createBodyTrackerUniqueFB (
    const BodyTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    BodyTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateBodyTrackerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<BodyTrackerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_body_tracking


#ifdef XR_FB_body_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result BodyTrackerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyBodyTrackerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_body_tracking


#ifdef XR_FB_body_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<BodyJointLocationsFB> BodyTrackerFB::locateBodyJointsFB (
    const BodyJointsLocateInfoFB& locateInfo, Dispatch&& d) const {
    BodyJointLocationsFB locations;
    Result result = static_cast<Result>( d.xrLocateBodyJointsFB(this->get(), locateInfo.get(), OPENXR_HPP_NAMESPACE::put(locations)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(locations) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_body_tracking


#ifdef XR_FB_body_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<BodySkeletonFB> BodyTrackerFB::getBodySkeletonFB (
    Dispatch&& d) const {
    BodySkeletonFB skeleton;
    Result result = static_cast<Result>( d.xrGetBodySkeletonFB(this->get(), OPENXR_HPP_NAMESPACE::put(skeleton)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(skeleton) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_body_tracking


#ifdef XR_FB_display_refresh_rate

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<float, Allocator>> Session::enumerateDisplayRefreshRatesToVectorFB (
    Dispatch&& d) const {
    std::vector<float, Allocator> displayRefreshRates;
        uint32_t displayRefreshRateCountOutput = 0;
    uint32_t displayRefreshRateCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(displayRefreshRates) };
    }
    do {
        displayRefreshRates.resize(displayRefreshRateCountOutput);
        displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
        result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, reinterpret_cast<float*>(displayRefreshRates.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
        displayRefreshRates.resize(displayRefreshRateCountOutput);
    } else displayRefreshRates.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(displayRefreshRates) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<float, Allocator>> Session::enumerateDisplayRefreshRatesToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<float, Allocator> displayRefreshRates{vectorAllocator};
        uint32_t displayRefreshRateCountOutput = 0;
    uint32_t displayRefreshRateCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || displayRefreshRateCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(displayRefreshRates) };
    }
    do {
        displayRefreshRates.resize(displayRefreshRateCountOutput);
        displayRefreshRateCapacityInput = static_cast<uint32_t>(displayRefreshRates.size());
        result = static_cast<Result>( d.xrEnumerateDisplayRefreshRatesFB(this->get(), displayRefreshRateCapacityInput, &displayRefreshRateCountOutput, reinterpret_cast<float*>(displayRefreshRates.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(displayRefreshRateCountOutput <= displayRefreshRates.size());
        displayRefreshRates.resize(displayRefreshRateCountOutput);
    } else displayRefreshRates.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(displayRefreshRates) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_display_refresh_rate


#ifdef XR_FB_display_refresh_rate

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<float> Session::getDisplayRefreshRateFB (
    Dispatch&& d) const {
    float displayRefreshRate;
    Result result = static_cast<Result>( d.xrGetDisplayRefreshRateFB(this->get(), &displayRefreshRate) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(displayRefreshRate) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_display_refresh_rate


#ifdef XR_FB_display_refresh_rate

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::requestDisplayRefreshRateFB (
    float displayRefreshRate, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrRequestDisplayRefreshRateFB(this->get(), displayRefreshRate) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_display_refresh_rate


#ifdef XR_HTCX_vive_tracker_interaction

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>> Instance::enumerateViveTrackerPathsToVectorHTCX (
    Dispatch&& d) const {
    std::vector<ViveTrackerPathsHTCX, Allocator> paths;
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(paths) };
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(paths) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>> Instance::enumerateViveTrackerPathsToVectorHTCX (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ViveTrackerPathsHTCX, Allocator> paths{vectorAllocator};
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(paths) };
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateViveTrackerPathsHTCX(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrViveTrackerPathsHTCX*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(paths) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTCX_vive_tracker_interaction


#ifdef XR_HTC_facial_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FacialTrackerHTC> Session::createFacialTrackerHTC (
    const FacialTrackerCreateInfoHTC& createInfo, Dispatch&& d) const {
    FacialTrackerHTC handle;
    Result result = static_cast<Result>( d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>> Session::createFacialTrackerUniqueHTC (
    const FacialTrackerCreateInfoHTC& createInfo, Dispatch&& d) const {
    FacialTrackerHTC handle;
    Result result = static_cast<Result>( d.xrCreateFacialTrackerHTC(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_facial_tracking


#ifdef XR_HTC_facial_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result FacialTrackerHTC::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyFacialTrackerHTC(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_facial_tracking


#ifdef XR_HTC_facial_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FacialExpressionsHTC> FacialTrackerHTC::getFacialExpressionsHTC (
    Dispatch&& d) const {
    FacialExpressionsHTC facialExpressions;
    Result result = static_cast<Result>( d.xrGetFacialExpressionsHTC(this->get(), OPENXR_HPP_NAMESPACE::put(facialExpressions)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(facialExpressions) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_facial_tracking


#ifdef XR_FB_color_space

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ColorSpaceFB, Allocator>> Session::enumerateColorSpacesToVectorFB (
    Dispatch&& d) const {
    std::vector<ColorSpaceFB, Allocator> colorSpaces;
        uint32_t colorSpaceCountOutput = 0;
    uint32_t colorSpaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(colorSpaces) };
    }
    do {
        colorSpaces.resize(colorSpaceCountOutput);
        colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
        result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
        colorSpaces.resize(colorSpaceCountOutput);
    } else colorSpaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(colorSpaces) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ColorSpaceFB, Allocator>> Session::enumerateColorSpacesToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ColorSpaceFB, Allocator> colorSpaces{vectorAllocator};
        uint32_t colorSpaceCountOutput = 0;
    uint32_t colorSpaceCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || colorSpaceCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(colorSpaces) };
    }
    do {
        colorSpaces.resize(colorSpaceCountOutput);
        colorSpaceCapacityInput = static_cast<uint32_t>(colorSpaces.size());
        result = static_cast<Result>( d.xrEnumerateColorSpacesFB(this->get(), colorSpaceCapacityInput, &colorSpaceCountOutput, reinterpret_cast<XrColorSpaceFB*>(colorSpaces.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(colorSpaceCountOutput <= colorSpaces.size());
        colorSpaces.resize(colorSpaceCountOutput);
    } else colorSpaces.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(colorSpaces) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_color_space


#ifdef XR_FB_color_space

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setColorSpaceFB (
    ColorSpaceFB colorSpace, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetColorSpaceFB(this->get(), OPENXR_HPP_NAMESPACE::get(colorSpace)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_color_space


#ifdef XR_FB_hand_tracking_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<HandTrackingMeshFB> HandTrackerEXT::getHandMeshFB (
    Dispatch&& d) const {
    HandTrackingMeshFB mesh;
    Result result = static_cast<Result>( d.xrGetHandMeshFB(this->get(), OPENXR_HPP_NAMESPACE::put(mesh)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(mesh) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_hand_tracking_mesh


#ifdef XR_FB_spatial_entity

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::createSpatialAnchorFB (
    const SpatialAnchorCreateInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrCreateSpatialAnchorFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity


#ifdef XR_FB_spatial_entity

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UuidEXT> Space::getSpaceUuidFB (
    Dispatch&& d) const {
    UuidEXT uuid;
    Result result = static_cast<Result>( d.xrGetSpaceUuidFB(this->get(), OPENXR_HPP_NAMESPACE::put(uuid)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(uuid) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity


#ifdef XR_FB_spatial_entity

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<SpaceComponentTypeFB, Allocator>> Space::enumerateSpaceSupportedComponentsToVectorFB (
    Dispatch&& d) const {
    std::vector<SpaceComponentTypeFB, Allocator> componentTypes;
        uint32_t componentTypeCountOutput = 0;
    uint32_t componentTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || componentTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(componentTypes) };
    }
    do {
        componentTypes.resize(componentTypeCountOutput);
        componentTypeCapacityInput = static_cast<uint32_t>(componentTypes.size());
        result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, reinterpret_cast<XrSpaceComponentTypeFB*>(componentTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(componentTypeCountOutput <= componentTypes.size());
        componentTypes.resize(componentTypeCountOutput);
    } else componentTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(componentTypes) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<SpaceComponentTypeFB, Allocator>> Space::enumerateSpaceSupportedComponentsToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<SpaceComponentTypeFB, Allocator> componentTypes{vectorAllocator};
        uint32_t componentTypeCountOutput = 0;
    uint32_t componentTypeCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || componentTypeCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(componentTypes) };
    }
    do {
        componentTypes.resize(componentTypeCountOutput);
        componentTypeCapacityInput = static_cast<uint32_t>(componentTypes.size());
        result = static_cast<Result>( d.xrEnumerateSpaceSupportedComponentsFB(this->get(), componentTypeCapacityInput, &componentTypeCountOutput, reinterpret_cast<XrSpaceComponentTypeFB*>(componentTypes.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(componentTypeCountOutput <= componentTypes.size());
        componentTypes.resize(componentTypeCountOutput);
    } else componentTypes.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(componentTypes) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity


#ifdef XR_FB_spatial_entity

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Space::setSpaceComponentStatusFB (
    const SpaceComponentStatusSetInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrSetSpaceComponentStatusFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity


#ifdef XR_FB_spatial_entity

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceComponentStatusFB> Space::getSpaceComponentStatusFB (
    SpaceComponentTypeFB componentType, Dispatch&& d) const {
    SpaceComponentStatusFB status;
    Result result = static_cast<Result>( d.xrGetSpaceComponentStatusFB(this->get(), OPENXR_HPP_NAMESPACE::get(componentType), OPENXR_HPP_NAMESPACE::put(status)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(status) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity


#ifdef XR_FB_foveation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FoveationProfileFB> Session::createFoveationProfileFB (
    const FoveationProfileCreateInfoFB& createInfo, Dispatch&& d) const {
    FoveationProfileFB handle;
    Result result = static_cast<Result>( d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>> Session::createFoveationProfileUniqueFB (
    const FoveationProfileCreateInfoFB& createInfo, Dispatch&& d) const {
    FoveationProfileFB handle;
    Result result = static_cast<Result>( d.xrCreateFoveationProfileFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_foveation


#ifdef XR_FB_foveation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result FoveationProfileFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyFoveationProfileFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_foveation


#ifdef XR_FB_keyboard_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<KeyboardTrackingDescriptionFB> Session::querySystemTrackedKeyboardFB (
    const KeyboardTrackingQueryFB& queryInfo, Dispatch&& d) const {
    KeyboardTrackingDescriptionFB keyboard;
    Result result = static_cast<Result>( d.xrQuerySystemTrackedKeyboardFB(this->get(), queryInfo.get(), OPENXR_HPP_NAMESPACE::put(keyboard)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(keyboard) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_keyboard_tracking


#ifdef XR_FB_keyboard_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createKeyboardSpaceFB (
    const KeyboardSpaceCreateInfoFB& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createKeyboardSpaceUniqueFB (
    const KeyboardSpaceCreateInfoFB& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateKeyboardSpaceFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_keyboard_tracking


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<TriangleMeshFB> Session::createTriangleMeshFB (
    const TriangleMeshCreateInfoFB& createInfo, Dispatch&& d) const {
    TriangleMeshFB handle;
    Result result = static_cast<Result>( d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>> Session::createTriangleMeshUniqueFB (
    const TriangleMeshCreateInfoFB& createInfo, Dispatch&& d) const {
    TriangleMeshFB handle;
    Result result = static_cast<Result>( d.xrCreateTriangleMeshFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyTriangleMeshFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshGetVertexBufferFB (
    XrVector3f** outVertexBuffer, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshGetVertexBufferFB(this->get(), outVertexBuffer) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshGetIndexBufferFB (
    uint32_t** outIndexBuffer, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshGetIndexBufferFB(this->get(), outIndexBuffer) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshBeginUpdateFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshBeginUpdateFB(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshEndUpdateFB (
    uint32_t vertexCount, uint32_t triangleCount, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshEndUpdateFB(this->get(), vertexCount, triangleCount) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<uint32_t> TriangleMeshFB::triangleMeshBeginVertexBufferUpdateFB (
    Dispatch&& d) const {
    uint32_t outVertexCount;
    Result result = static_cast<Result>( d.xrTriangleMeshBeginVertexBufferUpdateFB(this->get(), &outVertexCount) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(outVertexCount) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_triangle_mesh

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result TriangleMeshFB::triangleMeshEndVertexBufferUpdateFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrTriangleMeshEndVertexBufferUpdateFB(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_triangle_mesh


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughFB> Session::createPassthroughFB (
    const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>> Session::createPassthroughUniqueFB (
    const PassthroughCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughFB::passthroughStartFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughStartFB(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughFB::passthroughPauseFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughPauseFB(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughLayerFB> Session::createPassthroughLayerFB (
    const PassthroughLayerCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughLayerFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>> Session::createPassthroughLayerUniqueFB (
    const PassthroughLayerCreateInfoFB& createInfo, Dispatch&& d) const {
    PassthroughLayerFB handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughLayerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughLayerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerPauseFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerPauseFB(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerResumeFB (
    Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerResumeFB(this->get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerSetStyleFB (
    const PassthroughStyleFB& style, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerSetStyleFB(this->get(), style.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<GeometryInstanceFB> Session::createGeometryInstanceFB (
    const GeometryInstanceCreateInfoFB& createInfo, Dispatch&& d) const {
    GeometryInstanceFB handle;
    Result result = static_cast<Result>( d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>> Session::createGeometryInstanceUniqueFB (
    const GeometryInstanceCreateInfoFB& createInfo, Dispatch&& d) const {
    GeometryInstanceFB handle;
    Result result = static_cast<Result>( d.xrCreateGeometryInstanceFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result GeometryInstanceFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyGeometryInstanceFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result GeometryInstanceFB::geometryInstanceSetTransformFB (
    const GeometryInstanceTransformFB& transformation, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGeometryInstanceSetTransformFB(this->get(), transformation.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough


#ifdef XR_FB_render_model

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<RenderModelPathInfoFB, Allocator>> Session::enumerateRenderModelPathsToVectorFB (
    Dispatch&& d) const {
    std::vector<RenderModelPathInfoFB, Allocator> paths;
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(paths) };
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(paths) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<RenderModelPathInfoFB, Allocator>> Session::enumerateRenderModelPathsToVectorFB (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<RenderModelPathInfoFB, Allocator> paths{vectorAllocator};
        uint32_t pathCountOutput = 0;
    uint32_t pathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || pathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(paths) };
    }
    do {
        paths.resize(pathCountOutput);
        pathCapacityInput = static_cast<uint32_t>(paths.size());
        result = static_cast<Result>( d.xrEnumerateRenderModelPathsFB(this->get(), pathCapacityInput, &pathCountOutput, reinterpret_cast<XrRenderModelPathInfoFB*>(paths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(pathCountOutput <= paths.size());
        paths.resize(pathCountOutput);
    } else paths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(paths) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_render_model


#ifdef XR_FB_render_model

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::getRenderModelPropertiesFB (
    Path path, RenderModelPropertiesFB& properties, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetRenderModelPropertiesFB(this->get(), path.get(), properties.put()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::getRenderModelPropertiesFB");
    }
#endif



    return result;
}


#endif  // XR_FB_render_model


#ifdef XR_FB_render_model

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::loadRenderModelFB (
    const RenderModelLoadInfoFB& info, RenderModelBufferFB& buffer, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrLoadRenderModelFB(this->get(), info.get(), buffer.put()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::Session::loadRenderModelFB");
    }
#endif



    return result;
}


#endif  // XR_FB_render_model


#ifdef XR_VARJO_environment_depth_estimation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setEnvironmentDepthEstimationVARJO (
    XrBool32 enabled, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetEnvironmentDepthEstimationVARJO(this->get(), enabled) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_environment_depth_estimation


#ifdef XR_VARJO_marker_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setMarkerTrackingVARJO (
    XrBool32 enabled, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetMarkerTrackingVARJO(this->get(), enabled) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking


#ifdef XR_VARJO_marker_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setMarkerTrackingTimeoutVARJO (
    uint64_t markerId, Duration timeout, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetMarkerTrackingTimeoutVARJO(this->get(), markerId, timeout.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking


#ifdef XR_VARJO_marker_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setMarkerTrackingPredictionVARJO (
    uint64_t markerId, XrBool32 enable, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetMarkerTrackingPredictionVARJO(this->get(), markerId, enable) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking


#ifdef XR_VARJO_marker_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Extent2Df> Session::getMarkerSizeVARJO (
    uint64_t markerId, Dispatch&& d) const {
    Extent2Df size;
    Result result = static_cast<Result>( d.xrGetMarkerSizeVARJO(this->get(), markerId, OPENXR_HPP_NAMESPACE::put(size)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(size) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking


#ifdef XR_VARJO_marker_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createMarkerSpaceVARJO (
    const MarkerSpaceCreateInfoVARJO& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createMarkerSpaceUniqueVARJO (
    const MarkerSpaceCreateInfoVARJO& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateMarkerSpaceVARJO(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_marker_tracking


#ifdef XR_VARJO_view_offset

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setViewOffsetVARJO (
    float offset, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetViewOffsetVARJO(this->get(), offset) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_VARJO_view_offset


#ifdef XR_ML_compat
#if defined(XR_USE_PLATFORM_ML)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createSpaceFromCoordinateFrameUIDML (
    const CoordinateSpaceCreateInfoML& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpaceFromCoordinateFrameUIDML(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createSpaceFromCoordinateFrameUIDUniqueML (
    const CoordinateSpaceCreateInfoML& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateSpaceFromCoordinateFrameUIDML(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_ML)
#endif  // XR_ML_compat


#ifdef XR_MSFT_scene_marker

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<uint8_t, Allocator>> SceneMSFT::getSceneMarkerRawDataToVectorMSFT (
    const UuidMSFT& markerId, Dispatch&& d) const {
    std::vector<uint8_t, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(buffer) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<uint8_t*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(buffer) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<uint8_t, Allocator>> SceneMSFT::getSceneMarkerRawDataToVectorMSFT (
    const UuidMSFT& markerId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<uint8_t, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(buffer) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetSceneMarkerRawDataMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<uint8_t*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(buffer) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_MSFT_scene_marker


#ifdef XR_MSFT_scene_marker

































template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> SceneMSFT::getSceneMarkerDecodedStringMSFT (
    const UuidMSFT& markerId, Dispatch&& d) const {
    std::vector<char, Allocator> buffer;
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{{}};
    Result result = static_cast<Result>( d.xrGetSceneMarkerDecodedStringMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetSceneMarkerDecodedStringMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<string_with_allocator<Allocator>> SceneMSFT::getSceneMarkerDecodedStringMSFT (
    const UuidMSFT& markerId, Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<char, Allocator> buffer{vectorAllocator};
        uint32_t bufferCountOutput = 0;
    uint32_t bufferCapacityInput = 0;

    
    std::basic_string<char, std::char_traits<char>, Allocator> str{vectorAllocator};
    Result result = static_cast<Result>( d.xrGetSceneMarkerDecodedStringMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || bufferCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(str) };
    }
    do {
        buffer.resize(bufferCountOutput);
        bufferCapacityInput = static_cast<uint32_t>(buffer.size());
        result = static_cast<Result>( d.xrGetSceneMarkerDecodedStringMSFT(this->get(), markerId.get(), bufferCapacityInput, &bufferCountOutput, reinterpret_cast<char*>(buffer.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(bufferCountOutput <= buffer.size());
        buffer.resize(bufferCountOutput);
    } else buffer.clear();
    
    str.assign(buffer.begin(), buffer.end());
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(str) };

}


#endif  // XR_MSFT_scene_marker


#ifdef XR_FB_spatial_entity_query

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::querySpacesFB (
    const XrSpaceQueryInfoBaseHeaderFB* info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrQuerySpacesFB(this->get(), info, OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_query


#ifdef XR_FB_spatial_entity_query

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceQueryResultsFB> Session::retrieveSpaceQueryResultsFB (
    AsyncRequestIdFB requestId, Dispatch&& d) const {
    SpaceQueryResultsFB results;
    Result result = static_cast<Result>( d.xrRetrieveSpaceQueryResultsFB(this->get(), requestId.get(), OPENXR_HPP_NAMESPACE::put(results)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(results) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_query


#ifdef XR_FB_spatial_entity_storage

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::saveSpaceFB (
    const SpaceSaveInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrSaveSpaceFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_storage


#ifdef XR_FB_spatial_entity_storage

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::eraseSpaceFB (
    const SpaceEraseInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrEraseSpaceFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_storage


#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::getAudioOutputDeviceGuidOculus (
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetAudioOutputDeviceGuidOculus(this->get(), buffer) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid


#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::getAudioInputDeviceGuidOculus (
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS], Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrGetAudioInputDeviceGuidOculus(this->get(), buffer) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid


#ifdef XR_FB_spatial_entity_sharing

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::shareSpacesFB (
    const SpaceShareInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrShareSpacesFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_sharing


#ifdef XR_FB_scene

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Rect2Df> Session::getSpaceBoundingBox2DFB (
    Space space, Dispatch&& d) const {
    Rect2Df boundingBox2DOutput;
    Result result = static_cast<Result>( d.xrGetSpaceBoundingBox2DFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(boundingBox2DOutput)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(boundingBox2DOutput) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_scene


#ifdef XR_FB_scene

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Rect3DfFB> Session::getSpaceBoundingBox3DFB (
    Space space, Dispatch&& d) const {
    Rect3DfFB boundingBox3DOutput;
    Result result = static_cast<Result>( d.xrGetSpaceBoundingBox3DFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(boundingBox3DOutput)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(boundingBox3DOutput) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_scene


#ifdef XR_FB_scene

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SemanticLabelsFB> Session::getSpaceSemanticLabelsFB (
    Space space, Dispatch&& d) const {
    SemanticLabelsFB semanticLabelsOutput;
    Result result = static_cast<Result>( d.xrGetSpaceSemanticLabelsFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(semanticLabelsOutput)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(semanticLabelsOutput) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_scene


#ifdef XR_FB_scene

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Boundary2DFB> Session::getSpaceBoundary2DFB (
    Space space, Dispatch&& d) const {
    Boundary2DFB boundary2DOutput;
    Result result = static_cast<Result>( d.xrGetSpaceBoundary2DFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(boundary2DOutput)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(boundary2DOutput) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_scene


#ifdef XR_FB_scene

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<RoomLayoutFB> Session::getSpaceRoomLayoutFB (
    Space space, Dispatch&& d) const {
    RoomLayoutFB roomLayoutOutput;
    Result result = static_cast<Result>( d.xrGetSpaceRoomLayoutFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(roomLayoutOutput)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(roomLayoutOutput) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_scene


#ifdef XR_ALMALENCE_digital_lens_control

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setDigitalLensControlALMALENCE (
    const DigitalLensControlALMALENCE& digitalLensControl, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetDigitalLensControlALMALENCE(this->get(), digitalLensControl.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_ALMALENCE_digital_lens_control


#ifdef XR_FB_scene_capture

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::requestSceneCaptureFB (
    const SceneCaptureRequestInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrRequestSceneCaptureFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_scene_capture


#ifdef XR_FB_spatial_entity_container

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceContainerFB> Session::getSpaceContainerFB (
    Space space, Dispatch&& d) const {
    SpaceContainerFB spaceContainerOutput;
    Result result = static_cast<Result>( d.xrGetSpaceContainerFB(this->get(), space.get(), OPENXR_HPP_NAMESPACE::put(spaceContainerOutput)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(spaceContainerOutput) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_container


#ifdef XR_META_foveation_eye_tracked

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FoveationEyeTrackedStateMETA> Session::getFoveationEyeTrackedStateMETA (
    Dispatch&& d) const {
    FoveationEyeTrackedStateMETA foveationState;
    Result result = static_cast<Result>( d.xrGetFoveationEyeTrackedStateMETA(this->get(), OPENXR_HPP_NAMESPACE::put(foveationState)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(foveationState) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_foveation_eye_tracked


#ifdef XR_FB_face_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FaceTrackerFB> Session::createFaceTrackerFB (
    const FaceTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    FaceTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateFaceTrackerFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<FaceTrackerFB, impl::RemoveRefConst<Dispatch>>> Session::createFaceTrackerUniqueFB (
    const FaceTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    FaceTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateFaceTrackerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<FaceTrackerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_face_tracking


#ifdef XR_FB_face_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result FaceTrackerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyFaceTrackerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_face_tracking


#ifdef XR_FB_face_tracking

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<FaceExpressionWeightsFB> FaceTrackerFB::getFaceExpressionWeightsFB (
    const FaceExpressionInfoFB& expressionInfo, Dispatch&& d) const {
    FaceExpressionWeightsFB expressionWeights;
    Result result = static_cast<Result>( d.xrGetFaceExpressionWeightsFB(this->get(), expressionInfo.get(), OPENXR_HPP_NAMESPACE::put(expressionWeights)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(expressionWeights) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_face_tracking


#ifdef XR_FB_eye_tracking_social

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<EyeTrackerFB> Session::createEyeTrackerFB (
    const EyeTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    EyeTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateEyeTrackerFB(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<EyeTrackerFB, impl::RemoveRefConst<Dispatch>>> Session::createEyeTrackerUniqueFB (
    const EyeTrackerCreateInfoFB& createInfo, Dispatch&& d) const {
    EyeTrackerFB handle;
    Result result = static_cast<Result>( d.xrCreateEyeTrackerFB(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<EyeTrackerFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_eye_tracking_social


#ifdef XR_FB_eye_tracking_social

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result EyeTrackerFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyEyeTrackerFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_eye_tracking_social


#ifdef XR_FB_eye_tracking_social

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<EyeGazesFB> EyeTrackerFB::getEyeGazesFB (
    const EyeGazesInfoFB& gazeInfo, Dispatch&& d) const {
    EyeGazesFB eyeGazes;
    Result result = static_cast<Result>( d.xrGetEyeGazesFB(this->get(), gazeInfo.get(), OPENXR_HPP_NAMESPACE::put(eyeGazes)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(eyeGazes) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_eye_tracking_social


#ifdef XR_FB_passthrough_keyboard_hands

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughLayerFB::passthroughLayerSetKeyboardHandsIntensityFB (
    const PassthroughKeyboardHandsIntensityFB& intensity, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrPassthroughLayerSetKeyboardHandsIntensityFB(this->get(), intensity.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_passthrough_keyboard_hands


#ifdef XR_FB_haptic_pcm

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<DevicePcmSampleRateGetInfoFB> Session::getDeviceSampleRateFB (
    const HapticActionInfo& hapticActionInfo, Dispatch&& d) const {
    DevicePcmSampleRateGetInfoFB deviceSampleRate;
    Result result = static_cast<Result>( d.xrGetDeviceSampleRateFB(this->get(), hapticActionInfo.get(), &deviceSampleRate) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(deviceSampleRate) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_haptic_pcm


#ifdef XR_META_passthrough_preferences

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughPreferencesMETA> Session::getPassthroughPreferencesMETA (
    Dispatch&& d) const {
    PassthroughPreferencesMETA preferences;
    Result result = static_cast<Result>( d.xrGetPassthroughPreferencesMETA(this->get(), OPENXR_HPP_NAMESPACE::put(preferences)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(preferences) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_passthrough_preferences


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VirtualKeyboardMETA> Session::createVirtualKeyboardMETA (
    const VirtualKeyboardCreateInfoMETA& createInfo, Dispatch&& d) const {
    VirtualKeyboardMETA handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardMETA(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<VirtualKeyboardMETA, impl::RemoveRefConst<Dispatch>>> Session::createVirtualKeyboardUniqueMETA (
    const VirtualKeyboardCreateInfoMETA& createInfo, Dispatch&& d) const {
    VirtualKeyboardMETA handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardMETA(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<VirtualKeyboardMETA, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result VirtualKeyboardMETA::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyVirtualKeyboardMETA(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Space> Session::createVirtualKeyboardSpaceMETA (
    VirtualKeyboardMETA keyboard, const VirtualKeyboardSpaceCreateInfoMETA& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardSpaceMETA(this->get(), keyboard.get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> Session::createVirtualKeyboardSpaceUniqueMETA (
    VirtualKeyboardMETA keyboard, const VirtualKeyboardSpaceCreateInfoMETA& createInfo, Dispatch&& d) const {
    Space handle;
    Result result = static_cast<Result>( d.xrCreateVirtualKeyboardSpaceMETA(this->get(), keyboard.get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result VirtualKeyboardMETA::suggestVirtualKeyboardLocationMETA (
    const VirtualKeyboardLocationInfoMETA& locationInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSuggestVirtualKeyboardLocationMETA(this->get(), locationInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<float> VirtualKeyboardMETA::getVirtualKeyboardScaleMETA (
    Dispatch&& d) const {
    float scale;
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardScaleMETA(this->get(), &scale) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(scale) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result VirtualKeyboardMETA::setVirtualKeyboardModelVisibilityMETA (
    const VirtualKeyboardModelVisibilitySetInfoMETA& modelVisibility, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetVirtualKeyboardModelVisibilityMETA(this->get(), modelVisibility.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VirtualKeyboardModelAnimationStatesMETA> VirtualKeyboardMETA::getVirtualKeyboardModelAnimationStatesMETA (
    Dispatch&& d) const {
    VirtualKeyboardModelAnimationStatesMETA animationStates;
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardModelAnimationStatesMETA(this->get(), OPENXR_HPP_NAMESPACE::put(animationStates)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(animationStates) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<uint64_t, Allocator>> VirtualKeyboardMETA::getVirtualKeyboardDirtyTexturesToVectorMETA (
    Dispatch&& d) const {
    std::vector<uint64_t, Allocator> textureIds;
        uint32_t textureIdCountOutput = 0;
    uint32_t textureIdCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || textureIdCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(textureIds) };
    }
    do {
        textureIds.resize(textureIdCountOutput);
        textureIdCapacityInput = static_cast<uint32_t>(textureIds.size());
        result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, reinterpret_cast<uint64_t*>(textureIds.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(textureIdCountOutput <= textureIds.size());
        textureIds.resize(textureIdCountOutput);
    } else textureIds.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(textureIds) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<uint64_t, Allocator>> VirtualKeyboardMETA::getVirtualKeyboardDirtyTexturesToVectorMETA (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<uint64_t, Allocator> textureIds{vectorAllocator};
        uint32_t textureIdCountOutput = 0;
    uint32_t textureIdCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || textureIdCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(textureIds) };
    }
    do {
        textureIds.resize(textureIdCountOutput);
        textureIdCapacityInput = static_cast<uint32_t>(textureIds.size());
        result = static_cast<Result>( d.xrGetVirtualKeyboardDirtyTexturesMETA(this->get(), textureIdCapacityInput, &textureIdCountOutput, reinterpret_cast<uint64_t*>(textureIds.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(textureIdCountOutput <= textureIds.size());
        textureIds.resize(textureIdCountOutput);
    } else textureIds.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(textureIds) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<VirtualKeyboardTextureDataMETA> VirtualKeyboardMETA::getVirtualKeyboardTextureDataMETA (
    uint64_t textureId, Dispatch&& d) const {
    VirtualKeyboardTextureDataMETA textureData;
    Result result = static_cast<Result>( d.xrGetVirtualKeyboardTextureDataMETA(this->get(), textureId, OPENXR_HPP_NAMESPACE::put(textureData)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(textureData) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<Posef> VirtualKeyboardMETA::sendVirtualKeyboardInputMETA (
    const VirtualKeyboardInputInfoMETA& info, Dispatch&& d) const {
    Posef interactorRootPose;
    Result result = static_cast<Result>( d.xrSendVirtualKeyboardInputMETA(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(interactorRootPose)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(interactorRootPose) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_META_virtual_keyboard

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result VirtualKeyboardMETA::changeVirtualKeyboardTextContextMETA (
    const VirtualKeyboardTextContextChangeInfoMETA& changeInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrChangeVirtualKeyboardTextContextMETA(this->get(), changeInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_virtual_keyboard


#ifdef XR_OCULUS_external_camera

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ExternalCameraOCULUS, Allocator>> Session::enumerateExternalCamerasToVectorOCULUS (
    Dispatch&& d) const {
    std::vector<ExternalCameraOCULUS, Allocator> cameras;
        uint32_t cameraCountOutput = 0;
    uint32_t cameraCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || cameraCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(cameras) };
    }
    do {
        cameras.resize(cameraCountOutput);
        cameraCapacityInput = static_cast<uint32_t>(cameras.size());
        result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, reinterpret_cast<XrExternalCameraOCULUS*>(cameras.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(cameraCountOutput <= cameras.size());
        cameras.resize(cameraCountOutput);
    } else cameras.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(cameras) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<ExternalCameraOCULUS, Allocator>> Session::enumerateExternalCamerasToVectorOCULUS (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<ExternalCameraOCULUS, Allocator> cameras{vectorAllocator};
        uint32_t cameraCountOutput = 0;
    uint32_t cameraCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || cameraCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(cameras) };
    }
    do {
        cameras.resize(cameraCountOutput);
        cameraCapacityInput = static_cast<uint32_t>(cameras.size());
        result = static_cast<Result>( d.xrEnumerateExternalCamerasOCULUS(this->get(), cameraCapacityInput, &cameraCountOutput, reinterpret_cast<XrExternalCameraOCULUS*>(cameras.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(cameraCountOutput <= cameras.size());
        cameras.resize(cameraCountOutput);
    } else cameras.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(cameras) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_OCULUS_external_camera


#ifdef XR_META_performance_metrics

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<Path, Allocator>> Instance::enumeratePerformanceMetricsCounterPathsToVectorMETA (
    Dispatch&& d) const {
    std::vector<Path, Allocator> counterPaths;
        uint32_t counterPathCountOutput = 0;
    uint32_t counterPathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || counterPathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(counterPaths) };
    }
    do {
        counterPaths.resize(counterPathCountOutput);
        counterPathCapacityInput = static_cast<uint32_t>(counterPaths.size());
        result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, reinterpret_cast<XrPath*>(counterPaths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(counterPathCountOutput <= counterPaths.size());
        counterPaths.resize(counterPathCountOutput);
    } else counterPaths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(counterPaths) };

}

template <typename Allocator, typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<std::vector<Path, Allocator>> Instance::enumeratePerformanceMetricsCounterPathsToVectorMETA (
    Allocator const& vectorAllocator, Dispatch&& d) const {
    std::vector<Path, Allocator> counterPaths{vectorAllocator};
        uint32_t counterPathCountOutput = 0;
    uint32_t counterPathCapacityInput = 0;

    
    Result result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, nullptr) );
    if (!unqualifiedSuccess(result) || counterPathCountOutput == 0) {
                OPENXR_HPP_ASSERT( succeeded(result) );


        return { result, std::move(counterPaths) };
    }
    do {
        counterPaths.resize(counterPathCountOutput);
        counterPathCapacityInput = static_cast<uint32_t>(counterPaths.size());
        result = static_cast<Result>( d.xrEnumeratePerformanceMetricsCounterPathsMETA(this->get(), counterPathCapacityInput, &counterPathCountOutput, reinterpret_cast<XrPath*>(counterPaths.data())) );
    } while (result == xr::Result::ErrorSizeInsufficient);
    if (succeeded(result)) {
        OPENXR_HPP_ASSERT(counterPathCountOutput <= counterPaths.size());
        counterPaths.resize(counterPathCountOutput);
    } else counterPaths.clear();
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(counterPaths) };

}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_performance_metrics


#ifdef XR_META_performance_metrics

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setPerformanceMetricsStateMETA (
    const PerformanceMetricsStateMETA& state, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetPerformanceMetricsStateMETA(this->get(), state.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_performance_metrics


#ifdef XR_META_performance_metrics

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PerformanceMetricsStateMETA> Session::getPerformanceMetricsStateMETA (
    Dispatch&& d) const {
    PerformanceMetricsStateMETA state;
    Result result = static_cast<Result>( d.xrGetPerformanceMetricsStateMETA(this->get(), OPENXR_HPP_NAMESPACE::put(state)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(state) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_performance_metrics


#ifdef XR_META_performance_metrics

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PerformanceMetricsCounterMETA> Session::queryPerformanceMetricsCounterMETA (
    Path counterPath, Dispatch&& d) const {
    PerformanceMetricsCounterMETA counter;
    Result result = static_cast<Result>( d.xrQueryPerformanceMetricsCounterMETA(this->get(), counterPath.get(), OPENXR_HPP_NAMESPACE::put(counter)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(counter) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_performance_metrics


#ifdef XR_FB_spatial_entity_storage_batch

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<AsyncRequestIdFB> Session::saveSpaceListFB (
    const SpaceListSaveInfoFB& info, Dispatch&& d) const {
    AsyncRequestIdFB requestId;
    Result result = static_cast<Result>( d.xrSaveSpaceListFB(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(requestId)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(requestId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_storage_batch


#ifdef XR_FB_spatial_entity_user

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceUserFB> Session::createSpaceUserFB (
    const SpaceUserCreateInfoFB& info, Dispatch&& d) const {
    SpaceUserFB handle;
    Result result = static_cast<Result>( d.xrCreateSpaceUserFB(this->get(), info.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<SpaceUserFB, impl::RemoveRefConst<Dispatch>>> Session::createSpaceUserUniqueFB (
    const SpaceUserCreateInfoFB& info, Dispatch&& d) const {
    SpaceUserFB handle;
    Result result = static_cast<Result>( d.xrCreateSpaceUserFB(this->get(), info.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<SpaceUserFB, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_user


#ifdef XR_FB_spatial_entity_user

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<SpaceUserIdFB> SpaceUserFB::getSpaceUserIdFB (
    Dispatch&& d) const {
    SpaceUserIdFB userId;
    Result result = static_cast<Result>( d.xrGetSpaceUserIdFB(this->get(), &userId) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(userId) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_user


#ifdef XR_FB_spatial_entity_user

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result SpaceUserFB::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroySpaceUserFB(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_FB_spatial_entity_user


#ifdef XR_META_passthrough_color_lut

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughColorLutMETA> PassthroughFB::createPassthroughColorLutMETA (
    const PassthroughColorLutCreateInfoMETA& createInfo, Dispatch&& d) const {
    PassthroughColorLutMETA handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughColorLutMETA(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PassthroughColorLutMETA, impl::RemoveRefConst<Dispatch>>> PassthroughFB::createPassthroughColorLutUniqueMETA (
    const PassthroughColorLutCreateInfoMETA& createInfo, Dispatch&& d) const {
    PassthroughColorLutMETA handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughColorLutMETA(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<PassthroughColorLutMETA, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_passthrough_color_lut


#ifdef XR_META_passthrough_color_lut

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughColorLutMETA::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughColorLutMETA(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_passthrough_color_lut


#ifdef XR_META_passthrough_color_lut

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughColorLutMETA::updatePassthroughColorLutMETA (
    const PassthroughColorLutUpdateInfoMETA& updateInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrUpdatePassthroughColorLutMETA(this->get(), updateInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_META_passthrough_color_lut


#ifdef XR_QCOM_tracking_optimization_settings

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::setTrackingOptimizationSettingsHintQCOM (
    TrackingOptimizationSettingsDomainQCOM domain, TrackingOptimizationSettingsHintQCOM hint, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrSetTrackingOptimizationSettingsHintQCOM(this->get(), OPENXR_HPP_NAMESPACE::get(domain), OPENXR_HPP_NAMESPACE::get(hint)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_QCOM_tracking_optimization_settings


#ifdef XR_HTC_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PassthroughHTC> Session::createPassthroughHTC (
    const PassthroughCreateInfoHTC& createInfo, Dispatch&& d) const {
    PassthroughHTC handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughHTC(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PassthroughHTC, impl::RemoveRefConst<Dispatch>>> Session::createPassthroughUniqueHTC (
    const PassthroughCreateInfoHTC& createInfo, Dispatch&& d) const {
    PassthroughHTC handle;
    Result result = static_cast<Result>( d.xrCreatePassthroughHTC(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<PassthroughHTC, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_passthrough


#ifdef XR_HTC_passthrough

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PassthroughHTC::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPassthroughHTC(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_passthrough


#ifdef XR_HTC_foveation

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Session::applyFoveationHTC (
    const FoveationApplyInfoHTC& applyInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrApplyFoveationHTC(this->get(), applyInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_HTC_foveation


#ifdef XR_MNDX_force_feedback_curl

































template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result HandTrackerEXT::applyForceFeedbackCurlMNDX (
    const ForceFeedbackCurlApplyLocationsMNDX& locations, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrApplyForceFeedbackCurlMNDX(this->get(), locations.get()) );
    
        #ifdef OPENXR_HPP_NO_EXCEPTIONS
    OPENXR_HPP_ASSERT( succeeded(result) );
#else
    if (!(succeeded(result))) {
        exceptions::throwResultException(result, OPENXR_HPP_NAMESPACE_STRING "::HandTrackerEXT::applyForceFeedbackCurlMNDX");
    }
#endif



    return result;
}


#endif  // XR_MNDX_force_feedback_curl


#ifdef XR_EXT_plane_detection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PlaneDetectorEXT> Session::createPlaneDetectorEXT (
    const PlaneDetectorCreateInfoEXT& createInfo, Dispatch&& d) const {
    PlaneDetectorEXT handle;
    Result result = static_cast<Result>( d.xrCreatePlaneDetectorEXT(this->get(), createInfo.get(), handle.put()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(handle) };
}

#ifndef OPENXR_HPP_NO_SMART_HANDLE

template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<UniqueHandle<PlaneDetectorEXT, impl::RemoveRefConst<Dispatch>>> Session::createPlaneDetectorUniqueEXT (
    const PlaneDetectorCreateInfoEXT& createInfo, Dispatch&& d) const {
    PlaneDetectorEXT handle;
    Result result = static_cast<Result>( d.xrCreatePlaneDetectorEXT(this->get(), createInfo.get(), handle.put()) );
    ObjectDestroy<impl::RemoveRefConst<Dispatch>> deleter{d};
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, UniqueHandle<PlaneDetectorEXT, impl::RemoveRefConst<Dispatch>>(handle, deleter) };
}









#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_plane_detection


#ifdef XR_EXT_plane_detection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PlaneDetectorEXT::destroy (
    Dispatch&& d)  {
    
    Result result = static_cast<Result>( d.xrDestroyPlaneDetectorEXT(this->get()) );
    val_ = XR_NULL_HANDLE;
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_plane_detection


#ifdef XR_EXT_plane_detection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result PlaneDetectorEXT::beginPlaneDetectionEXT (
    const PlaneDetectorBeginInfoEXT& beginInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrBeginPlaneDetectionEXT(this->get(), beginInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_plane_detection


#ifdef XR_EXT_plane_detection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PlaneDetectionStateEXT> PlaneDetectorEXT::getPlaneDetectionStateEXT (
    Dispatch&& d) const {
    XrPlaneDetectionStateEXT state_tmp;
    PlaneDetectionStateEXT state;
    Result result = static_cast<Result>( d.xrGetPlaneDetectionStateEXT(this->get(), &state_tmp) );
    state = static_cast<PlaneDetectionStateEXT>(state_tmp);
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(state) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_plane_detection


#ifdef XR_EXT_plane_detection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PlaneDetectorLocationsEXT> PlaneDetectorEXT::getPlaneDetectionsEXT (
    const PlaneDetectorGetInfoEXT& info, Dispatch&& d) const {
    PlaneDetectorLocationsEXT locations;
    Result result = static_cast<Result>( d.xrGetPlaneDetectionsEXT(this->get(), info.get(), OPENXR_HPP_NAMESPACE::put(locations)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(locations) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_plane_detection


#ifdef XR_EXT_plane_detection

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE ResultValue<PlaneDetectorPolygonBufferEXT> PlaneDetectorEXT::getPlanePolygonBufferEXT (
    uint64_t planeId, uint32_t polygonBufferIndex, Dispatch&& d) const {
    PlaneDetectorPolygonBufferEXT polygonBuffer;
    Result result = static_cast<Result>( d.xrGetPlanePolygonBufferEXT(this->get(), planeId, polygonBufferIndex, OPENXR_HPP_NAMESPACE::put(polygonBuffer)) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return { result, std::move(polygonBuffer) };
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_EXT_plane_detection


#ifdef XR_ML_user_calibration

































#ifdef OPENXR_HPP_NO_EXCEPTIONS
template <typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch)>
OPENXR_HPP_INLINE Result Instance::enableUserCalibrationEventsML (
    const UserCalibrationEnableEventsInfoML& enableInfo, Dispatch&& d) const {
    
    Result result = static_cast<Result>( d.xrEnableUserCalibrationEventsML(this->get(), enableInfo.get()) );
    
            OPENXR_HPP_ASSERT( succeeded(result) );


    return result;
}

#endif // OPENXR_HPP_NO_EXCEPTIONS

#endif  // XR_ML_user_calibration
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE
































#endif  // ifndef OPENXR_METHOD_IMPLS_ENHANCED_INL_

